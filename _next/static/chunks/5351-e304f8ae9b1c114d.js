!(function () {
  try {
    var e =
        "undefined" != typeof window
          ? window
          : "undefined" != typeof global
          ? global
          : "undefined" != typeof self
          ? self
          : {},
      t = new e.Error().stack;
    t &&
      ((e._sentryDebugIds = e._sentryDebugIds || {}),
      (e._sentryDebugIds[t] = "9f2c62fe-8d0c-4aa2-802f-e91abc693d39"),
      (e._sentryDebugIdIdentifier =
        "sentry-dbid-9f2c62fe-8d0c-4aa2-802f-e91abc693d39"));
  } catch (e) {}
})(),
  (self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [5351],
    {
      18106: function (e, t, n) {
        "use strict";
        var s =
          (this && this.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ParsedMessage = void 0);
        let i = s(n(75528)),
          a = s(n(28737)),
          o = n(37705),
          l = `
sign-in-with-ethereum =
    [ scheme "://" ] domain %s" wants you to sign in with your Ethereum account:" LF
    address LF
    LF
    [ statement LF ]
    LF
    %s"URI: " URI LF
    %s"Version: " version LF
    %s"Chain ID: " chain-id LF
    %s"Nonce: " nonce LF
    %s"Issued At: " issued-at
    [ LF %s"Expiration Time: " expiration-time ]
    [ LF %s"Not Before: " not-before ]
    [ LF %s"Request ID: " request-id ]
    [ LF %s"Resources:"
    resources ]

domain = authority

address = "0x" 40*40HEXDIG
    ; Must also conform to captilization
    ; checksum encoding specified in EIP-55
    ; where applicable (EOAs).

statement = 1*( reserved / unreserved / " " )
    ; The purpose is to exclude LF (line breaks).

version = "1"

nonce = 8*( ALPHA / DIGIT )

issued-at = date-time
expiration-time = date-time
not-before = date-time

request-id = *pchar

chain-id = 1*DIGIT
    ; See EIP-155 for valid CHAIN_IDs.

resources = *( LF resource )

resource = "- " URI

; ------------------------------------------------------------------------------
; RFC 3986

URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

hier-part     = "//" authority path-abempty
              / path-absolute
              / path-rootless
              / path-empty

scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )

authority     = [ userinfo "@" ] host [ ":" port ]
userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
host          = IP-literal / IPv4address / reg-name
port          = *DIGIT

IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"

IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )

IPv6address   =                            6( h16 ":" ) ls32
              /                       "::" 5( h16 ":" ) ls32
              / [               h16 ] "::" 4( h16 ":" ) ls32
              / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
              / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
              / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
              / [ *4( h16 ":" ) h16 ] "::"              ls32
              / [ *5( h16 ":" ) h16 ] "::"              h16
              / [ *6( h16 ":" ) h16 ] "::"

h16           = 1*4HEXDIG
ls32          = ( h16 ":" h16 ) / IPv4address
IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet
dec-octet     = DIGIT                 ; 0-9
                 / %x31-39 DIGIT         ; 10-99
                 / "1" 2DIGIT            ; 100-199
                 / "2" %x30-34 DIGIT     ; 200-249
                 / "25" %x30-35          ; 250-255

reg-name      = *( unreserved / pct-encoded / sub-delims )

path-abempty  = *( "/" segment )
path-absolute = "/" [ segment-nz *( "/" segment ) ]
path-rootless = segment-nz *( "/" segment )
path-empty    = 0pchar

segment       = *pchar
segment-nz    = 1*pchar

pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"

query         = *( pchar / "/" / "?" )

fragment      = *( pchar / "/" / "?" )

pct-encoded   = "%" HEXDIG HEXDIG

unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
reserved      = gen-delims / sub-delims
gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
              / "*" / "+" / "," / ";" / "="

; ------------------------------------------------------------------------------
; RFC 3339

date-fullyear   = 4DIGIT
date-month      = 2DIGIT  ; 01-12
date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
                          ; month/year
time-hour       = 2DIGIT  ; 00-23
time-minute     = 2DIGIT  ; 00-59
time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second
                          ; rules
time-secfrac    = "." 1*DIGIT
time-numoffset  = ("+" / "-") time-hour ":" time-minute
time-offset     = "Z" / time-numoffset

partial-time    = time-hour ":" time-minute ":" time-second
                  [time-secfrac]
full-date       = date-fullyear "-" date-month "-" date-mday
full-time       = partial-time time-offset

date-time       = full-date "T" full-time

; ------------------------------------------------------------------------------
; RFC 5234

ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z
LF             =  %x0A
                  ; linefeed
DIGIT          =  %x30-39
                  ; 0-9
HEXDIG         =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
`;
        class u {
          static generateApi() {
            let e = new i.default(l);
            if ((e.generate(), e.errors.length))
              throw (
                (console.error(e.errorsToAscii()),
                console.error(e.linesToAscii()),
                console.log(e.displayAttributeErrors()),
                Error("ABNF grammar has errors"))
              );
            return e.toObject();
          }
        }
        u.grammarObj = u.generateApi();
        class c {
          constructor(e) {
            let t = new a.default.parser();
            t.ast = new a.default.ast();
            let n = a.default.ids;
            (t.ast.callbacks.scheme = function (e, t, s, i, o) {
              let l = n.SEM_OK;
              return (
                e === n.SEM_PRE &&
                  0 === s &&
                  (o.scheme = a.default.utils.charsToString(t, s, i)),
                l
              );
            }),
              (t.ast.callbacks.domain = function (e, t, s, i, o) {
                let l = n.SEM_OK;
                return (
                  e === n.SEM_PRE &&
                    (o.domain = a.default.utils.charsToString(t, s, i)),
                  l
                );
              }),
              (t.ast.callbacks.address = function (e, t, s, i, o) {
                let l = n.SEM_OK;
                return (
                  e === n.SEM_PRE &&
                    (o.address = a.default.utils.charsToString(t, s, i)),
                  l
                );
              }),
              (t.ast.callbacks.statement = function (e, t, s, i, o) {
                let l = n.SEM_OK;
                return (
                  e === n.SEM_PRE &&
                    (o.statement = a.default.utils.charsToString(t, s, i)),
                  l
                );
              }),
              (t.ast.callbacks.uri = function (e, t, s, i, o) {
                let l = n.SEM_OK;
                return (
                  e !== n.SEM_PRE ||
                    o.uri ||
                    (o.uri = a.default.utils.charsToString(t, s, i)),
                  l
                );
              }),
              (t.ast.callbacks.version = function (e, t, s, i, o) {
                let l = n.SEM_OK;
                return (
                  e === n.SEM_PRE &&
                    (o.version = a.default.utils.charsToString(t, s, i)),
                  l
                );
              }),
              (t.ast.callbacks["chain-id"] = function (e, t, s, i, l) {
                let u = n.SEM_OK;
                return (
                  e === n.SEM_PRE &&
                    (l.chainId = (0, o.parseIntegerNumber)(
                      a.default.utils.charsToString(t, s, i)
                    )),
                  u
                );
              }),
              (t.ast.callbacks.nonce = function (e, t, s, i, o) {
                let l = n.SEM_OK;
                return (
                  e === n.SEM_PRE &&
                    (o.nonce = a.default.utils.charsToString(t, s, i)),
                  l
                );
              }),
              (t.ast.callbacks["issued-at"] = function (e, t, s, i, o) {
                let l = n.SEM_OK;
                return (
                  e === n.SEM_PRE &&
                    (o.issuedAt = a.default.utils.charsToString(t, s, i)),
                  l
                );
              }),
              (t.ast.callbacks["expiration-time"] = function (e, t, s, i, o) {
                let l = n.SEM_OK;
                return (
                  e === n.SEM_PRE &&
                    (o.expirationTime = a.default.utils.charsToString(t, s, i)),
                  l
                );
              }),
              (t.ast.callbacks["not-before"] = function (e, t, s, i, o) {
                let l = n.SEM_OK;
                return (
                  e === n.SEM_PRE &&
                    (o.notBefore = a.default.utils.charsToString(t, s, i)),
                  l
                );
              }),
              (t.ast.callbacks["request-id"] = function (e, t, s, i, o) {
                let l = n.SEM_OK;
                return (
                  e === n.SEM_PRE &&
                    (o.requestId = a.default.utils.charsToString(t, s, i)),
                  l
                );
              }),
              (t.ast.callbacks.resources = function (e, t, s, i, o) {
                let l = n.SEM_OK;
                return (
                  e === n.SEM_PRE &&
                    (o.resources = a.default.utils
                      .charsToString(t, s, i)
                      .slice(3)
                      .split("\n- ")),
                  l
                );
              });
            let s = t.parse(u.grammarObj, "sign-in-with-ethereum", e);
            if (!s.success)
              throw Error(`Invalid message: ${JSON.stringify(s)}`);
            let i = {};
            for (let [e, n] of (t.ast.translate(i), Object.entries(i)))
              this[e] = n;
            if (0 === this.domain.length)
              throw Error("Domain cannot be empty.");
            if (!(0, o.isEIP55Address)(this.address))
              throw Error("Address not conformant to EIP-55.");
          }
        }
        t.ParsedMessage = c;
      },
      20200: function (e, t, n) {
        "use strict";
        var s =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, n, s) {
                  void 0 === s && (s = n);
                  var i = Object.getOwnPropertyDescriptor(t, n);
                  (!i ||
                    ("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) &&
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[n];
                      },
                    }),
                    Object.defineProperty(e, s, i);
                }
              : function (e, t, n, s) {
                  void 0 === s && (s = n), (e[s] = t[n]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var n in e)
                "default" === n ||
                  Object.prototype.hasOwnProperty.call(t, n) ||
                  s(t, e, n);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ParsedMessage = void 0);
        let a = n(18106);
        Object.defineProperty(t, "ParsedMessage", {
          enumerable: !0,
          get: function () {
            return a.ParsedMessage;
          },
        }),
          i(n(37705), t);
      },
      37705: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.parseIntegerNumber = t.isEIP55Address = void 0);
        let s = n(85426),
          i = n(98089);
        (t.isEIP55Address = (e) => {
          if (42 != e.length) return !1;
          let t = `${e}`.toLowerCase().replace("0x", ""),
            n = (0, i.bytesToHex)((0, s.keccak_256)(t)),
            a = "0x";
          for (let e = 0; e < t.length; e++)
            parseInt(n[e], 16) >= 8 ? (a += t[e].toUpperCase()) : (a += t[e]);
          return e === a;
        }),
          (t.parseIntegerNumber = (e) => {
            let t = parseInt(e);
            if (isNaN(t) || t === 1 / 0) throw Error("Invalid number.");
            return t;
          });
      },
      75528: function (e, t, n) {
        e.exports = function (e) {
          let t;
          let { Buffer: s } = n(48764),
            i = "api.js: ",
            a = this,
            o = n(28737),
            l = n(20979),
            u = n(1789),
            c = new (n(73737))(),
            {
              attributes: d,
              showAttributes: h,
              showAttributeErrors: p,
              showRuleDependencies: f,
            } = n(68862),
            g = n(2595),
            m = function (e, t, n) {
              let s;
              let i = `<span class="${o.style.CLASS_CTRLCHAR}">`,
                a = "</span>",
                l = `<span class="${o.style.CLASS_NOMATCH}">`,
                u = "</span>",
                c = "";
              for (; Array.isArray(e) && 0 !== e.length; ) {
                if ("number" != typeof t)
                  throw Error("abnfToHtml: beg must be type number");
                if (t >= e.length) break;
                s =
                  "number" != typeof n || t + n >= e.length ? e.length : t + n;
                let d = 0;
                for (let n = t; n < s; n += 1) {
                  let t = e[n];
                  if (t >= 32 && t <= 126)
                    switch (
                      (1 === d
                        ? ((c += a), (d = 0))
                        : 2 === d && ((c += u), (d = 0)),
                      t)
                    ) {
                      case 32:
                        c += "&nbsp;";
                        break;
                      case 60:
                        c += "&lt;";
                        break;
                      case 62:
                        c += "&gt;";
                        break;
                      case 38:
                        c += "&amp;";
                        break;
                      case 34:
                        c += "&quot;";
                        break;
                      case 39:
                        c += "&#039;";
                        break;
                      case 92:
                        c += "&#092;";
                        break;
                      default:
                        c += String.fromCharCode(t);
                    }
                  else
                    9 === t || 10 === t || 13 === t
                      ? (0 === d
                          ? ((c += i), (d = 1))
                          : 2 === d && ((c += u + i), (d = 1)),
                        9 === t && (c += "TAB"),
                        10 === t && (c += "LF"),
                        13 === t && (c += "CR"))
                      : (0 === d
                          ? ((c += l), (d = 2))
                          : 1 === d && ((c += a + l), (d = 2)),
                        (c += `\\x${o.utils.charToHex(t)}`));
                }
                2 === d && (c += u), 1 === d && (c += a);
                break;
              }
              return c;
            },
            y = function (e, t, n) {
              let s = "";
              for (let i = t; i < t + n; i += 1) {
                let t = e[i];
                if (t >= 32 && t <= 126) s += String.fromCharCode(t);
                else
                  switch (t) {
                    case 9:
                      s += "\\t";
                      break;
                    case 10:
                      s += "\\n";
                      break;
                    case 13:
                      s += "\\r";
                      break;
                    default:
                      s += "\\unknown";
                  }
              }
              return s;
            },
            b = function (e) {
              let t = "Annotated Input Grammar";
              return (
                e.forEach((e) => {
                  t += `
line no: ${e.lineNo} : char index: ${e.beginChar} : length: ${
                    e.length
                  } : abnf: ${y(a.chars, e.beginChar, e.length)}`;
                }),
                (t += "\n")
              );
            },
            A = function (e) {
              let t = "";
              return (
                (t += `<table class="${o.style.CLASS_GRAMMAR}">
<caption>Annotated Input Grammar</caption>
<tr><th>line<br>no.</th><th>first<br>char</th><th><br>length</th><th><br>text</th></tr>
`),
                e.forEach((e) => {
                  t += `<tr><td>${e.lineNo}</td><td>${e.beginChar}</td><td>${
                    e.length
                  }</td><td>${m(a.chars, e.beginChar, e.length)}</td></tr>
`;
                }),
                (t += "</table>\n")
              );
            },
            w = function (e, t, n, s) {
              let [i] = o,
                a = "",
                l = `<span class="${i.CLASS_NOMATCH}">&raquo;</span>`;
              return (
                (a += `<p><table class="${i.CLASS_GRAMMAR}">
`),
                s &&
                  "string" == typeof s &&
                  (a += `<caption>${s}</caption>
`),
                (a +=
                  "<tr><th>line<br>no.</th><th>line<br>offset</th><th>error<br>offset</th><th><br>text</th></tr>\n"),
                e.forEach((e) => {
                  let s, i, u, c, d;
                  let h = "",
                    p = "";
                  0 === t.length
                    ? ((d = l), (i = 0))
                    : ((u = (s = t[e.line]).beginChar),
                      e.char > u && (h = m(n, u, e.char - u)),
                      (u = e.char) < (c = s.beginChar + s.length) &&
                        (p = m(n, u, c - u)),
                      (d = h + l + p),
                      (i = e.char - s.beginChar),
                      (a += `<tr><td>${e.line}</td><td>${
                        s.beginChar
                      }</td><td>${i}</td><td>${d}</td></tr>
<tr><td colspan="3"></td><td>&uarr;:&nbsp;${o.utils.stringToAsciiHtml(
                        e.msg
                      )}</td></tr>
`));
                }),
                (a += "</table></p>\n")
              );
            },
            v = function (e, t, n) {
              let s, i, a, o;
              return (
                (s = ""),
                e.forEach((e) => {
                  (i = t[e.line]),
                    (s += `${i.lineNo}: ${i.beginChar}: ${
                      e.char - i.beginChar
                    }: `),
                    (a = i.beginChar),
                    (o = e.char - i.beginChar),
                    (s += y(n, a, o) + " >> "),
                    (a = e.char),
                    (o = i.beginChar + i.length - e.char),
                    (s +=
                      y(n, a, o) +
                      "\n" +
                      `${i.lineNo}: ` +
                      `${i.beginChar}: ` +
                      `${e.char - i.beginChar}: ` +
                      "error: " +
                      e.msg +
                      "\n");
                }),
                s
              );
            },
            E = !1,
            P = !1,
            k = !1,
            T = !1,
            x = 0;
          if (((this.errors = []), s.isBuffer(e)))
            this.chars = l.decode("BINARY", e);
          else if (Array.isArray(e)) this.chars = e.slice();
          else if ("string" == typeof e) this.chars = l.decode("STRING", e);
          else
            throw Error(
              `${i}input source is not a string, byte Buffer or character array`
            );
          (this.sabnf = l.encode("STRING", this.chars)),
            (this.scan = function (e, t) {
              (this.lines = u(this.chars, this.errors, e, t)), (E = !0);
            }),
            (this.parse = function (e, t, n) {
              if (!E) throw Error(`${i}grammar not scanned`);
              c.syntax(this.chars, this.lines, this.errors, e, t, n), (P = !0);
            }),
            (this.translate = function () {
              if (!P) throw Error(`${i}grammar not scanned and parsed`);
              let e = c.semantic(this.chars, this.lines, this.errors);
              0 === this.errors.length &&
                ((this.rules = e.rules),
                (this.udts = e.udts),
                (t = e.lineMap),
                (k = !0));
            }),
            (this.attributes = function () {
              if (!k)
                throw Error(`${i}grammar not scanned, parsed and translated`);
              return (
                (x = d(this.rules, this.udts, t, this.errors)), (T = !0), x
              );
            }),
            (this.generate = function (e) {
              if (
                ((this.lines = u(this.chars, this.errors, e)),
                this.errors.length ||
                  (c.syntax(this.chars, this.lines, this.errors, e),
                  this.errors.length))
              )
                return;
              let n = c.semantic(this.chars, this.lines, this.errors);
              this.errors.length ||
                ((this.rules = n.rules),
                (this.udts = n.udts),
                (t = n.lineMap),
                (x = d(this.rules, this.udts, t, this.errors)),
                (T = !0));
            }),
            (this.displayRules = function (e = "index") {
              if (!k)
                throw Error(`${i}grammar not scanned, parsed and translated`);
              return g(this.rules, this.udts, e);
            }),
            (this.displayRuleDependencies = function (e = "index") {
              if (!T)
                throw Error(
                  `${i}no attributes - must be preceeded by call to attributes()`
                );
              return f(e);
            }),
            (this.displayAttributes = function (e = "index") {
              if (!T)
                throw Error(
                  `${i}no attributes - must be preceeded by call to attributes()`
                );
              return x && p(e), h(e);
            }),
            (this.displayAttributeErrors = function () {
              if (!T)
                throw Error(
                  `${i}no attributes - must be preceeded by call to attributes()`
                );
              return p();
            }),
            (this.toSource = function (e) {
              if (!T)
                throw Error(
                  `${i}can't generate parser source - must be preceeded by call to attributes()`
                );
              if (x)
                throw Error(
                  `${i}can't generate parser source - attributes have ${x} errors`
                );
              return c.generateSource(
                this.chars,
                this.lines,
                this.rules,
                this.udts,
                e
              );
            }),
            (this.toObject = function () {
              if (!T)
                throw Error(
                  `${i}can't generate parser source - must be preceeded by call to attributes()`
                );
              if (x)
                throw Error(
                  `${i}can't generate parser source - attributes have ${x} errors`
                );
              return c.generateObject(this.sabnf, this.rules, this.udts);
            }),
            (this.errorsToAscii = function () {
              return v(this.errors, this.lines, this.chars);
            }),
            (this.errorsToHtml = function (e) {
              return w(this.errors, this.lines, this.chars, e);
            }),
            (this.linesToAscii = function () {
              return b(this.lines);
            }),
            (this.linesToHtml = function () {
              return A(this.lines);
            });
        };
      },
      68862: function (e, t, n) {
        e.exports = (function () {
          let e = n(58276),
            {
              ruleAttributes: t,
              showAttributes: s,
              showAttributeErrors: i,
            } = n(94246),
            { ruleDependencies: a, showRuleDependencies: o } = n(37008);
          class l {
            constructor(e, t) {
              (this.rules = e),
                (this.udts = t),
                (this.ruleCount = e.length),
                (this.udtCount = t.length),
                (this.startRule = 0),
                (this.dependenciesComplete = !1),
                (this.attributesComplete = !1),
                (this.isMutuallyRecursive = !1),
                (this.ruleIndexes = this.indexArray(this.ruleCount)),
                (this.ruleAlphaIndexes = this.indexArray(this.ruleCount)),
                (this.ruleTypeIndexes = this.indexArray(this.ruleCount)),
                (this.udtIndexes = this.indexArray(this.udtCount)),
                (this.udtAlphaIndexes = this.indexArray(this.udtCount)),
                (this.attrsErrorCount = 0),
                (this.attrs = []),
                (this.attrsErrors = []),
                (this.attrsWorking = []),
                (this.ruleDeps = []);
              for (let t = 0; t < this.ruleCount; t += 1)
                this.attrs.push(this.attrGen(this.rules[t])),
                  this.attrsWorking.push(this.attrGen(this.rules[t])),
                  this.ruleDeps.push(
                    this.rdGen(e[t], this.ruleCount, this.udtCount)
                  );
              (this.compRulesAlpha = this.compRulesAlpha.bind(this)),
                (this.compUdtsAlpha = this.compUdtsAlpha.bind(this)),
                (this.compRulesType = this.compRulesType.bind(this)),
                (this.compRulesGroup = this.compRulesGroup.bind(this));
            }
            attrGen(e) {
              return {
                left: !1,
                nested: !1,
                right: !1,
                empty: !1,
                finite: !1,
                cyclic: !1,
                leaf: !1,
                isOpen: !1,
                isComplete: !1,
                rule: e,
              };
            }
            attrInit(e) {
              (e.left = !1),
                (e.nested = !1),
                (e.right = !1),
                (e.empty = !1),
                (e.finite = !1),
                (e.cyclic = !1),
                (e.leaf = !1),
                (e.isOpen = !1),
                (e.isComplete = !1);
            }
            attrCopy(e, t) {
              (e.left = t.left),
                (e.nested = t.nested),
                (e.right = t.right),
                (e.empty = t.empty),
                (e.finite = t.finite),
                (e.cyclic = t.cyclic),
                (e.leaf = t.leaf),
                (e.isOpen = t.isOpen),
                (e.isComplete = t.isComplete),
                (e.rule = t.rule);
            }
            rdGen(t, n, s) {
              return {
                rule: t,
                recursiveType: e.ATTR_N,
                groupNumber: -1,
                refersTo: this.falseArray(n),
                refersToUdt: this.falseArray(s),
                referencedBy: this.falseArray(n),
              };
            }
            typeToString(t) {
              switch (t) {
                case e.ATTR_N:
                  return " N";
                case e.ATTR_R:
                  return " R";
                case e.ATTR_MR:
                  return "MR";
                default:
                  return "UNKNOWN";
              }
            }
            falseArray(e) {
              let t = [];
              if (e > 0) for (let n = 0; n < e; n += 1) t.push(!1);
              return t;
            }
            falsifyArray(e) {
              for (let t = 0; t < e.length; t += 1) e[t] = !1;
            }
            indexArray(e) {
              let t = [];
              if (e > 0) for (let n = 0; n < e; n += 1) t.push(n);
              return t;
            }
            compRulesAlpha(e, t) {
              return this.rules[e].lower < this.rules[t].lower
                ? -1
                : this.rules[e].lower > this.rules[t].lower
                ? 1
                : 0;
            }
            compUdtsAlpha(e, t) {
              return this.udts[e].lower < this.udts[t].lower
                ? -1
                : this.udts[e].lower > this.udts[t].lower
                ? 1
                : 0;
            }
            compRulesType(e, t) {
              return this.ruleDeps[e].recursiveType <
                this.ruleDeps[t].recursiveType
                ? -1
                : this.ruleDeps[e].recursiveType >
                  this.ruleDeps[t].recursiveType
                ? 1
                : 0;
            }
            compRulesGroup(t, n) {
              if (
                this.ruleDeps[t].recursiveType === e.ATTR_MR &&
                this.ruleDeps[n].recursiveType === e.ATTR_MR
              ) {
                if (this.ruleDeps[t].groupNumber < this.ruleDeps[n].groupNumber)
                  return -1;
                if (this.ruleDeps[t].groupNumber > this.ruleDeps[n].groupNumber)
                  return 1;
              }
              return 0;
            }
          }
          return {
            attributes: function (e = [], n = [], s = [], i = []) {
              let o = new l(e, n);
              return (
                a(o),
                t(o),
                o.attrsErrorCount &&
                  i.push({
                    line: 0,
                    char: 0,
                    msg: `${o.attrsErrorCount} attribute errors`,
                  }),
                o.attrsErrorCount
              );
            },
            showAttributes: s,
            showAttributeErrors: i,
            showRuleDependencies: o,
          };
        })();
      },
      73737: function (e, t, n) {
        e.exports = function () {
          let e = n(28737),
            t = e.ids,
            s = new (n(74216))(),
            i = new (n(11832))(),
            a = new (n(33610))(),
            o = new e.parser();
          (o.ast = new e.ast()),
            (o.callbacks = s.callbacks),
            (o.ast.callbacks = i.callbacks);
          let l = function (e, t, n) {
              if (t < 0 || t >= n) return -1;
              for (let n = 0; n < e.length; n += 1)
                if (t >= e[n].beginChar && t < e[n].beginChar + e[n].length)
                  return n;
              return -1;
            },
            u = function (e, t) {
              let n = -1;
              if (t < e.length) {
                for (let s = t; s < e.length; s += 1)
                  if (null !== e[s]) {
                    n = e[s];
                    break;
                  }
              }
              return n;
            },
            c = function (e) {
              e.forEach((e) => {
                let n = [],
                  s = [],
                  i = 0;
                e.opcodes.forEach((e) => {
                  e.type === t.ALT && 1 === e.children.length
                    ? s.push(null)
                    : e.type === t.CAT && 1 === e.children.length
                    ? s.push(null)
                    : e.type === t.REP && 1 === e.min && 1 === e.max
                    ? s.push(null)
                    : (s.push(i), n.push(e), (i += 1));
                }),
                  s.push(i),
                  n.forEach((e) => {
                    if (e.type === t.ALT || e.type === t.CAT)
                      for (let t = 0; t < e.children.length; t += 1)
                        e.children[t] = u(s, e.children[t]);
                  }),
                  (e.opcodes = n);
              });
            };
          (this.syntax = function (e, t, n, s, i, u) {
            if (u) {
              if ("traceObject" !== u.traceObject)
                throw TypeError("parser: trace argument is not a trace object");
              o.trace = u;
            }
            let c = {};
            (c.errors = n),
              (c.strict = !!s),
              (c.lite = !!i),
              (c.lines = t),
              (c.findLine = l),
              (c.charsLength = e.length),
              (c.ruleCount = 0),
              o.parse(a, "file", e, c).success ||
                n.push({
                  line: 0,
                  char: 0,
                  msg: "syntax analysis of input grammar failed",
                });
          }),
            (this.semantic = function (e, t, n) {
              let s = {};
              return ((s.errors = n),
              (s.lines = t),
              (s.findLine = l),
              (s.charsLength = e.length),
              o.ast.translate(s),
              n.length)
                ? null
                : (c(s.rules),
                  { rules: s.rules, udts: s.udts, lineMap: s.rulesLineMap });
            }),
            (this.generateSource = function (e, n, s, i, a) {
              let o,
                l,
                u,
                c,
                d = "",
                h = !1,
                p = !1;
              a &&
                (a.typescript
                  ? ((h = !0), (p = !1))
                  : a.lite && ((h = !1), (p = !0)));
              let f = 0,
                g = 1 / 0,
                m = 0,
                y = [],
                b = [],
                A = 0,
                w = 0,
                v = 0,
                E = 0,
                P = 0,
                k = 0,
                T = 0,
                x = 0,
                O = 0,
                S = 0,
                C = 0,
                B = 0,
                N = 0,
                R = 0,
                I = 0;
              return (
                s.forEach((e) => {
                  y.push(e.lower),
                    (f += e.opcodes.length),
                    e.opcodes.forEach((e) => {
                      switch (e.type) {
                        case t.ALT:
                          A += 1;
                          break;
                        case t.CAT:
                          w += 1;
                          break;
                        case t.RNM:
                          v += 1;
                          break;
                        case t.UDT:
                          E += 1;
                          break;
                        case t.REP:
                          P += 1;
                          break;
                        case t.AND:
                          k += 1;
                          break;
                        case t.NOT:
                          T += 1;
                          break;
                        case t.BKA:
                          B += 1;
                          break;
                        case t.BKN:
                          N += 1;
                          break;
                        case t.BKR:
                          C += 1;
                          break;
                        case t.ABG:
                          R += 1;
                          break;
                        case t.AEN:
                          I += 1;
                          break;
                        case t.TLS:
                          for (x += 1, o = 0; o < e.string.length; o += 1)
                            e.string[o] < g && (g = e.string[o]),
                              e.string[o] > m && (m = e.string[o]);
                          break;
                        case t.TBS:
                          for (O += 1, o = 0; o < e.string.length; o += 1)
                            e.string[o] < g && (g = e.string[o]),
                              e.string[o] > m && (m = e.string[o]);
                          break;
                        case t.TRG:
                          (S += 1),
                            e.min < g && (g = e.min),
                            e.max > m && (m = e.max);
                          break;
                        default:
                          throw Error("generateSource: unrecognized opcode");
                      }
                    });
                }),
                y.sort(),
                i.length > 0 &&
                  (i.forEach((e) => {
                    b.push(e.lower);
                  }),
                  b.sort()),
                (d +=
                  "// copyright: Copyright (c) 2024 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.4.0 [apg-js](https://github.com/ldthomas/apg-js)\n"),
                a
                  ? a.funcName
                    ? (d += `const ${a.funcName} = function grammar(){
`)
                    : h
                    ? (d += "export function grammar(){\n")
                    : p
                    ? (d += "export default function grammar(){\n")
                    : (d += `module.exports = function grammar(){
`)
                  : (d += `module.exports = function grammar(){
`),
                (d += `  // \`\`\`
  // SUMMARY
  //      rules = ${s.length}
  //       udts = ${i.length}
  //    opcodes = ${f}
  //        ---   ABNF original opcodes
  //        ALT = ${A}
  //        CAT = ${w}
  //        REP = ${P}
  //        RNM = ${v}
  //        TLS = ${x}
  //        TBS = ${O}
  //        TRG = ${S}
  //        ---   SABNF superset opcodes
  //        UDT = ${E}
  //        AND = ${k}
  //        NOT = ${T}
`),
                p ||
                  (d += `  //        BKA = ${B}
  //        BKN = ${N}
  //        BKR = ${C}
  //        ABG = ${R}
  //        AEN = ${I}
`),
                (d += "  // characters = ["),
                x + O + S === 0
                  ? (d += " none defined ]")
                  : (d += `${g} - ${m}]`),
                E > 0 && (d += " + user defined"),
                (d +=
                  "\n  // ```\n  /* OBJECT IDENTIFIER (for internal parser use) */\n  this.grammarObject = 'grammarObject';\n\n  /* RULES */\n  this.rules = [];\n"),
                s.forEach((e, t) => {
                  let n = "  this.rules[";
                  (n +=
                    t +
                    "] = { name: '" +
                    e.name +
                    "', lower: '" +
                    e.lower +
                    "', index: " +
                    e.index +
                    ", isBkr: " +
                    e.isBkr +
                    " };\n"),
                    (d += n);
                }),
                (d += "\n  /* UDTS */\n  this.udts = [];\n"),
                i.length > 0 &&
                  i.forEach((e, t) => {
                    let n = "  this.udts[";
                    (n +=
                      t +
                      "] = { name: '" +
                      e.name +
                      "', lower: '" +
                      e.lower +
                      "', index: " +
                      e.index +
                      ", empty: " +
                      e.empty +
                      ", isBkr: " +
                      e.isBkr +
                      " };\n"),
                      (d += n);
                  }),
                (d += "\n  /* OPCODES */\n"),
                s.forEach((e, n) => {
                  n > 0 && (d += "\n"),
                    (d += `  /* ${e.name} */
  this.rules[${n}].opcodes = [];
`),
                    e.opcodes.forEach((e, a) => {
                      let o;
                      switch (e.type) {
                        case t.ALT:
                          d += `  this.rules[${n}].opcodes[${a}] = { type: ${
                            e.type
                          }, children: [${e.children.toString()}] };// ALT
`;
                          break;
                        case t.CAT:
                          d += `  this.rules[${n}].opcodes[${a}] = { type: ${
                            e.type
                          }, children: [${e.children.toString()}] };// CAT
`;
                          break;
                        case t.RNM:
                          d += `  this.rules[${n}].opcodes[${a}] = { type: ${
                            e.type
                          }, index: ${e.index} };// RNM(${s[e.index].name})
`;
                          break;
                        case t.BKR:
                          e.index >= s.length
                            ? ((l = i[e.index - s.length].name),
                              (u = i[e.index - s.length].lower))
                            : ((l = s[e.index].name), (u = s[e.index].lower)),
                            (o = "%i"),
                            e.bkrCase === t.BKR_MODE_CS && (o = "%s"),
                            e.bkrMode === t.BKR_MODE_UM
                              ? (o += "%u")
                              : (o += "%p"),
                            (l = o + l),
                            (d += `  this.rules[${n}].opcodes[${a}] = { type: ${e.type}, index: ${e.index}, lower: '${u}', bkrCase: ${e.bkrCase}, bkrMode: ${e.bkrMode} };// BKR(\\${l})
`);
                          break;
                        case t.UDT:
                          d += `  this.rules[${n}].opcodes[${a}] = { type: ${
                            e.type
                          }, empty: ${e.empty}, index: ${e.index} };// UDT(${
                            i[e.index].name
                          })
`;
                          break;
                        case t.REP:
                          d += `  this.rules[${n}].opcodes[${a}] = { type: ${e.type}, min: ${e.min}, max: ${e.max} };// REP
`;
                          break;
                        case t.AND:
                          d += `  this.rules[${n}].opcodes[${a}] = { type: ${e.type} };// AND
`;
                          break;
                        case t.NOT:
                          d += `  this.rules[${n}].opcodes[${a}] = { type: ${e.type} };// NOT
`;
                          break;
                        case t.ABG:
                          d += `  this.rules[${n}].opcodes[${a}] = { type: ${e.type} };// ABG(%^)
`;
                          break;
                        case t.AEN:
                          d += `  this.rules[${n}].opcodes[${a}] = { type: ${e.type} };// AEN(%$)
`;
                          break;
                        case t.BKA:
                          d += `  this.rules[${n}].opcodes[${a}] = { type: ${e.type} };// BKA
`;
                          break;
                        case t.BKN:
                          d += `  this.rules[${n}].opcodes[${a}] = { type: ${e.type} };// BKN
`;
                          break;
                        case t.TLS:
                          d += `  this.rules[${n}].opcodes[${a}] = { type: ${
                            e.type
                          }, string: [${e.string.toString()}] };// TLS
`;
                          break;
                        case t.TBS:
                          d += `  this.rules[${n}].opcodes[${a}] = { type: ${
                            e.type
                          }, string: [${e.string.toString()}] };// TBS
`;
                          break;
                        case t.TRG:
                          d += `  this.rules[${n}].opcodes[${a}] = { type: ${e.type}, min: ${e.min}, max: ${e.max} };// TRG
`;
                          break;
                        default:
                          throw Error("parser.js: ~143: unrecognized opcode");
                      }
                    });
                }),
                (d +=
                  '\n  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n  this.toString = function toString(){\n    let str = "";\n'),
                n.forEach((t) => {
                  let n = t.beginChar + t.length;
                  (c = ""), (d += '    str += "');
                  for (let s = t.beginChar; s < n; s += 1) {
                    switch (e[s]) {
                      case 9:
                        c = " ";
                        break;
                      case 10:
                        c = "\\n";
                        break;
                      case 13:
                        c = "\\r";
                        break;
                      case 34:
                        c = '\\"';
                        break;
                      case 92:
                        c = "\\\\";
                        break;
                      default:
                        c = String.fromCharCode(e[s]);
                    }
                    d += c;
                  }
                  d += '";\n';
                }),
                (d += "    return str;\n  }\n}\n")
              );
            }),
            (this.generateObject = function (e, t, n) {
              let s = {},
                i = [],
                a = [],
                o = e.slice(0);
              return (
                (s.grammarObject = "grammarObject"),
                t.forEach((e) => {
                  i.push(e.lower);
                }),
                i.sort(),
                n.length > 0 &&
                  (n.forEach((e) => {
                    a.push(e.lower);
                  }),
                  a.sort()),
                (s.callbacks = []),
                i.forEach((e) => {
                  s.callbacks[e] = !1;
                }),
                n.length > 0 &&
                  a.forEach((e) => {
                    s.callbacks[e] = !1;
                  }),
                (s.rules = t),
                (s.udts = n),
                (s.toString = function () {
                  return o;
                }),
                s
              );
            });
        };
      },
      94246: function (e, t, n) {
        e.exports = (function () {
          let e = n(58276),
            t = null;
          function s(e) {
            return !e.left && !e.nested && !e.right && !e.cyclic && e.empty;
          }
          function i(e) {
            return !!e.left || !!e.nested || !!e.right || !!e.cyclic;
          }
          let a = (e) => (e ? "t" : "f"),
            o = (e) => (e ? "e" : "f"),
            l = (e) => (e ? "t" : "e"),
            u = (n, s, i, u) =>
              `${n}:${s}:` +
              (`${o(i.left)} ${a(i.nested)} ${a(i.right)} ${o(i.cyclic)} ${l(
                i.finite
              )} ${a(i.empty)}:${t.typeToString(u.recursiveType)}:` +
                (u.recursiveType === e.ATTR_MR ? u.groupNumber : "-")) +
              `:${i.rule.name}
`,
            c = () =>
              "LEGEND - t=true, f=false, e=error\nsequence:rule index:left nested right cyclic finite empty:type:group number:rule name\n",
            d = (e) => {
              let n = 0,
                s = 0,
                i = null,
                a = null,
                o = "",
                { ruleIndexes: l } = t;
              for (
                97 === e
                  ? (l = t.ruleAlphaIndexes)
                  : 116 === e && (l = t.ruleTypeIndexes),
                  n = 0;
                n < t.ruleCount;
                n += 1
              )
                (s = l[n]),
                  (i = t.attrs[s]),
                  (a = t.ruleDeps[s]),
                  (o += u(n, s, i, a));
              return o;
            };
          return {
            ruleAttributes: (n) => {
              let a = 0,
                o = 0,
                l = (t = n).attrGen();
              for (a = 0; a < t.ruleCount; a += 1) {
                for (o = 0; o < t.ruleCount; o += 1)
                  t.attrInit(t.attrsWorking[o]);
                (t.startRule = a),
                  (function t(n, a, o) {
                    let l = n.attrsWorking[a];
                    l.isComplete
                      ? n.attrCopy(o, l)
                      : l.isOpen
                      ? a === n.startRule
                        ? a === n.startRule &&
                          ((o.left = !0),
                          (o.right = !0),
                          (o.cyclic = !0),
                          (o.leaf = !0))
                        : (o.finite = !0)
                      : ((l.isOpen = !0),
                        (function n(a, o, l, u) {
                          a.attrInit(u);
                          let c = o[l];
                          switch (c.type) {
                            case e.ALT:
                              !(function (e, t, s, i) {
                                let a = 0,
                                  o = t[s],
                                  l = o.children.length,
                                  u = [];
                                for (a = 0; a < l; a += 1) u.push(e.attrGen());
                                for (a = 0; a < l; a += 1)
                                  n(e, t, o.children[a], u[a]);
                                for (
                                  a = 0,
                                    i.left = !1,
                                    i.right = !1,
                                    i.nested = !1,
                                    i.empty = !1,
                                    i.finite = !1,
                                    i.cyclic = !1;
                                  a < l;
                                  a += 1
                                )
                                  u[a].left && (i.left = !0),
                                    u[a].nested && (i.nested = !0),
                                    u[a].right && (i.right = !0),
                                    u[a].empty && (i.empty = !0),
                                    u[a].finite && (i.finite = !0),
                                    u[a].cyclic && (i.cyclic = !0);
                              })(a, o, l, u);
                              break;
                            case e.CAT:
                              !(function (e, t, a, o) {
                                let l = 0,
                                  u = t[a],
                                  c = u.children.length,
                                  d = [];
                                for (l = 0; l < c; l += 1) d.push(e.attrGen());
                                for (l = 0; l < c; l += 1)
                                  n(e, t, u.children[l], d[l]);
                                (o.left = (function (e, t) {
                                  for (let n = 0; n < t; n += 1) {
                                    if (e[n].left) return !0;
                                    if (!e[n].empty) break;
                                  }
                                  return !1;
                                })(d, c)),
                                  (o.right = (function (e, t) {
                                    for (let n = t - 1; n >= 0; n -= 1) {
                                      if (e[n].right) return !0;
                                      if (!e[n].empty) break;
                                    }
                                    return !1;
                                  })(d, c)),
                                  (o.nested = (function (e, t) {
                                    let n = 0,
                                      a = 0,
                                      o = 0;
                                    for (n = 0; n < t; n += 1)
                                      if (e[n].nested) return !0;
                                    for (n = 0; n < t; n += 1)
                                      if (e[n].right && !e[n].leaf) {
                                        for (a = n + 1; a < t; a += 1)
                                          if (!s(e[a])) return !0;
                                      }
                                    for (n = t - 1; n >= 0; n -= 1)
                                      if (e[n].left && !e[n].leaf) {
                                        for (a = n - 1; a >= 0; a -= 1)
                                          if (!s(e[a])) return !0;
                                      }
                                    for (n = 0; n < t; n += 1)
                                      if (!e[n].empty && !i(e[n])) {
                                        for (a = n + 1; a < t; a += 1)
                                          if (i(e[a])) {
                                            for (o = a + 1; o < t; o += 1)
                                              if (!e[o].empty && !i(e[o]))
                                                return !0;
                                          }
                                      }
                                    return !1;
                                  })(d, c)),
                                  (o.empty = (function (e, t) {
                                    for (let n = 0; n < t; n += 1)
                                      if (!e[n].empty) return !1;
                                    return !0;
                                  })(d, c)),
                                  (o.finite = (function (e, t) {
                                    for (let n = 0; n < t; n += 1)
                                      if (!e[n].finite) return !1;
                                    return !0;
                                  })(d, c)),
                                  (o.cyclic = (function (e, t) {
                                    for (let n = 0; n < t; n += 1)
                                      if (!e[n].cyclic) return !1;
                                    return !0;
                                  })(d, c));
                              })(a, o, l, u);
                              break;
                            case e.REP:
                              n(a, o, l + 1, u),
                                0 === c.min &&
                                  ((u.empty = !0), (u.finite = !0));
                              break;
                            case e.RNM:
                              t(a, o[l].index, u);
                              break;
                            case e.BKR:
                              !(function (e, n, s, i) {
                                let a = n[s];
                                a.index >= e.ruleCount
                                  ? ((i.empty =
                                      e.udts[a.index - e.ruleCount].empty),
                                    (i.finite = !0))
                                  : (t(e, a.index, i),
                                    (i.left = !1),
                                    (i.nested = !1),
                                    (i.right = !1),
                                    (i.cyclic = !1));
                              })(a, o, l, u);
                              break;
                            case e.AND:
                            case e.NOT:
                            case e.BKA:
                            case e.BKN:
                              n(a, o, l + 1, u), (u.empty = !0);
                              break;
                            case e.TLS:
                              (u.empty = !o[l].string.length),
                                (u.finite = !0),
                                (u.cyclic = !1);
                              break;
                            case e.TBS:
                            case e.TRG:
                              (u.empty = !1), (u.finite = !0), (u.cyclic = !1);
                              break;
                            case e.UDT:
                              (u.empty = c.empty),
                                (u.finite = !0),
                                (u.cyclic = !1);
                              break;
                            case e.ABG:
                            case e.AEN:
                              (u.empty = !0), (u.finite = !0), (u.cyclic = !1);
                              break;
                            default:
                              throw Error(`unknown opcode type: ${c}`);
                          }
                        })(n, l.rule.opcodes, 0, o),
                        (l.left = o.left),
                        (l.right = o.right),
                        (l.nested = o.nested),
                        (l.empty = o.empty),
                        (l.finite = o.finite),
                        (l.cyclic = o.cyclic),
                        (l.leaf = !1),
                        (l.isOpen = !1),
                        (l.isComplete = !0));
                  })(t, a, l),
                  t.attrCopy(t.attrs[a], t.attrsWorking[a]);
              }
              t.attributesComplete = !0;
              let u = null;
              for (a = 0; a < t.ruleCount; a += 1)
                if ((u = t.attrs[a]).left || !u.finite || u.cyclic) {
                  let e = t.attrGen(u.rule);
                  t.attrCopy(e, u),
                    t.attrsErrors.push(e),
                    (t.attrsErrorCount += 1);
                }
            },
            showAttributes: (e = "index") => {
              if (!t.attributesComplete)
                throw Error(
                  "rule-attributes.js:showAttributes: attributes not available"
                );
              let n = "",
                s = "RULE ATTRIBUTES\n";
              return (
                97 === e.charCodeAt(0)
                  ? (n += "alphabetical by rule name\n" + s + c() + d(97))
                  : 116 === e.charCodeAt(0)
                  ? (n += "ordered by rule type\n" + s + c() + d(116))
                  : (n += "ordered by rule index\n" + s + c() + d()),
                n
              );
            },
            showAttributeErrors: () => {
              let e = null,
                n = null,
                s = "";
              if (
                ((s += "RULE ATTRIBUTES WITH ERRORS\n" + c()),
                t.attrsErrorCount)
              )
                for (let i = 0; i < t.attrsErrorCount; i += 1)
                  (e = t.attrsErrors[i]),
                    (n = t.ruleDeps[e.rule.index]),
                    (s += u(i, e.rule.index, e, n));
              else s += "<none>\n";
              return s;
            },
          };
        })();
      },
      37008: function (e, t, n) {
        e.exports = (() => {
          let e = n(58276),
            t = null,
            s = (t, n, i, a) => {
              let o = 0,
                l = 0,
                u = n[i];
              a[i] = !0;
              let c = u.rule.opcodes;
              for (o = 0; o < c.length; o += 1) {
                let i = c[o];
                if (i.type === e.RNM)
                  for (
                    u.refersTo[i.index] = !0,
                      a[i.index] || s(t, n, i.index, a),
                      l = 0;
                    l < t;
                    l += 1
                  )
                    n[i.index].refersTo[l] && (u.refersTo[l] = !0);
                else
                  i.type === e.UDT
                    ? (u.refersToUdt[i.index] = !0)
                    : i.type !== e.BKR ||
                      (i.index < t
                        ? ((u.refersTo[i.index] = !0),
                          a[i.index] || s(t, n, i.index, a))
                        : (u.refersToUdt[t - i.index] = !0));
              }
            },
            i = (e = null) => {
              let n = 0,
                s = 0,
                i = 0,
                a = 0,
                o = t.ruleCount - 1,
                l = t.udtCount - 1,
                u = "",
                c = "",
                d = !1,
                h = null,
                { ruleIndexes: p } = t,
                { udtIndexes: f } = t;
              for (
                97 === e
                  ? ((p = t.ruleAlphaIndexes), (f = t.udtAlphaIndexes))
                  : 116 === e &&
                    ((p = t.ruleTypeIndexes), (f = t.udtAlphaIndexes)),
                  n = 0;
                n < t.ruleCount;
                n += 1
              ) {
                for (
                  h = t.ruleDeps[p[n]],
                    c = `${p[n]}:${t.typeToString(h.recursiveType)}:`,
                    t.isMutuallyRecursive &&
                      (c += (h.groupNumber > -1 ? h.groupNumber : "-") + ":"),
                    c += " ",
                    u += `${c + t.rules[p[n]].name}
`,
                    d = !0,
                    i = 0,
                    a = u.length,
                    u += c,
                    s = 0;
                  s < t.ruleCount;
                  s += 1
                )
                  h.refersTo[p[s]] &&
                    (d
                      ? ((d = !1), (u += "=> " + t.ruleDeps[p[s]].rule.name))
                      : (u += `, ${t.ruleDeps[p[s]].rule.name}`),
                    (i += 1)),
                    u.length - a > 100 &&
                      s !== o &&
                      ((u += `
${c}=> `),
                      (a = u.length));
                if (t.udtCount)
                  for (s = 0; s < t.udtCount; s += 1)
                    h.refersToUdt[f[s]] &&
                      (d
                        ? ((d = !1), (u += "=> " + t.udts[f[s]].name))
                        : (u += `, ${t.udts[f[s]].name}`),
                      (i += 1)),
                      u.length - a > 100 &&
                        s !== l &&
                        ((u += `
${c}=> `),
                        (a = u.length));
                for (
                  0 === i && (u += "=> <none>\n"),
                    !1 === d && (u += "\n"),
                    d = !0,
                    i = 0,
                    a = u.length,
                    u += c,
                    s = 0;
                  s < t.ruleCount;
                  s += 1
                )
                  h.referencedBy[p[s]] &&
                    (d
                      ? ((d = !1), (u += "<= " + t.ruleDeps[p[s]].rule.name))
                      : (u += `, ${t.ruleDeps[p[s]].rule.name}`),
                    (i += 1)),
                    u.length - a > 100 &&
                      s !== o &&
                      ((u += `
${c}=> `),
                      (a = u.length));
                0 === i && (u += "<= <none>\n"),
                  !1 === d && (u += "\n"),
                  (u += "\n");
              }
              return u;
            };
          return {
            ruleDependencies: (n) => {
              let i = 0,
                a = 0,
                o = 0,
                l = null,
                u = null,
                c = !1;
              (t = n).dependenciesComplete = !1;
              let d = t.falseArray(t.ruleCount);
              for (i = 0; i < t.ruleCount; i += 1)
                t.falsifyArray(d), s(t.ruleCount, t.ruleDeps, i, d);
              for (i = 0; i < t.ruleCount; i += 1)
                for (a = 0; a < t.ruleCount; a += 1)
                  i !== a &&
                    t.ruleDeps[a].refersTo[i] &&
                    (t.ruleDeps[i].referencedBy[a] = !0);
              for (i = 0; i < t.ruleCount; i += 1)
                (t.ruleDeps[i].recursiveType = e.ATTR_N),
                  t.ruleDeps[i].refersTo[i] &&
                    (t.ruleDeps[i].recursiveType = e.ATTR_R);
              for (i = 0, o = -1; i < t.ruleCount; i += 1)
                if ((l = t.ruleDeps[i]).recursiveType === e.ATTR_R)
                  for (a = 0, c = !0; a < t.ruleCount; a += 1)
                    i !== a &&
                      (u = t.ruleDeps[a]).recursiveType === e.ATTR_R &&
                      l.refersTo[a] &&
                      u.refersTo[i] &&
                      (c &&
                        ((o += 1),
                        (l.recursiveType = e.ATTR_MR),
                        (l.groupNumber = o),
                        (c = !1)),
                      (u.recursiveType = e.ATTR_MR),
                      (u.groupNumber = o));
              (t.isMutuallyRecursive = o > -1),
                t.ruleAlphaIndexes.sort(t.compRulesAlpha),
                t.ruleTypeIndexes.sort(t.compRulesAlpha),
                t.ruleTypeIndexes.sort(t.compRulesType),
                t.isMutuallyRecursive &&
                  t.ruleTypeIndexes.sort(t.compRulesGroup),
                t.udtCount && t.udtAlphaIndexes.sort(t.compUdtsAlpha),
                (t.dependenciesComplete = !0);
            },
            showRuleDependencies: (e = "index") => {
              let n = "RULE DEPENDENCIES(index:type:[group number:])\n";
              return (
                (n += "=> refers to rule names\n<= referenced by rule names\n"),
                t.dependenciesComplete &&
                  (97 === e.charCodeAt(0)
                    ? (n += "alphabetical by rule name\n" + i(97))
                    : 116 === e.charCodeAt(0)
                    ? (n += "ordered by rule type\n" + i(116))
                    : (n += "ordered by rule index\n" + i(null))),
                n
              );
            },
          };
        })();
      },
      33610: function (e) {
        e.exports = function () {
          (this.grammarObject = "grammarObject"),
            (this.rules = []),
            (this.rules[0] = {
              name: "File",
              lower: "file",
              index: 0,
              isBkr: !1,
            }),
            (this.rules[1] = {
              name: "BlankLine",
              lower: "blankline",
              index: 1,
              isBkr: !1,
            }),
            (this.rules[2] = {
              name: "Rule",
              lower: "rule",
              index: 2,
              isBkr: !1,
            }),
            (this.rules[3] = {
              name: "RuleLookup",
              lower: "rulelookup",
              index: 3,
              isBkr: !1,
            }),
            (this.rules[4] = {
              name: "RuleNameTest",
              lower: "rulenametest",
              index: 4,
              isBkr: !1,
            }),
            (this.rules[5] = {
              name: "RuleName",
              lower: "rulename",
              index: 5,
              isBkr: !1,
            }),
            (this.rules[6] = {
              name: "RuleNameError",
              lower: "rulenameerror",
              index: 6,
              isBkr: !1,
            }),
            (this.rules[7] = {
              name: "DefinedAsTest",
              lower: "definedastest",
              index: 7,
              isBkr: !1,
            }),
            (this.rules[8] = {
              name: "DefinedAsError",
              lower: "definedaserror",
              index: 8,
              isBkr: !1,
            }),
            (this.rules[9] = {
              name: "DefinedAs",
              lower: "definedas",
              index: 9,
              isBkr: !1,
            }),
            (this.rules[10] = {
              name: "Defined",
              lower: "defined",
              index: 10,
              isBkr: !1,
            }),
            (this.rules[11] = {
              name: "IncAlt",
              lower: "incalt",
              index: 11,
              isBkr: !1,
            }),
            (this.rules[12] = {
              name: "RuleError",
              lower: "ruleerror",
              index: 12,
              isBkr: !1,
            }),
            (this.rules[13] = {
              name: "LineEndError",
              lower: "lineenderror",
              index: 13,
              isBkr: !1,
            }),
            (this.rules[14] = {
              name: "Alternation",
              lower: "alternation",
              index: 14,
              isBkr: !1,
            }),
            (this.rules[15] = {
              name: "Concatenation",
              lower: "concatenation",
              index: 15,
              isBkr: !1,
            }),
            (this.rules[16] = {
              name: "Repetition",
              lower: "repetition",
              index: 16,
              isBkr: !1,
            }),
            (this.rules[17] = {
              name: "Modifier",
              lower: "modifier",
              index: 17,
              isBkr: !1,
            }),
            (this.rules[18] = {
              name: "Predicate",
              lower: "predicate",
              index: 18,
              isBkr: !1,
            }),
            (this.rules[19] = {
              name: "BasicElement",
              lower: "basicelement",
              index: 19,
              isBkr: !1,
            }),
            (this.rules[20] = {
              name: "BasicElementErr",
              lower: "basicelementerr",
              index: 20,
              isBkr: !1,
            }),
            (this.rules[21] = {
              name: "Group",
              lower: "group",
              index: 21,
              isBkr: !1,
            }),
            (this.rules[22] = {
              name: "GroupError",
              lower: "grouperror",
              index: 22,
              isBkr: !1,
            }),
            (this.rules[23] = {
              name: "GroupOpen",
              lower: "groupopen",
              index: 23,
              isBkr: !1,
            }),
            (this.rules[24] = {
              name: "GroupClose",
              lower: "groupclose",
              index: 24,
              isBkr: !1,
            }),
            (this.rules[25] = {
              name: "Option",
              lower: "option",
              index: 25,
              isBkr: !1,
            }),
            (this.rules[26] = {
              name: "OptionError",
              lower: "optionerror",
              index: 26,
              isBkr: !1,
            }),
            (this.rules[27] = {
              name: "OptionOpen",
              lower: "optionopen",
              index: 27,
              isBkr: !1,
            }),
            (this.rules[28] = {
              name: "OptionClose",
              lower: "optionclose",
              index: 28,
              isBkr: !1,
            }),
            (this.rules[29] = {
              name: "RnmOp",
              lower: "rnmop",
              index: 29,
              isBkr: !1,
            }),
            (this.rules[30] = {
              name: "BkrOp",
              lower: "bkrop",
              index: 30,
              isBkr: !1,
            }),
            (this.rules[31] = {
              name: "bkrModifier",
              lower: "bkrmodifier",
              index: 31,
              isBkr: !1,
            }),
            (this.rules[32] = {
              name: "cs",
              lower: "cs",
              index: 32,
              isBkr: !1,
            }),
            (this.rules[33] = {
              name: "ci",
              lower: "ci",
              index: 33,
              isBkr: !1,
            }),
            (this.rules[34] = {
              name: "um",
              lower: "um",
              index: 34,
              isBkr: !1,
            }),
            (this.rules[35] = {
              name: "pm",
              lower: "pm",
              index: 35,
              isBkr: !1,
            }),
            (this.rules[36] = {
              name: "bkr-name",
              lower: "bkr-name",
              index: 36,
              isBkr: !1,
            }),
            (this.rules[37] = {
              name: "rname",
              lower: "rname",
              index: 37,
              isBkr: !1,
            }),
            (this.rules[38] = {
              name: "uname",
              lower: "uname",
              index: 38,
              isBkr: !1,
            }),
            (this.rules[39] = {
              name: "ename",
              lower: "ename",
              index: 39,
              isBkr: !1,
            }),
            (this.rules[40] = {
              name: "UdtOp",
              lower: "udtop",
              index: 40,
              isBkr: !1,
            }),
            (this.rules[41] = {
              name: "udt-non-empty",
              lower: "udt-non-empty",
              index: 41,
              isBkr: !1,
            }),
            (this.rules[42] = {
              name: "udt-empty",
              lower: "udt-empty",
              index: 42,
              isBkr: !1,
            }),
            (this.rules[43] = {
              name: "RepOp",
              lower: "repop",
              index: 43,
              isBkr: !1,
            }),
            (this.rules[44] = {
              name: "AltOp",
              lower: "altop",
              index: 44,
              isBkr: !1,
            }),
            (this.rules[45] = {
              name: "CatOp",
              lower: "catop",
              index: 45,
              isBkr: !1,
            }),
            (this.rules[46] = {
              name: "StarOp",
              lower: "starop",
              index: 46,
              isBkr: !1,
            }),
            (this.rules[47] = {
              name: "AndOp",
              lower: "andop",
              index: 47,
              isBkr: !1,
            }),
            (this.rules[48] = {
              name: "NotOp",
              lower: "notop",
              index: 48,
              isBkr: !1,
            }),
            (this.rules[49] = {
              name: "BkaOp",
              lower: "bkaop",
              index: 49,
              isBkr: !1,
            }),
            (this.rules[50] = {
              name: "BknOp",
              lower: "bknop",
              index: 50,
              isBkr: !1,
            }),
            (this.rules[51] = {
              name: "AbgOp",
              lower: "abgop",
              index: 51,
              isBkr: !1,
            }),
            (this.rules[52] = {
              name: "AenOp",
              lower: "aenop",
              index: 52,
              isBkr: !1,
            }),
            (this.rules[53] = {
              name: "TrgOp",
              lower: "trgop",
              index: 53,
              isBkr: !1,
            }),
            (this.rules[54] = {
              name: "TbsOp",
              lower: "tbsop",
              index: 54,
              isBkr: !1,
            }),
            (this.rules[55] = {
              name: "TlsOp",
              lower: "tlsop",
              index: 55,
              isBkr: !1,
            }),
            (this.rules[56] = {
              name: "TlsCase",
              lower: "tlscase",
              index: 56,
              isBkr: !1,
            }),
            (this.rules[57] = {
              name: "TlsOpen",
              lower: "tlsopen",
              index: 57,
              isBkr: !1,
            }),
            (this.rules[58] = {
              name: "TlsClose",
              lower: "tlsclose",
              index: 58,
              isBkr: !1,
            }),
            (this.rules[59] = {
              name: "TlsString",
              lower: "tlsstring",
              index: 59,
              isBkr: !1,
            }),
            (this.rules[60] = {
              name: "StringTab",
              lower: "stringtab",
              index: 60,
              isBkr: !1,
            }),
            (this.rules[61] = {
              name: "ClsOp",
              lower: "clsop",
              index: 61,
              isBkr: !1,
            }),
            (this.rules[62] = {
              name: "ClsOpen",
              lower: "clsopen",
              index: 62,
              isBkr: !1,
            }),
            (this.rules[63] = {
              name: "ClsClose",
              lower: "clsclose",
              index: 63,
              isBkr: !1,
            }),
            (this.rules[64] = {
              name: "ClsString",
              lower: "clsstring",
              index: 64,
              isBkr: !1,
            }),
            (this.rules[65] = {
              name: "ProsVal",
              lower: "prosval",
              index: 65,
              isBkr: !1,
            }),
            (this.rules[66] = {
              name: "ProsValOpen",
              lower: "prosvalopen",
              index: 66,
              isBkr: !1,
            }),
            (this.rules[67] = {
              name: "ProsValString",
              lower: "prosvalstring",
              index: 67,
              isBkr: !1,
            }),
            (this.rules[68] = {
              name: "ProsValClose",
              lower: "prosvalclose",
              index: 68,
              isBkr: !1,
            }),
            (this.rules[69] = {
              name: "rep-min",
              lower: "rep-min",
              index: 69,
              isBkr: !1,
            }),
            (this.rules[70] = {
              name: "rep-min-max",
              lower: "rep-min-max",
              index: 70,
              isBkr: !1,
            }),
            (this.rules[71] = {
              name: "rep-max",
              lower: "rep-max",
              index: 71,
              isBkr: !1,
            }),
            (this.rules[72] = {
              name: "rep-num",
              lower: "rep-num",
              index: 72,
              isBkr: !1,
            }),
            (this.rules[73] = {
              name: "dString",
              lower: "dstring",
              index: 73,
              isBkr: !1,
            }),
            (this.rules[74] = {
              name: "xString",
              lower: "xstring",
              index: 74,
              isBkr: !1,
            }),
            (this.rules[75] = {
              name: "bString",
              lower: "bstring",
              index: 75,
              isBkr: !1,
            }),
            (this.rules[76] = {
              name: "Dec",
              lower: "dec",
              index: 76,
              isBkr: !1,
            }),
            (this.rules[77] = {
              name: "Hex",
              lower: "hex",
              index: 77,
              isBkr: !1,
            }),
            (this.rules[78] = {
              name: "Bin",
              lower: "bin",
              index: 78,
              isBkr: !1,
            }),
            (this.rules[79] = {
              name: "dmin",
              lower: "dmin",
              index: 79,
              isBkr: !1,
            }),
            (this.rules[80] = {
              name: "dmax",
              lower: "dmax",
              index: 80,
              isBkr: !1,
            }),
            (this.rules[81] = {
              name: "bmin",
              lower: "bmin",
              index: 81,
              isBkr: !1,
            }),
            (this.rules[82] = {
              name: "bmax",
              lower: "bmax",
              index: 82,
              isBkr: !1,
            }),
            (this.rules[83] = {
              name: "xmin",
              lower: "xmin",
              index: 83,
              isBkr: !1,
            }),
            (this.rules[84] = {
              name: "xmax",
              lower: "xmax",
              index: 84,
              isBkr: !1,
            }),
            (this.rules[85] = {
              name: "dnum",
              lower: "dnum",
              index: 85,
              isBkr: !1,
            }),
            (this.rules[86] = {
              name: "bnum",
              lower: "bnum",
              index: 86,
              isBkr: !1,
            }),
            (this.rules[87] = {
              name: "xnum",
              lower: "xnum",
              index: 87,
              isBkr: !1,
            }),
            (this.rules[88] = {
              name: "alphanum",
              lower: "alphanum",
              index: 88,
              isBkr: !1,
            }),
            (this.rules[89] = {
              name: "owsp",
              lower: "owsp",
              index: 89,
              isBkr: !1,
            }),
            (this.rules[90] = {
              name: "wsp",
              lower: "wsp",
              index: 90,
              isBkr: !1,
            }),
            (this.rules[91] = {
              name: "space",
              lower: "space",
              index: 91,
              isBkr: !1,
            }),
            (this.rules[92] = {
              name: "comment",
              lower: "comment",
              index: 92,
              isBkr: !1,
            }),
            (this.rules[93] = {
              name: "LineEnd",
              lower: "lineend",
              index: 93,
              isBkr: !1,
            }),
            (this.rules[94] = {
              name: "LineContinue",
              lower: "linecontinue",
              index: 94,
              isBkr: !1,
            }),
            (this.udts = []),
            (this.rules[0].opcodes = []),
            (this.rules[0].opcodes[0] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[0].opcodes[1] = { type: 1, children: [2, 3, 4] }),
            (this.rules[0].opcodes[2] = { type: 4, index: 1 }),
            (this.rules[0].opcodes[3] = { type: 4, index: 2 }),
            (this.rules[0].opcodes[4] = { type: 4, index: 12 }),
            (this.rules[1].opcodes = []),
            (this.rules[1].opcodes[0] = { type: 2, children: [1, 5, 7] }),
            (this.rules[1].opcodes[1] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[1].opcodes[2] = { type: 1, children: [3, 4] }),
            (this.rules[1].opcodes[3] = { type: 6, string: [32] }),
            (this.rules[1].opcodes[4] = { type: 6, string: [9] }),
            (this.rules[1].opcodes[5] = { type: 3, min: 0, max: 1 }),
            (this.rules[1].opcodes[6] = { type: 4, index: 92 }),
            (this.rules[1].opcodes[7] = { type: 4, index: 93 }),
            (this.rules[2].opcodes = []),
            (this.rules[2].opcodes[0] = { type: 2, children: [1, 2, 3, 4] }),
            (this.rules[2].opcodes[1] = { type: 4, index: 3 }),
            (this.rules[2].opcodes[2] = { type: 4, index: 89 }),
            (this.rules[2].opcodes[3] = { type: 4, index: 14 }),
            (this.rules[2].opcodes[4] = { type: 1, children: [5, 8] }),
            (this.rules[2].opcodes[5] = { type: 2, children: [6, 7] }),
            (this.rules[2].opcodes[6] = { type: 4, index: 89 }),
            (this.rules[2].opcodes[7] = { type: 4, index: 93 }),
            (this.rules[2].opcodes[8] = { type: 2, children: [9, 10] }),
            (this.rules[2].opcodes[9] = { type: 4, index: 13 }),
            (this.rules[2].opcodes[10] = { type: 4, index: 93 }),
            (this.rules[3].opcodes = []),
            (this.rules[3].opcodes[0] = { type: 2, children: [1, 2, 3] }),
            (this.rules[3].opcodes[1] = { type: 4, index: 4 }),
            (this.rules[3].opcodes[2] = { type: 4, index: 89 }),
            (this.rules[3].opcodes[3] = { type: 4, index: 7 }),
            (this.rules[4].opcodes = []),
            (this.rules[4].opcodes[0] = { type: 1, children: [1, 2] }),
            (this.rules[4].opcodes[1] = { type: 4, index: 5 }),
            (this.rules[4].opcodes[2] = { type: 4, index: 6 }),
            (this.rules[5].opcodes = []),
            (this.rules[5].opcodes[0] = { type: 4, index: 88 }),
            (this.rules[6].opcodes = []),
            (this.rules[6].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
            (this.rules[6].opcodes[1] = { type: 1, children: [2, 3] }),
            (this.rules[6].opcodes[2] = { type: 5, min: 33, max: 60 }),
            (this.rules[6].opcodes[3] = { type: 5, min: 62, max: 126 }),
            (this.rules[7].opcodes = []),
            (this.rules[7].opcodes[0] = { type: 1, children: [1, 2] }),
            (this.rules[7].opcodes[1] = { type: 4, index: 9 }),
            (this.rules[7].opcodes[2] = { type: 4, index: 8 }),
            (this.rules[8].opcodes = []),
            (this.rules[8].opcodes[0] = { type: 3, min: 1, max: 2 }),
            (this.rules[8].opcodes[1] = { type: 5, min: 33, max: 126 }),
            (this.rules[9].opcodes = []),
            (this.rules[9].opcodes[0] = { type: 1, children: [1, 2] }),
            (this.rules[9].opcodes[1] = { type: 4, index: 11 }),
            (this.rules[9].opcodes[2] = { type: 4, index: 10 }),
            (this.rules[10].opcodes = []),
            (this.rules[10].opcodes[0] = { type: 6, string: [61] }),
            (this.rules[11].opcodes = []),
            (this.rules[11].opcodes[0] = { type: 6, string: [61, 47] }),
            (this.rules[12].opcodes = []),
            (this.rules[12].opcodes[0] = { type: 2, children: [1, 6] }),
            (this.rules[12].opcodes[1] = { type: 3, min: 1, max: 1 / 0 }),
            (this.rules[12].opcodes[2] = { type: 1, children: [3, 4, 5] }),
            (this.rules[12].opcodes[3] = { type: 5, min: 32, max: 126 }),
            (this.rules[12].opcodes[4] = { type: 6, string: [9] }),
            (this.rules[12].opcodes[5] = { type: 4, index: 94 }),
            (this.rules[12].opcodes[6] = { type: 4, index: 93 }),
            (this.rules[13].opcodes = []),
            (this.rules[13].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
            (this.rules[13].opcodes[1] = { type: 1, children: [2, 3, 4] }),
            (this.rules[13].opcodes[2] = { type: 5, min: 32, max: 126 }),
            (this.rules[13].opcodes[3] = { type: 6, string: [9] }),
            (this.rules[13].opcodes[4] = { type: 4, index: 94 }),
            (this.rules[14].opcodes = []),
            (this.rules[14].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[14].opcodes[1] = { type: 4, index: 15 }),
            (this.rules[14].opcodes[2] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[14].opcodes[3] = { type: 2, children: [4, 5, 6] }),
            (this.rules[14].opcodes[4] = { type: 4, index: 89 }),
            (this.rules[14].opcodes[5] = { type: 4, index: 44 }),
            (this.rules[14].opcodes[6] = { type: 4, index: 15 }),
            (this.rules[15].opcodes = []),
            (this.rules[15].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[15].opcodes[1] = { type: 4, index: 16 }),
            (this.rules[15].opcodes[2] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[15].opcodes[3] = { type: 2, children: [4, 5] }),
            (this.rules[15].opcodes[4] = { type: 4, index: 45 }),
            (this.rules[15].opcodes[5] = { type: 4, index: 16 }),
            (this.rules[16].opcodes = []),
            (this.rules[16].opcodes[0] = { type: 2, children: [1, 3] }),
            (this.rules[16].opcodes[1] = { type: 3, min: 0, max: 1 }),
            (this.rules[16].opcodes[2] = { type: 4, index: 17 }),
            (this.rules[16].opcodes[3] = { type: 1, children: [4, 5, 6, 7] }),
            (this.rules[16].opcodes[4] = { type: 4, index: 21 }),
            (this.rules[16].opcodes[5] = { type: 4, index: 25 }),
            (this.rules[16].opcodes[6] = { type: 4, index: 19 }),
            (this.rules[16].opcodes[7] = { type: 4, index: 20 }),
            (this.rules[17].opcodes = []),
            (this.rules[17].opcodes[0] = { type: 1, children: [1, 5] }),
            (this.rules[17].opcodes[1] = { type: 2, children: [2, 3] }),
            (this.rules[17].opcodes[2] = { type: 4, index: 18 }),
            (this.rules[17].opcodes[3] = { type: 3, min: 0, max: 1 }),
            (this.rules[17].opcodes[4] = { type: 4, index: 43 }),
            (this.rules[17].opcodes[5] = { type: 4, index: 43 }),
            (this.rules[18].opcodes = []),
            (this.rules[18].opcodes[0] = { type: 1, children: [1, 2, 3, 4] }),
            (this.rules[18].opcodes[1] = { type: 4, index: 49 }),
            (this.rules[18].opcodes[2] = { type: 4, index: 50 }),
            (this.rules[18].opcodes[3] = { type: 4, index: 47 }),
            (this.rules[18].opcodes[4] = { type: 4, index: 48 }),
            (this.rules[19].opcodes = []),
            (this.rules[19].opcodes[0] = {
              type: 1,
              children: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
            }),
            (this.rules[19].opcodes[1] = { type: 4, index: 40 }),
            (this.rules[19].opcodes[2] = { type: 4, index: 29 }),
            (this.rules[19].opcodes[3] = { type: 4, index: 53 }),
            (this.rules[19].opcodes[4] = { type: 4, index: 54 }),
            (this.rules[19].opcodes[5] = { type: 4, index: 55 }),
            (this.rules[19].opcodes[6] = { type: 4, index: 61 }),
            (this.rules[19].opcodes[7] = { type: 4, index: 30 }),
            (this.rules[19].opcodes[8] = { type: 4, index: 51 }),
            (this.rules[19].opcodes[9] = { type: 4, index: 52 }),
            (this.rules[19].opcodes[10] = { type: 4, index: 65 }),
            (this.rules[20].opcodes = []),
            (this.rules[20].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
            (this.rules[20].opcodes[1] = { type: 1, children: [2, 3, 4, 5] }),
            (this.rules[20].opcodes[2] = { type: 5, min: 33, max: 40 }),
            (this.rules[20].opcodes[3] = { type: 5, min: 42, max: 46 }),
            (this.rules[20].opcodes[4] = { type: 5, min: 48, max: 92 }),
            (this.rules[20].opcodes[5] = { type: 5, min: 94, max: 126 }),
            (this.rules[21].opcodes = []),
            (this.rules[21].opcodes[0] = { type: 2, children: [1, 2, 3] }),
            (this.rules[21].opcodes[1] = { type: 4, index: 23 }),
            (this.rules[21].opcodes[2] = { type: 4, index: 14 }),
            (this.rules[21].opcodes[3] = { type: 1, children: [4, 5] }),
            (this.rules[21].opcodes[4] = { type: 4, index: 24 }),
            (this.rules[21].opcodes[5] = { type: 4, index: 22 }),
            (this.rules[22].opcodes = []),
            (this.rules[22].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
            (this.rules[22].opcodes[1] = { type: 1, children: [2, 3, 4, 5] }),
            (this.rules[22].opcodes[2] = { type: 5, min: 33, max: 40 }),
            (this.rules[22].opcodes[3] = { type: 5, min: 42, max: 46 }),
            (this.rules[22].opcodes[4] = { type: 5, min: 48, max: 92 }),
            (this.rules[22].opcodes[5] = { type: 5, min: 94, max: 126 }),
            (this.rules[23].opcodes = []),
            (this.rules[23].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[23].opcodes[1] = { type: 6, string: [40] }),
            (this.rules[23].opcodes[2] = { type: 4, index: 89 }),
            (this.rules[24].opcodes = []),
            (this.rules[24].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[24].opcodes[1] = { type: 4, index: 89 }),
            (this.rules[24].opcodes[2] = { type: 6, string: [41] }),
            (this.rules[25].opcodes = []),
            (this.rules[25].opcodes[0] = { type: 2, children: [1, 2, 3] }),
            (this.rules[25].opcodes[1] = { type: 4, index: 27 }),
            (this.rules[25].opcodes[2] = { type: 4, index: 14 }),
            (this.rules[25].opcodes[3] = { type: 1, children: [4, 5] }),
            (this.rules[25].opcodes[4] = { type: 4, index: 28 }),
            (this.rules[25].opcodes[5] = { type: 4, index: 26 }),
            (this.rules[26].opcodes = []),
            (this.rules[26].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
            (this.rules[26].opcodes[1] = { type: 1, children: [2, 3, 4, 5] }),
            (this.rules[26].opcodes[2] = { type: 5, min: 33, max: 40 }),
            (this.rules[26].opcodes[3] = { type: 5, min: 42, max: 46 }),
            (this.rules[26].opcodes[4] = { type: 5, min: 48, max: 92 }),
            (this.rules[26].opcodes[5] = { type: 5, min: 94, max: 126 }),
            (this.rules[27].opcodes = []),
            (this.rules[27].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[27].opcodes[1] = { type: 6, string: [91] }),
            (this.rules[27].opcodes[2] = { type: 4, index: 89 }),
            (this.rules[28].opcodes = []),
            (this.rules[28].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[28].opcodes[1] = { type: 4, index: 89 }),
            (this.rules[28].opcodes[2] = { type: 6, string: [93] }),
            (this.rules[29].opcodes = []),
            (this.rules[29].opcodes[0] = { type: 4, index: 88 }),
            (this.rules[30].opcodes = []),
            (this.rules[30].opcodes[0] = { type: 2, children: [1, 2, 4] }),
            (this.rules[30].opcodes[1] = { type: 6, string: [92] }),
            (this.rules[30].opcodes[2] = { type: 3, min: 0, max: 1 }),
            (this.rules[30].opcodes[3] = { type: 4, index: 31 }),
            (this.rules[30].opcodes[4] = { type: 4, index: 36 }),
            (this.rules[31].opcodes = []),
            (this.rules[31].opcodes[0] = { type: 1, children: [1, 7, 13, 19] }),
            (this.rules[31].opcodes[1] = { type: 2, children: [2, 3] }),
            (this.rules[31].opcodes[2] = { type: 4, index: 32 }),
            (this.rules[31].opcodes[3] = { type: 3, min: 0, max: 1 }),
            (this.rules[31].opcodes[4] = { type: 1, children: [5, 6] }),
            (this.rules[31].opcodes[5] = { type: 4, index: 34 }),
            (this.rules[31].opcodes[6] = { type: 4, index: 35 }),
            (this.rules[31].opcodes[7] = { type: 2, children: [8, 9] }),
            (this.rules[31].opcodes[8] = { type: 4, index: 33 }),
            (this.rules[31].opcodes[9] = { type: 3, min: 0, max: 1 }),
            (this.rules[31].opcodes[10] = { type: 1, children: [11, 12] }),
            (this.rules[31].opcodes[11] = { type: 4, index: 34 }),
            (this.rules[31].opcodes[12] = { type: 4, index: 35 }),
            (this.rules[31].opcodes[13] = { type: 2, children: [14, 15] }),
            (this.rules[31].opcodes[14] = { type: 4, index: 34 }),
            (this.rules[31].opcodes[15] = { type: 3, min: 0, max: 1 }),
            (this.rules[31].opcodes[16] = { type: 1, children: [17, 18] }),
            (this.rules[31].opcodes[17] = { type: 4, index: 32 }),
            (this.rules[31].opcodes[18] = { type: 4, index: 33 }),
            (this.rules[31].opcodes[19] = { type: 2, children: [20, 21] }),
            (this.rules[31].opcodes[20] = { type: 4, index: 35 }),
            (this.rules[31].opcodes[21] = { type: 3, min: 0, max: 1 }),
            (this.rules[31].opcodes[22] = { type: 1, children: [23, 24] }),
            (this.rules[31].opcodes[23] = { type: 4, index: 32 }),
            (this.rules[31].opcodes[24] = { type: 4, index: 33 }),
            (this.rules[32].opcodes = []),
            (this.rules[32].opcodes[0] = { type: 6, string: [37, 115] }),
            (this.rules[33].opcodes = []),
            (this.rules[33].opcodes[0] = { type: 6, string: [37, 105] }),
            (this.rules[34].opcodes = []),
            (this.rules[34].opcodes[0] = { type: 6, string: [37, 117] }),
            (this.rules[35].opcodes = []),
            (this.rules[35].opcodes[0] = { type: 6, string: [37, 112] }),
            (this.rules[36].opcodes = []),
            (this.rules[36].opcodes[0] = { type: 1, children: [1, 2, 3] }),
            (this.rules[36].opcodes[1] = { type: 4, index: 38 }),
            (this.rules[36].opcodes[2] = { type: 4, index: 39 }),
            (this.rules[36].opcodes[3] = { type: 4, index: 37 }),
            (this.rules[37].opcodes = []),
            (this.rules[37].opcodes[0] = { type: 4, index: 88 }),
            (this.rules[38].opcodes = []),
            (this.rules[38].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[38].opcodes[1] = { type: 6, string: [117, 95] }),
            (this.rules[38].opcodes[2] = { type: 4, index: 88 }),
            (this.rules[39].opcodes = []),
            (this.rules[39].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[39].opcodes[1] = { type: 6, string: [101, 95] }),
            (this.rules[39].opcodes[2] = { type: 4, index: 88 }),
            (this.rules[40].opcodes = []),
            (this.rules[40].opcodes[0] = { type: 1, children: [1, 2] }),
            (this.rules[40].opcodes[1] = { type: 4, index: 42 }),
            (this.rules[40].opcodes[2] = { type: 4, index: 41 }),
            (this.rules[41].opcodes = []),
            (this.rules[41].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[41].opcodes[1] = { type: 6, string: [117, 95] }),
            (this.rules[41].opcodes[2] = { type: 4, index: 88 }),
            (this.rules[42].opcodes = []),
            (this.rules[42].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[42].opcodes[1] = { type: 6, string: [101, 95] }),
            (this.rules[42].opcodes[2] = { type: 4, index: 88 }),
            (this.rules[43].opcodes = []),
            (this.rules[43].opcodes[0] = {
              type: 1,
              children: [1, 5, 8, 11, 12],
            }),
            (this.rules[43].opcodes[1] = { type: 2, children: [2, 3, 4] }),
            (this.rules[43].opcodes[2] = { type: 4, index: 69 }),
            (this.rules[43].opcodes[3] = { type: 4, index: 46 }),
            (this.rules[43].opcodes[4] = { type: 4, index: 71 }),
            (this.rules[43].opcodes[5] = { type: 2, children: [6, 7] }),
            (this.rules[43].opcodes[6] = { type: 4, index: 69 }),
            (this.rules[43].opcodes[7] = { type: 4, index: 46 }),
            (this.rules[43].opcodes[8] = { type: 2, children: [9, 10] }),
            (this.rules[43].opcodes[9] = { type: 4, index: 46 }),
            (this.rules[43].opcodes[10] = { type: 4, index: 71 }),
            (this.rules[43].opcodes[11] = { type: 4, index: 46 }),
            (this.rules[43].opcodes[12] = { type: 4, index: 70 }),
            (this.rules[44].opcodes = []),
            (this.rules[44].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[44].opcodes[1] = { type: 6, string: [47] }),
            (this.rules[44].opcodes[2] = { type: 4, index: 89 }),
            (this.rules[45].opcodes = []),
            (this.rules[45].opcodes[0] = { type: 4, index: 90 }),
            (this.rules[46].opcodes = []),
            (this.rules[46].opcodes[0] = { type: 6, string: [42] }),
            (this.rules[47].opcodes = []),
            (this.rules[47].opcodes[0] = { type: 6, string: [38] }),
            (this.rules[48].opcodes = []),
            (this.rules[48].opcodes[0] = { type: 6, string: [33] }),
            (this.rules[49].opcodes = []),
            (this.rules[49].opcodes[0] = { type: 6, string: [38, 38] }),
            (this.rules[50].opcodes = []),
            (this.rules[50].opcodes[0] = { type: 6, string: [33, 33] }),
            (this.rules[51].opcodes = []),
            (this.rules[51].opcodes[0] = { type: 6, string: [37, 94] }),
            (this.rules[52].opcodes = []),
            (this.rules[52].opcodes[0] = { type: 6, string: [37, 36] }),
            (this.rules[53].opcodes = []),
            (this.rules[53].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[53].opcodes[1] = { type: 6, string: [37] }),
            (this.rules[53].opcodes[2] = { type: 1, children: [3, 8, 13] }),
            (this.rules[53].opcodes[3] = { type: 2, children: [4, 5, 6, 7] }),
            (this.rules[53].opcodes[4] = { type: 4, index: 76 }),
            (this.rules[53].opcodes[5] = { type: 4, index: 79 }),
            (this.rules[53].opcodes[6] = { type: 6, string: [45] }),
            (this.rules[53].opcodes[7] = { type: 4, index: 80 }),
            (this.rules[53].opcodes[8] = {
              type: 2,
              children: [9, 10, 11, 12],
            }),
            (this.rules[53].opcodes[9] = { type: 4, index: 77 }),
            (this.rules[53].opcodes[10] = { type: 4, index: 83 }),
            (this.rules[53].opcodes[11] = { type: 6, string: [45] }),
            (this.rules[53].opcodes[12] = { type: 4, index: 84 }),
            (this.rules[53].opcodes[13] = {
              type: 2,
              children: [14, 15, 16, 17],
            }),
            (this.rules[53].opcodes[14] = { type: 4, index: 78 }),
            (this.rules[53].opcodes[15] = { type: 4, index: 81 }),
            (this.rules[53].opcodes[16] = { type: 6, string: [45] }),
            (this.rules[53].opcodes[17] = { type: 4, index: 82 }),
            (this.rules[54].opcodes = []),
            (this.rules[54].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[54].opcodes[1] = { type: 6, string: [37] }),
            (this.rules[54].opcodes[2] = { type: 1, children: [3, 10, 17] }),
            (this.rules[54].opcodes[3] = { type: 2, children: [4, 5, 6] }),
            (this.rules[54].opcodes[4] = { type: 4, index: 76 }),
            (this.rules[54].opcodes[5] = { type: 4, index: 73 }),
            (this.rules[54].opcodes[6] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[54].opcodes[7] = { type: 2, children: [8, 9] }),
            (this.rules[54].opcodes[8] = { type: 6, string: [46] }),
            (this.rules[54].opcodes[9] = { type: 4, index: 73 }),
            (this.rules[54].opcodes[10] = { type: 2, children: [11, 12, 13] }),
            (this.rules[54].opcodes[11] = { type: 4, index: 77 }),
            (this.rules[54].opcodes[12] = { type: 4, index: 74 }),
            (this.rules[54].opcodes[13] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[54].opcodes[14] = { type: 2, children: [15, 16] }),
            (this.rules[54].opcodes[15] = { type: 6, string: [46] }),
            (this.rules[54].opcodes[16] = { type: 4, index: 74 }),
            (this.rules[54].opcodes[17] = { type: 2, children: [18, 19, 20] }),
            (this.rules[54].opcodes[18] = { type: 4, index: 78 }),
            (this.rules[54].opcodes[19] = { type: 4, index: 75 }),
            (this.rules[54].opcodes[20] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[54].opcodes[21] = { type: 2, children: [22, 23] }),
            (this.rules[54].opcodes[22] = { type: 6, string: [46] }),
            (this.rules[54].opcodes[23] = { type: 4, index: 75 }),
            (this.rules[55].opcodes = []),
            (this.rules[55].opcodes[0] = { type: 2, children: [1, 2, 3, 4] }),
            (this.rules[55].opcodes[1] = { type: 4, index: 56 }),
            (this.rules[55].opcodes[2] = { type: 4, index: 57 }),
            (this.rules[55].opcodes[3] = { type: 4, index: 59 }),
            (this.rules[55].opcodes[4] = { type: 4, index: 58 }),
            (this.rules[56].opcodes = []),
            (this.rules[56].opcodes[0] = { type: 3, min: 0, max: 1 }),
            (this.rules[56].opcodes[1] = { type: 1, children: [2, 3] }),
            (this.rules[56].opcodes[2] = { type: 7, string: [37, 105] }),
            (this.rules[56].opcodes[3] = { type: 7, string: [37, 115] }),
            (this.rules[57].opcodes = []),
            (this.rules[57].opcodes[0] = { type: 6, string: [34] }),
            (this.rules[58].opcodes = []),
            (this.rules[58].opcodes[0] = { type: 6, string: [34] }),
            (this.rules[59].opcodes = []),
            (this.rules[59].opcodes[0] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[59].opcodes[1] = { type: 1, children: [2, 3, 4] }),
            (this.rules[59].opcodes[2] = { type: 5, min: 32, max: 33 }),
            (this.rules[59].opcodes[3] = { type: 5, min: 35, max: 126 }),
            (this.rules[59].opcodes[4] = { type: 4, index: 60 }),
            (this.rules[60].opcodes = []),
            (this.rules[60].opcodes[0] = { type: 6, string: [9] }),
            (this.rules[61].opcodes = []),
            (this.rules[61].opcodes[0] = { type: 2, children: [1, 2, 3] }),
            (this.rules[61].opcodes[1] = { type: 4, index: 62 }),
            (this.rules[61].opcodes[2] = { type: 4, index: 64 }),
            (this.rules[61].opcodes[3] = { type: 4, index: 63 }),
            (this.rules[62].opcodes = []),
            (this.rules[62].opcodes[0] = { type: 6, string: [39] }),
            (this.rules[63].opcodes = []),
            (this.rules[63].opcodes[0] = { type: 6, string: [39] }),
            (this.rules[64].opcodes = []),
            (this.rules[64].opcodes[0] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[64].opcodes[1] = { type: 1, children: [2, 3, 4] }),
            (this.rules[64].opcodes[2] = { type: 5, min: 32, max: 38 }),
            (this.rules[64].opcodes[3] = { type: 5, min: 40, max: 126 }),
            (this.rules[64].opcodes[4] = { type: 4, index: 60 }),
            (this.rules[65].opcodes = []),
            (this.rules[65].opcodes[0] = { type: 2, children: [1, 2, 3] }),
            (this.rules[65].opcodes[1] = { type: 4, index: 66 }),
            (this.rules[65].opcodes[2] = { type: 4, index: 67 }),
            (this.rules[65].opcodes[3] = { type: 4, index: 68 }),
            (this.rules[66].opcodes = []),
            (this.rules[66].opcodes[0] = { type: 6, string: [60] }),
            (this.rules[67].opcodes = []),
            (this.rules[67].opcodes[0] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[67].opcodes[1] = { type: 1, children: [2, 3, 4] }),
            (this.rules[67].opcodes[2] = { type: 5, min: 32, max: 61 }),
            (this.rules[67].opcodes[3] = { type: 5, min: 63, max: 126 }),
            (this.rules[67].opcodes[4] = { type: 4, index: 60 }),
            (this.rules[68].opcodes = []),
            (this.rules[68].opcodes[0] = { type: 6, string: [62] }),
            (this.rules[69].opcodes = []),
            (this.rules[69].opcodes[0] = { type: 4, index: 72 }),
            (this.rules[70].opcodes = []),
            (this.rules[70].opcodes[0] = { type: 4, index: 72 }),
            (this.rules[71].opcodes = []),
            (this.rules[71].opcodes[0] = { type: 4, index: 72 }),
            (this.rules[72].opcodes = []),
            (this.rules[72].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
            (this.rules[72].opcodes[1] = { type: 5, min: 48, max: 57 }),
            (this.rules[73].opcodes = []),
            (this.rules[73].opcodes[0] = { type: 4, index: 85 }),
            (this.rules[74].opcodes = []),
            (this.rules[74].opcodes[0] = { type: 4, index: 87 }),
            (this.rules[75].opcodes = []),
            (this.rules[75].opcodes[0] = { type: 4, index: 86 }),
            (this.rules[76].opcodes = []),
            (this.rules[76].opcodes[0] = { type: 1, children: [1, 2] }),
            (this.rules[76].opcodes[1] = { type: 6, string: [68] }),
            (this.rules[76].opcodes[2] = { type: 6, string: [100] }),
            (this.rules[77].opcodes = []),
            (this.rules[77].opcodes[0] = { type: 1, children: [1, 2] }),
            (this.rules[77].opcodes[1] = { type: 6, string: [88] }),
            (this.rules[77].opcodes[2] = { type: 6, string: [120] }),
            (this.rules[78].opcodes = []),
            (this.rules[78].opcodes[0] = { type: 1, children: [1, 2] }),
            (this.rules[78].opcodes[1] = { type: 6, string: [66] }),
            (this.rules[78].opcodes[2] = { type: 6, string: [98] }),
            (this.rules[79].opcodes = []),
            (this.rules[79].opcodes[0] = { type: 4, index: 85 }),
            (this.rules[80].opcodes = []),
            (this.rules[80].opcodes[0] = { type: 4, index: 85 }),
            (this.rules[81].opcodes = []),
            (this.rules[81].opcodes[0] = { type: 4, index: 86 }),
            (this.rules[82].opcodes = []),
            (this.rules[82].opcodes[0] = { type: 4, index: 86 }),
            (this.rules[83].opcodes = []),
            (this.rules[83].opcodes[0] = { type: 4, index: 87 }),
            (this.rules[84].opcodes = []),
            (this.rules[84].opcodes[0] = { type: 4, index: 87 }),
            (this.rules[85].opcodes = []),
            (this.rules[85].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
            (this.rules[85].opcodes[1] = { type: 5, min: 48, max: 57 }),
            (this.rules[86].opcodes = []),
            (this.rules[86].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
            (this.rules[86].opcodes[1] = { type: 5, min: 48, max: 49 }),
            (this.rules[87].opcodes = []),
            (this.rules[87].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
            (this.rules[87].opcodes[1] = { type: 1, children: [2, 3, 4] }),
            (this.rules[87].opcodes[2] = { type: 5, min: 48, max: 57 }),
            (this.rules[87].opcodes[3] = { type: 5, min: 65, max: 70 }),
            (this.rules[87].opcodes[4] = { type: 5, min: 97, max: 102 }),
            (this.rules[88].opcodes = []),
            (this.rules[88].opcodes[0] = { type: 2, children: [1, 4] }),
            (this.rules[88].opcodes[1] = { type: 1, children: [2, 3] }),
            (this.rules[88].opcodes[2] = { type: 5, min: 97, max: 122 }),
            (this.rules[88].opcodes[3] = { type: 5, min: 65, max: 90 }),
            (this.rules[88].opcodes[4] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[88].opcodes[5] = { type: 1, children: [6, 7, 8, 9] }),
            (this.rules[88].opcodes[6] = { type: 5, min: 97, max: 122 }),
            (this.rules[88].opcodes[7] = { type: 5, min: 65, max: 90 }),
            (this.rules[88].opcodes[8] = { type: 5, min: 48, max: 57 }),
            (this.rules[88].opcodes[9] = { type: 6, string: [45] }),
            (this.rules[89].opcodes = []),
            (this.rules[89].opcodes[0] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[89].opcodes[1] = { type: 4, index: 91 }),
            (this.rules[90].opcodes = []),
            (this.rules[90].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
            (this.rules[90].opcodes[1] = { type: 4, index: 91 }),
            (this.rules[91].opcodes = []),
            (this.rules[91].opcodes[0] = { type: 1, children: [1, 2, 3, 4] }),
            (this.rules[91].opcodes[1] = { type: 6, string: [32] }),
            (this.rules[91].opcodes[2] = { type: 6, string: [9] }),
            (this.rules[91].opcodes[3] = { type: 4, index: 92 }),
            (this.rules[91].opcodes[4] = { type: 4, index: 94 }),
            (this.rules[92].opcodes = []),
            (this.rules[92].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[92].opcodes[1] = { type: 6, string: [59] }),
            (this.rules[92].opcodes[2] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[92].opcodes[3] = { type: 1, children: [4, 5] }),
            (this.rules[92].opcodes[4] = { type: 5, min: 32, max: 126 }),
            (this.rules[92].opcodes[5] = { type: 6, string: [9] }),
            (this.rules[93].opcodes = []),
            (this.rules[93].opcodes[0] = { type: 1, children: [1, 2, 3] }),
            (this.rules[93].opcodes[1] = { type: 6, string: [13, 10] }),
            (this.rules[93].opcodes[2] = { type: 6, string: [10] }),
            (this.rules[93].opcodes[3] = { type: 6, string: [13] }),
            (this.rules[94].opcodes = []),
            (this.rules[94].opcodes[0] = { type: 2, children: [1, 5] }),
            (this.rules[94].opcodes[1] = { type: 1, children: [2, 3, 4] }),
            (this.rules[94].opcodes[2] = { type: 6, string: [13, 10] }),
            (this.rules[94].opcodes[3] = { type: 6, string: [10] }),
            (this.rules[94].opcodes[4] = { type: 6, string: [13] }),
            (this.rules[94].opcodes[5] = { type: 1, children: [6, 7] }),
            (this.rules[94].opcodes[6] = { type: 6, string: [32] }),
            (this.rules[94].opcodes[7] = { type: 6, string: [9] }),
            (this.toString = function () {
              return ";\n; ABNF for JavaScript APG 2.0 SABNF\n; RFC 5234 with some restrictions and additions.\n; Updated 11/24/2015 for RFC 7405 case-sensitive literal string notation\n;  - accepts %s\"string\" as a case-sensitive string\n;  - accepts %i\"string\" as a case-insensitive string\n;  - accepts \"string\" as a case-insensitive string\n;\n; Some restrictions:\n;   1. Rules must begin at first character of each line.\n;      Indentations on first rule and rules thereafter are not allowed.\n;   2. Relaxed line endings. CRLF, LF or CR are accepted as valid line ending.\n;   3. Prose values, i.e. <prose value>, are accepted as valid grammar syntax.\n;      However, a working parser cannot be generated from them.\n;\n; Super set (SABNF) additions:\n;   1. Look-ahead (syntactic predicate) operators are accepted as element prefixes.\n;      & is the positive look-ahead operator, succeeds and backtracks if the look-ahead phrase is found\n;      ! is the negative look-ahead operator, succeeds and backtracks if the look-ahead phrase is NOT found\n;      e.g. &%d13 or &rule or !(A / B)\n;   2. User-Defined Terminals (UDT) of the form, u_name and e_name are accepted.\n;      'name' is alpha followed by alpha/num/hyphen just like a rule name.\n;      u_name may be used as an element but no rule definition is given.\n;      e.g. rule = A / u_myUdt\n;           A = \"a\"\n;      would be a valid grammar.\n;   3. Case-sensitive, single-quoted strings are accepted.\n;      e.g. 'abc' would be equivalent to %d97.98.99\n;      (kept for backward compatibility, but superseded by %s\"abc\")  \n; New 12/26/2015\n;   4. Look-behind operators are accepted as element prefixes.\n;      && is the positive look-behind operator, succeeds and backtracks if the look-behind phrase is found\n;      !! is the negative look-behind operator, succeeds and backtracks if the look-behind phrase is NOT found\n;      e.g. &&%d13 or &&rule or !!(A / B)\n;   5. Back reference operators, i.e. \\rulename, are accepted.\n;      A back reference operator acts like a TLS or TBS terminal except that the phrase it attempts\n;      to match is a phrase previously matched by the rule 'rulename'.\n;      There are two modes of previous phrase matching - the parent-frame mode and the universal mode.\n;      In universal mode, \\rulename matches the last match to 'rulename' regardless of where it was found.\n;      In parent-frame mode, \\rulename matches only the last match found on the parent's frame or parse tree level.\n;      Back reference modifiers can be used to specify case and mode.\n;      \\A defaults to case-insensitive and universal mode, e.g. \\A === \\%i%uA\n;      Modifiers %i and %s determine case-insensitive and case-sensitive mode, respectively.\n;      Modifiers %u and %p determine universal mode and parent frame mode, respectively.\n;      Case and mode modifiers can appear in any order, e.g. \\%s%pA === \\%p%sA. \n;   7. String begin anchor, ABG(%^) matches the beginning of the input string location.\n;      Returns EMPTY or NOMATCH. Never consumes any characters.\n;   8. String end anchor, AEN(%$) matches the end of the input string location.\n;      Returns EMPTY or NOMATCH. Never consumes any characters.\n;\nFile            = *(BlankLine / Rule / RuleError)\nBlankLine       = *(%d32/%d9) [comment] LineEnd\nRule            = RuleLookup owsp Alternation ((owsp LineEnd)\n                / (LineEndError LineEnd))\nRuleLookup      = RuleNameTest owsp DefinedAsTest\nRuleNameTest    = RuleName/RuleNameError\nRuleName        = alphanum\nRuleNameError   = 1*(%d33-60/%d62-126)\nDefinedAsTest   = DefinedAs / DefinedAsError\nDefinedAsError  = 1*2%d33-126\nDefinedAs       = IncAlt / Defined\nDefined         = %d61\nIncAlt          = %d61.47\nRuleError       = 1*(%d32-126 / %d9  / LineContinue) LineEnd\nLineEndError    = 1*(%d32-126 / %d9  / LineContinue)\nAlternation     = Concatenation *(owsp AltOp Concatenation)\nConcatenation   = Repetition *(CatOp Repetition)\nRepetition      = [Modifier] (Group / Option / BasicElement / BasicElementErr)\nModifier        = (Predicate [RepOp])\n                / RepOp\nPredicate       = BkaOp\n                / BknOp\n                / AndOp\n                / NotOp\nBasicElement    = UdtOp\n                / RnmOp\n                / TrgOp\n                / TbsOp\n                / TlsOp\n                / ClsOp\n                / BkrOp\n                / AbgOp\n                / AenOp\n                / ProsVal\nBasicElementErr = 1*(%d33-40/%d42-46/%d48-92/%d94-126)\nGroup           = GroupOpen  Alternation (GroupClose / GroupError)\nGroupError      = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\nGroupOpen       = %d40 owsp\nGroupClose      = owsp %d41\nOption          = OptionOpen Alternation (OptionClose / OptionError)\nOptionError     = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\nOptionOpen      = %d91 owsp\nOptionClose     = owsp %d93\nRnmOp           = alphanum\nBkrOp           = %d92 [bkrModifier] bkr-name\nbkrModifier     = (cs [um / pm]) / (ci [um / pm]) / (um [cs /ci]) / (pm [cs / ci])\ncs              = '%s'\nci              = '%i'\num              = '%u'\npm              = '%p'\nbkr-name        = uname / ename / rname\nrname           = alphanum\nuname           = %d117.95 alphanum\nename           = %d101.95 alphanum\nUdtOp           = udt-empty\n                / udt-non-empty\nudt-non-empty   = %d117.95 alphanum\nudt-empty       = %d101.95 alphanum\nRepOp           = (rep-min StarOp rep-max)\n                / (rep-min StarOp)\n                / (StarOp rep-max)\n                / StarOp\n                / rep-min-max\nAltOp           = %d47 owsp\nCatOp           = wsp\nStarOp          = %d42\nAndOp           = %d38\nNotOp           = %d33\nBkaOp           = %d38.38\nBknOp           = %d33.33\nAbgOp           = %d37.94\nAenOp           = %d37.36\nTrgOp           = %d37 ((Dec dmin %d45 dmax) / (Hex xmin %d45 xmax) / (Bin bmin %d45 bmax))\nTbsOp           = %d37 ((Dec dString *(%d46 dString)) / (Hex xString *(%d46 xString)) / (Bin bString *(%d46 bString)))\nTlsOp           = TlsCase TlsOpen TlsString TlsClose\nTlsCase         = [\"%i\" / \"%s\"]\nTlsOpen         = %d34\nTlsClose        = %d34\nTlsString       = *(%d32-33/%d35-126/StringTab)\nStringTab       = %d9\nClsOp           = ClsOpen ClsString ClsClose\nClsOpen         = %d39\nClsClose        = %d39\nClsString       = *(%d32-38/%d40-126/StringTab)\nProsVal         = ProsValOpen ProsValString ProsValClose\nProsValOpen     = %d60\nProsValString   = *(%d32-61/%d63-126/StringTab)\nProsValClose    = %d62\nrep-min         = rep-num\nrep-min-max     = rep-num\nrep-max         = rep-num\nrep-num         = 1*(%d48-57)\ndString         = dnum\nxString         = xnum\nbString         = bnum\nDec             = (%d68/%d100)\nHex             = (%d88/%d120)\nBin             = (%d66/%d98)\ndmin            = dnum\ndmax            = dnum\nbmin            = bnum\nbmax            = bnum\nxmin            = xnum\nxmax            = xnum\ndnum            = 1*(%d48-57)\nbnum            = 1*%d48-49\nxnum            = 1*(%d48-57 / %d65-70 / %d97-102)\n;\n; Basics\nalphanum        = (%d97-122/%d65-90) *(%d97-122/%d65-90/%d48-57/%d45)\nowsp            = *space\nwsp             = 1*space\nspace           = %d32\n                / %d9\n                / comment\n                / LineContinue\ncomment         = %d59 *(%d32-126 / %d9)\nLineEnd         = %d13.10\n                / %d10\n                / %d13\nLineContinue    = (%d13.10 / %d10 / %d13) (%d32 / %d9)\n";
            });
        };
      },
      73479: function (e, t, n) {
        let s = n(58276),
          i = n(8544),
          a = [];
        (a.line = function (e, t, n, i, a) {
          return (
            e === s.SEM_PRE
              ? ((a.endLength = 0), (a.textLength = 0), (a.invalidCount = 0))
              : a.lines.push({
                  lineNo: a.lines.length,
                  beginChar: n,
                  length: i,
                  textLength: a.textLength,
                  endType: a.endType,
                  invalidChars: a.invalidCount,
                }),
            s.SEM_OK
          );
        }),
          (a["line-text"] = function (e, t, n, i, a) {
            return e === s.SEM_PRE && (a.textLength = i), s.SEM_OK;
          }),
          (a["last-line"] = function (e, t, n, i, a) {
            return (
              e === s.SEM_PRE
                ? ((a.endLength = 0), (a.textLength = 0), (a.invalidCount = 0))
                : a.strict
                ? (a.lines.push({
                    lineNo: a.lines.length,
                    beginChar: n,
                    length: i,
                    textLength: i,
                    endType: "none",
                    invalidChars: a.invalidCount,
                  }),
                  a.errors.push({
                    line: a.lineNo,
                    char: n + i,
                    msg: "no line end on last line - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)",
                  }))
                : (t.push(10),
                  a.lines.push({
                    lineNo: a.lines.length,
                    beginChar: n,
                    length: i + 1,
                    textLength: i,
                    endType: "LF",
                    invalidChars: a.invalidCount,
                  })),
              s.SEM_OK
            );
          }),
          (a.invalid = function (e, t, n, a, o) {
            return (
              e === s.SEM_PRE &&
                o.errors.push({
                  line: o.lineNo,
                  char: n,
                  msg: `invalid character found '\\x${i.charToHex(t[n])}'`,
                }),
              s.SEM_OK
            );
          }),
          (a.end = function (e, t, n, i, a) {
            return e === s.SEM_POST && (a.lineNo += 1), s.SEM_OK;
          }),
          (a.lf = function (e, t, n, i, a) {
            return (
              e === s.SEM_PRE &&
                ((a.endType = "LF"),
                a.strict &&
                  a.errors.push({
                    line: a.lineNo,
                    char: n,
                    msg: "line end character LF(\\n, \\x0A) - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)",
                  })),
              s.SEM_OK
            );
          }),
          (a.cr = function (e, t, n, i, a) {
            return (
              e === s.SEM_PRE &&
                ((a.endType = "CR"),
                a.strict &&
                  a.errors.push({
                    line: a.lineNo,
                    char: n,
                    msg: "line end character CR(\\r, \\x0D) - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)",
                  })),
              s.SEM_OK
            );
          }),
          (a.crlf = function (e, t, n, i, a) {
            return e === s.SEM_PRE && (a.endType = "CRLF"), s.SEM_OK;
          }),
          (t.callbacks = a);
      },
      66410: function (e) {
        e.exports = function () {
          (this.grammarObject = "grammarObject"),
            (this.rules = []),
            (this.rules[0] = {
              name: "file",
              lower: "file",
              index: 0,
              isBkr: !1,
            }),
            (this.rules[1] = {
              name: "line",
              lower: "line",
              index: 1,
              isBkr: !1,
            }),
            (this.rules[2] = {
              name: "line-text",
              lower: "line-text",
              index: 2,
              isBkr: !1,
            }),
            (this.rules[3] = {
              name: "last-line",
              lower: "last-line",
              index: 3,
              isBkr: !1,
            }),
            (this.rules[4] = {
              name: "valid",
              lower: "valid",
              index: 4,
              isBkr: !1,
            }),
            (this.rules[5] = {
              name: "invalid",
              lower: "invalid",
              index: 5,
              isBkr: !1,
            }),
            (this.rules[6] = {
              name: "end",
              lower: "end",
              index: 6,
              isBkr: !1,
            }),
            (this.rules[7] = {
              name: "CRLF",
              lower: "crlf",
              index: 7,
              isBkr: !1,
            }),
            (this.rules[8] = { name: "LF", lower: "lf", index: 8, isBkr: !1 }),
            (this.rules[9] = { name: "CR", lower: "cr", index: 9, isBkr: !1 }),
            (this.udts = []),
            (this.rules[0].opcodes = []),
            (this.rules[0].opcodes[0] = { type: 2, children: [1, 3] }),
            (this.rules[0].opcodes[1] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[0].opcodes[2] = { type: 4, index: 1 }),
            (this.rules[0].opcodes[3] = { type: 3, min: 0, max: 1 }),
            (this.rules[0].opcodes[4] = { type: 4, index: 3 }),
            (this.rules[1].opcodes = []),
            (this.rules[1].opcodes[0] = { type: 2, children: [1, 2] }),
            (this.rules[1].opcodes[1] = { type: 4, index: 2 }),
            (this.rules[1].opcodes[2] = { type: 4, index: 6 }),
            (this.rules[2].opcodes = []),
            (this.rules[2].opcodes[0] = { type: 3, min: 0, max: 1 / 0 }),
            (this.rules[2].opcodes[1] = { type: 1, children: [2, 3] }),
            (this.rules[2].opcodes[2] = { type: 4, index: 4 }),
            (this.rules[2].opcodes[3] = { type: 4, index: 5 }),
            (this.rules[3].opcodes = []),
            (this.rules[3].opcodes[0] = { type: 3, min: 1, max: 1 / 0 }),
            (this.rules[3].opcodes[1] = { type: 1, children: [2, 3] }),
            (this.rules[3].opcodes[2] = { type: 4, index: 4 }),
            (this.rules[3].opcodes[3] = { type: 4, index: 5 }),
            (this.rules[4].opcodes = []),
            (this.rules[4].opcodes[0] = { type: 1, children: [1, 2] }),
            (this.rules[4].opcodes[1] = { type: 5, min: 32, max: 126 }),
            (this.rules[4].opcodes[2] = { type: 6, string: [9] }),
            (this.rules[5].opcodes = []),
            (this.rules[5].opcodes[0] = { type: 1, children: [1, 2, 3, 4] }),
            (this.rules[5].opcodes[1] = { type: 5, min: 0, max: 8 }),
            (this.rules[5].opcodes[2] = { type: 5, min: 11, max: 12 }),
            (this.rules[5].opcodes[3] = { type: 5, min: 14, max: 31 }),
            (this.rules[5].opcodes[4] = { type: 5, min: 127, max: 4294967295 }),
            (this.rules[6].opcodes = []),
            (this.rules[6].opcodes[0] = { type: 1, children: [1, 2, 3] }),
            (this.rules[6].opcodes[1] = { type: 4, index: 7 }),
            (this.rules[6].opcodes[2] = { type: 4, index: 8 }),
            (this.rules[6].opcodes[3] = { type: 4, index: 9 }),
            (this.rules[7].opcodes = []),
            (this.rules[7].opcodes[0] = { type: 6, string: [13, 10] }),
            (this.rules[8].opcodes = []),
            (this.rules[8].opcodes[0] = { type: 6, string: [10] }),
            (this.rules[9].opcodes = []),
            (this.rules[9].opcodes[0] = { type: 6, string: [13] }),
            (this.toString = function () {
              return "file = *line [last-line]\nline = line-text end\nline-text = *(valid/invalid)\nlast-line = 1*(valid/invalid)\nvalid = %d32-126 / %d9\ninvalid = %d0-8 / %d11-12 /%d14-31 / %x7f-ffffffff\nend = CRLF / LF / CR\nCRLF = %d13.10\nLF = %d10\nCR = %d13\n";
            });
        };
      },
      1789: function (e, t, n) {
        e.exports = function (e, t, s, i) {
          let a = n(28737),
            o = new (n(66410))(),
            { callbacks: l } = n(73479),
            u = [],
            c = new a.parser();
          if (((c.ast = new a.ast()), (c.ast.callbacks = l), i)) {
            if ("traceObject" !== i.traceObject)
              throw TypeError(
                "scanner.js: trace argument is not a trace object"
              );
            c.trace = i;
          }
          if (!0 !== c.parse(o, "file", e).success) {
            t.push({
              line: 0,
              char: 0,
              msg: "syntax analysis error analyzing input SABNF grammar",
            });
            return;
          }
          return (
            c.ast.translate({ lines: u, lineNo: 0, errors: t, strict: !!s }), u
          );
        };
      },
      11832: function (e, t, n) {
        e.exports = function () {
          let e = n(28737),
            t = e.ids,
            s = function () {
              (this.names = []),
                (this.add = function (e) {
                  let t = -1;
                  return (
                    -1 === this.get(e) &&
                      ((t = {
                        name: e,
                        lower: e.toLowerCase(),
                        index: this.names.length,
                      }),
                      this.names.push(t)),
                    t
                  );
                }),
                (this.get = function (e) {
                  let t = -1,
                    n = e.toLowerCase();
                  for (let e = 0; e < this.names.length; e += 1)
                    if (this.names[e].lower === n) {
                      t = this.names[e];
                      break;
                    }
                  return t;
                });
            },
            i = function (e, t, n) {
              let s = 0;
              for (let i = t; i < t + n; i += 1) s = 10 * s + e[i] - 48;
              return s;
            },
            a = function (e, t, n) {
              let s = 0;
              for (let i = t; i < t + n; i += 1) s = 2 * s + e[i] - 48;
              return s;
            },
            o = function (e, t, n) {
              let s = 0;
              for (let i = t; i < t + n; i += 1) {
                let t = e[i];
                if (t >= 48 && t <= 57) t -= 48;
                else if (t >= 65 && t <= 70) t -= 55;
                else if (t >= 97 && t <= 102) t -= 87;
                else throw Error("hexnum out of range");
                s = 16 * s + t;
              }
              return s;
            };
          (this.callbacks = []),
            (this.callbacks.abgop = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return e === t.SEM_POST && a.opcodes.push({ type: t.ABG }), o;
            }),
            (this.callbacks.aenop = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return e === t.SEM_POST && a.opcodes.push({ type: t.AEN }), o;
            }),
            (this.callbacks.alternation = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              if (e === t.SEM_PRE)
                for (;;) {
                  if (null === a.definedas) {
                    o = t.SEM_SKIP;
                    break;
                  }
                  if (null === a.topStack) {
                    if ("=" === a.definedas) {
                      (a.topStack = {
                        alt: { type: t.ALT, children: [] },
                        cat: null,
                      }),
                        a.altStack.push(a.topStack),
                        a.opcodes.push(a.topStack.alt);
                      break;
                    }
                    (a.topStack = { alt: a.opcodes[0], cat: null }),
                      a.altStack.push(a.topStack);
                    break;
                  }
                  (a.topStack = {
                    alt: { type: t.ALT, children: [] },
                    cat: null,
                  }),
                    a.altStack.push(a.topStack),
                    a.opcodes.push(a.topStack.alt);
                  break;
                }
              else
                e === t.SEM_POST &&
                  (a.altStack.pop(),
                  a.altStack.length > 0
                    ? (a.topStack = a.altStack[a.altStack.length - 1])
                    : (a.topStack = null));
              return o;
            }),
            (this.callbacks.andop = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return e === t.SEM_POST && a.opcodes.push({ type: t.AND }), o;
            }),
            (this.callbacks.bmax = function (e, n, s, i, o) {
              let l = t.SEM_OK;
              return e === t.SEM_POST && (o.max = a(n, s, i)), l;
            }),
            (this.callbacks.bmin = function (e, n, s, i, o) {
              let l = t.SEM_OK;
              return e === t.SEM_POST && (o.min = a(n, s, i)), l;
            }),
            (this.callbacks.bkaop = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return e === t.SEM_POST && a.opcodes.push({ type: t.BKA }), o;
            }),
            (this.callbacks.bknop = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return e === t.SEM_POST && a.opcodes.push({ type: t.BKN }), o;
            }),
            (this.callbacks.bkrop = function (n, s, i, a, o) {
              let l = t.SEM_OK;
              return (
                n === t.SEM_PRE
                  ? ((o.ci = !0), (o.cs = !1), (o.um = !0), (o.pm = !1))
                  : n === t.SEM_POST &&
                    o.opcodes.push({
                      type: t.BKR,
                      bkrCase: !0 === o.cs ? t.BKR_MODE_CS : t.BKR_MODE_CI,
                      bkrMode: !0 === o.pm ? t.BKR_MODE_PM : t.BKR_MODE_UM,
                      index: {
                        phraseIndex: o.bkrname.phraseIndex,
                        name: e.utils.charsToString(
                          s,
                          o.bkrname.phraseIndex,
                          o.bkrname.phraseLength
                        ),
                      },
                    }),
                l
              );
            }),
            (this.callbacks["bkr-name"] = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return (
                e === t.SEM_POST &&
                  (a.bkrname = { phraseIndex: s, phraseLength: i }),
                o
              );
            }),
            (this.callbacks.bstring = function (e, n, s, i, o) {
              let l = t.SEM_OK;
              return e === t.SEM_POST && o.tbsstr.push(a(n, s, i)), l;
            }),
            (this.callbacks.clsop = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return (
                e === t.SEM_POST &&
                  (i <= 2
                    ? a.opcodes.push({ type: t.TLS, string: [] })
                    : a.opcodes.push({
                        type: t.TBS,
                        string: n.slice(s + 1, s + i - 1),
                      })),
                o
              );
            }),
            (this.callbacks.ci = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return e === t.SEM_POST && (a.ci = !0), o;
            }),
            (this.callbacks.cs = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return e === t.SEM_POST && (a.cs = !0), o;
            }),
            (this.callbacks.um = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return e === t.SEM_POST && (a.um = !0), o;
            }),
            (this.callbacks.pm = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return e === t.SEM_POST && (a.pm = !0), o;
            }),
            (this.callbacks.concatenation = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return (
                e === t.SEM_PRE
                  ? (a.topStack.alt.children.push(a.opcodes.length),
                    (a.topStack.cat = { type: t.CAT, children: [] }),
                    a.opcodes.push(a.topStack.cat))
                  : e === t.SEM_POST && (a.topStack.cat = null),
                o
              );
            }),
            (this.callbacks.defined = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return e === t.SEM_POST && (a.definedas = "="), o;
            }),
            (this.callbacks.dmax = function (e, n, s, a, o) {
              let l = t.SEM_OK;
              return e === t.SEM_POST && (o.max = i(n, s, a)), l;
            }),
            (this.callbacks.dmin = function (e, n, s, a, o) {
              let l = t.SEM_OK;
              return e === t.SEM_POST && (o.min = i(n, s, a)), l;
            }),
            (this.callbacks.dstring = function (e, n, s, a, o) {
              let l = t.SEM_OK;
              return e === t.SEM_POST && o.tbsstr.push(i(n, s, a)), l;
            }),
            (this.callbacks.file = function (e, n, i, a, o) {
              let l = t.SEM_OK;
              if (e === t.SEM_PRE)
                (o.ruleNames = new s()),
                  (o.udtNames = new s()),
                  (o.rules = []),
                  (o.udts = []),
                  (o.rulesLineMap = []),
                  (o.opcodes = []),
                  (o.altStack = []),
                  (o.topStack = null),
                  (o.topRule = null);
              else if (e === t.SEM_POST) {
                let e;
                o.rules.forEach((n) => {
                  (n.isBkr = !1),
                    n.opcodes.forEach((n) => {
                      n.type === t.RNM &&
                        (-1 === (e = o.ruleNames.get(n.index.name))
                          ? (o.errors.push({
                              line: o.findLine(
                                o.lines,
                                n.index.phraseIndex,
                                o.charsLength
                              ),
                              char: n.index.phraseIndex,
                              msg: `Rule name '${n.index.name}' used but not defined.`,
                            }),
                            (n.index = -1))
                          : (n.index = e.index));
                    });
                }),
                  o.udts.forEach((e) => {
                    e.isBkr = !1;
                  }),
                  o.rules.forEach((n) => {
                    n.opcodes.forEach((s) => {
                      s.type === t.BKR &&
                        ((n.hasBkr = !0),
                        -1 !== (e = o.ruleNames.get(s.index.name))
                          ? ((o.rules[e.index].isBkr = !0), (s.index = e.index))
                          : -1 !== (e = o.udtNames.get(s.index.name))
                          ? ((o.udts[e.index].isBkr = !0),
                            (s.index = o.rules.length + e.index))
                          : (o.errors.push({
                              line: o.findLine(
                                o.lines,
                                s.index.phraseIndex,
                                o.charsLength
                              ),
                              char: s.index.phraseIndex,
                              msg: `Back reference name '${s.index.name}' refers to undefined rule or unamed UDT.`,
                            }),
                            (s.index = -1)));
                    });
                  });
              }
              return l;
            }),
            (this.callbacks.incalt = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return e === t.SEM_POST && (a.definedas = "=/"), o;
            }),
            (this.callbacks.notop = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return e === t.SEM_POST && a.opcodes.push({ type: t.NOT }), o;
            }),
            (this.callbacks.optionopen = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return (
                e === t.SEM_POST &&
                  a.opcodes.push({ type: t.REP, min: 0, max: 1, char: s }),
                o
              );
            }),
            (this.callbacks["rep-max"] = function (e, n, s, a, o) {
              let l = t.SEM_OK;
              return e === t.SEM_POST && (o.max = i(n, s, a)), l;
            }),
            (this.callbacks["rep-min"] = function (e, n, s, a, o) {
              let l = t.SEM_OK;
              return e === t.SEM_POST && (o.min = i(n, s, a)), l;
            }),
            (this.callbacks["rep-min-max"] = function (e, n, s, a, o) {
              let l = t.SEM_OK;
              return (
                e === t.SEM_POST && ((o.max = i(n, s, a)), (o.min = o.max)), l
              );
            }),
            (this.callbacks.repetition = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return (
                e === t.SEM_PRE &&
                  a.topStack.cat.children.push(a.opcodes.length),
                o
              );
            }),
            (this.callbacks.repop = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return (
                e === t.SEM_PRE
                  ? ((a.min = 0),
                    (a.max = 1 / 0),
                    (a.topRep = { type: t.REP, min: 0, max: 1 / 0 }),
                    a.opcodes.push(a.topRep))
                  : e === t.SEM_POST &&
                    (a.min > a.max &&
                      a.errors.push({
                        line: a.findLine(a.lines, s, a.charsLength),
                        char: s,
                        msg: `repetition min cannot be greater than max: min: ${a.min}: max: ${a.max}`,
                      }),
                    (a.topRep.min = a.min),
                    (a.topRep.max = a.max)),
                o
              );
            }),
            (this.callbacks.rnmop = function (n, s, i, a, o) {
              let l = t.SEM_OK;
              return (
                n === t.SEM_POST &&
                  o.opcodes.push({
                    type: t.RNM,
                    index: {
                      phraseIndex: i,
                      name: e.utils.charsToString(s, i, a),
                    },
                  }),
                l
              );
            }),
            (this.callbacks.rule = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return (
                e === t.SEM_PRE &&
                  ((a.altStack.length = 0),
                  (a.topStack = null),
                  a.rulesLineMap.push({
                    line: a.findLine(a.lines, s, a.charsLength),
                    char: s,
                  })),
                o
              );
            }),
            (this.callbacks.rulelookup = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              if (e === t.SEM_PRE) (a.ruleName = ""), (a.definedas = "");
              else if (e === t.SEM_POST) {
                let e;
                "=" === a.definedas
                  ? -1 === (e = a.ruleNames.add(a.ruleName))
                    ? ((a.definedas = null),
                      a.errors.push({
                        line: a.findLine(a.lines, s, a.charsLength),
                        char: s,
                        msg: `Rule name '${a.ruleName}' previously defined.`,
                      }))
                    : ((a.topRule = {
                        name: e.name,
                        lower: e.lower,
                        opcodes: [],
                        index: e.index,
                      }),
                      a.rules.push(a.topRule),
                      (a.opcodes = a.topRule.opcodes))
                  : -1 === (e = a.ruleNames.get(a.ruleName))
                  ? ((a.definedas = null),
                    a.errors.push({
                      line: a.findLine(a.lines, s, a.charsLength),
                      char: s,
                      msg: `Rule name '${a.ruleName}' for incremental alternate not previously defined.`,
                    }))
                  : ((a.topRule = a.rules[e.index]),
                    (a.opcodes = a.topRule.opcodes));
              }
              return o;
            }),
            (this.callbacks.rulename = function (n, s, i, a, o) {
              let l = t.SEM_OK;
              return (
                n === t.SEM_PRE &&
                  (o.ruleName = e.utils.charsToString(s, i, a)),
                l
              );
            }),
            (this.callbacks.tbsop = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return (
                e === t.SEM_PRE
                  ? (a.tbsstr = [])
                  : e === t.SEM_POST &&
                    a.opcodes.push({ type: t.TBS, string: a.tbsstr }),
                o
              );
            }),
            (this.callbacks.tlscase = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return (
                e === t.SEM_POST &&
                  i > 0 &&
                  (83 === n[s + 1] || 115 === n[s + 1]) &&
                  (a.tlscase = !1),
                o
              );
            }),
            (this.callbacks.tlsstring = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              if (e === t.SEM_POST) {
                if (a.tlscase) {
                  let e = n.slice(s, s + i);
                  for (let t = 0; t < e.length; t += 1)
                    e[t] >= 65 && e[t] <= 90 && (e[t] += 32);
                  a.opcodes.push({ type: t.TLS, string: e });
                } else
                  a.opcodes.push({ type: t.TBS, string: n.slice(s, s + i) });
              }
              return o;
            }),
            (this.callbacks.tlsop = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return e === t.SEM_PRE && (a.tlscase = !0), o;
            }),
            (this.callbacks.trgop = function (e, n, s, i, a) {
              let o = t.SEM_OK;
              return (
                e === t.SEM_PRE
                  ? ((a.min = 0), (a.max = 0))
                  : e === t.SEM_POST &&
                    (a.min > a.max &&
                      a.errors.push({
                        line: a.findLine(a.lines, s, a.charsLength),
                        char: s,
                        msg: `TRG, (%dmin-max), min cannot be greater than max: min: ${a.min}: max: ${a.max}`,
                      }),
                    a.opcodes.push({ type: t.TRG, min: a.min, max: a.max })),
                o
              );
            }),
            (this.callbacks["udt-empty"] = function (n, s, i, a, o) {
              let l = t.SEM_OK;
              if (n === t.SEM_POST) {
                let n = e.utils.charsToString(s, i, a),
                  l = o.udtNames.add(n);
                if (-1 === l) {
                  if (-1 === (l = o.udtNames.get(n)))
                    throw Error("semUdtEmpty: name look up error");
                } else
                  o.udts.push({
                    name: l.name,
                    lower: l.lower,
                    index: l.index,
                    empty: !0,
                  });
                o.opcodes.push({ type: t.UDT, empty: !0, index: l.index });
              }
              return l;
            }),
            (this.callbacks["udt-non-empty"] = function (n, s, i, a, o) {
              let l = t.SEM_OK;
              if (n === t.SEM_POST) {
                let n = e.utils.charsToString(s, i, a),
                  l = o.udtNames.add(n);
                if (-1 === l) {
                  if (-1 === (l = o.udtNames.get(n)))
                    throw Error("semUdtNonEmpty: name look up error");
                } else
                  o.udts.push({
                    name: l.name,
                    lower: l.lower,
                    index: l.index,
                    empty: !1,
                  });
                o.opcodes.push({
                  type: t.UDT,
                  empty: !1,
                  index: l.index,
                  syntax: null,
                  semantic: null,
                });
              }
              return l;
            }),
            (this.callbacks.xmax = function (e, n, s, i, a) {
              let l = t.SEM_OK;
              return e === t.SEM_POST && (a.max = o(n, s, i)), l;
            }),
            (this.callbacks.xmin = function (e, n, s, i, a) {
              let l = t.SEM_OK;
              return e === t.SEM_POST && (a.min = o(n, s, i)), l;
            }),
            (this.callbacks.xstring = function (e, n, s, i, a) {
              let l = t.SEM_OK;
              return e === t.SEM_POST && a.tbsstr.push(o(n, s, i)), l;
            });
        };
      },
      2595: function (e) {
        e.exports = (function () {
          let e = "show-rules.js";
          return function (t = [], n = [], s = "index") {
            let i;
            let a = "showRules",
              o = [],
              l = [],
              u = [],
              c = [],
              d = t.length,
              h = n.length,
              p = "RULE/UDT NAMES";
            if (!(Array.isArray(t) && t.length))
              throw Error(`${e}:${a}: rules arg must be array with length > 0`);
            if (!Array.isArray(n))
              throw Error(`${e}:${a}: udts arg must be array`);
            for (i = 0; i < d; i += 1) u.push(i);
            if (
              ((o = u.slice(0)).sort(function (e, n) {
                return t[e].lower < t[n].lower
                  ? -1
                  : t[e].lower > t[n].lower
                  ? 1
                  : 0;
              }),
              h)
            ) {
              for (i = 0; i < h; i += 1) c.push(i);
              (l = c.slice(0)).sort(function (e, t) {
                return n[e].lower < n[t].lower
                  ? -1
                  : n[e].lower > n[t].lower
                  ? 1
                  : 0;
              });
            }
            if (97 === s.charCodeAt(0)) {
              for (
                p += " - alphabetical by rule/UDT name\n", i = 0;
                i < d;
                i += 1
              )
                p += `${i}: ${o[i]}: ${t[o[i]].name}
`;
              if (h)
                for (i = 0; i < h; i += 1)
                  p += `${i}: ${l[i]}: ${n[l[i]].name}
`;
            } else {
              for (p += " - ordered by rule/UDT index\n", i = 0; i < d; i += 1)
                p += `${i}: ${t[i].name}
`;
              if (h)
                for (i = 0; i < h; i += 1)
                  p += `${i}: ${n[i].name}
`;
            }
            return p;
          };
        })();
      },
      74216: function (e, t, n) {
        e.exports = function () {
          let e;
          let t = "syntax-callbacks.js: ",
            s = n(28737),
            i = s.ids;
          (this.callbacks = []),
            (this.callbacks.andop = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  a.strict &&
                    a.errors.push({
                      line: a.findLine(a.lines, s, a.charsLength),
                      char: s,
                      msg: "AND operator(&) found - strict ABNF specified.",
                    });
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.basicelementerr = function (n, s, a, o) {
              switch (n.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  !1 === e.basicError &&
                    o.errors.push({
                      line: o.findLine(o.lines, a, o.charsLength),
                      char: a,
                      msg: "Unrecognized SABNF element.",
                    });
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.clsclose = function (n, s, a, o) {
              switch (n.state) {
                case i.ACTIVE:
                case i.EMPTY:
                  break;
                case i.NOMATCH:
                  o.errors.push({
                    line: o.findLine(o.lines, e.clsOpen),
                    char: e.clsOpen,
                    msg: "Case-sensitive literal string('...') opened but not closed.",
                  }),
                    (e.clsOpen = null),
                    (e.basicError = !0);
                  break;
                case i.MATCH:
                  o.strict &&
                    o.errors.push({
                      line: o.findLine(o.lines, e.clsOpen),
                      char: e.clsOpen,
                      msg: "Case-sensitive string operator('...') found - strict ABNF specified.",
                    }),
                    (e.clsOpen = null);
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.clsopen = function (n, s, a) {
              switch (n.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  e.clsOpen = a;
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.clsstring = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                  a.stringTabChar = !1;
                  break;
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  !1 !== a.stringTabChar &&
                    a.errors.push({
                      line: a.findLine(a.lines, a.stringTabChar),
                      char: a.stringTabChar,
                      msg: "Tab character (\\t, x09) not allowed in literal string.",
                    });
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.definedaserror = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  a.errors.push({
                    line: a.findLine(a.lines, s, a.charsLength),
                    char: s,
                    msg: "Expected '=' or '=/'. Not found.",
                  });
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.file = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                  (a.altStack = []), (a.repCount = 0);
                  break;
                case i.EMPTY:
                  a.errors.push({
                    line: 0,
                    char: 0,
                    msg: "grammar file is empty",
                  });
                  break;
                case i.MATCH:
                  0 === a.ruleCount &&
                    a.errors.push({
                      line: 0,
                      char: 0,
                      msg: "no rules defined",
                    });
                  break;
                case i.NOMATCH:
                  throw Error(
                    `${t}synFile: grammar file NOMATCH: design error: should never happen.`
                  );
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.groupclose = function (n, s, a, o) {
              switch (n.state) {
                case i.ACTIVE:
                case i.EMPTY:
                  break;
                case i.NOMATCH:
                  o.errors.push({
                    line: o.findLine(o.lines, e.groupOpen),
                    char: e.groupOpen,
                    msg: 'Group "(...)" opened but not closed.',
                  }),
                    ((e = o.altStack.pop()).groupError = !0);
                  break;
                case i.MATCH:
                  e = o.altStack.pop();
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.groupopen = function (n, s, a, o) {
              switch (n.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  (e = {
                    groupOpen: a,
                    groupError: !1,
                    optionOpen: null,
                    optionError: !1,
                    tlsOpen: null,
                    clsOpen: null,
                    prosValOpen: null,
                    basicError: !1,
                  }),
                    o.altStack.push(e);
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.lineenderror = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  a.errors.push({
                    line: a.findLine(a.lines, s, a.charsLength),
                    char: s,
                    msg: "Unrecognized grammar element or characters.",
                  });
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.lineend = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  if (1 === e.phraseLength && a.strict) {
                    let e = 13 === n[s] ? "CR" : "LF";
                    a.errors.push({
                      line: a.findLine(a.lines, s, a.charsLength),
                      char: s,
                      msg: `Line end '${e}' found - strict ABNF specified, only CRLF allowed.`,
                    });
                  }
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.notop = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  a.strict &&
                    a.errors.push({
                      line: a.findLine(a.lines, s, a.charsLength),
                      char: s,
                      msg: "NOT operator(!) found - strict ABNF specified.",
                    });
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.optionclose = function (n, s, a, o) {
              switch (n.state) {
                case i.ACTIVE:
                case i.EMPTY:
                  break;
                case i.NOMATCH:
                  o.errors.push({
                    line: o.findLine(o.lines, e.optionOpen),
                    char: e.optionOpen,
                    msg: 'Option "[...]" opened but not closed.',
                  }),
                    ((e = o.altStack.pop()).optionError = !0);
                  break;
                case i.MATCH:
                  e = o.altStack.pop();
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.optionopen = function (n, s, a, o) {
              switch (n.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  (e = {
                    groupOpen: null,
                    groupError: !1,
                    optionOpen: a,
                    optionError: !1,
                    tlsOpen: null,
                    clsOpen: null,
                    prosValOpen: null,
                    basicError: !1,
                  }),
                    o.altStack.push(e);
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.prosvalclose = function (n, s, a, o) {
              switch (n.state) {
                case i.ACTIVE:
                case i.EMPTY:
                  break;
                case i.NOMATCH:
                  o.errors.push({
                    line: o.findLine(o.lines, e.prosValOpen),
                    char: e.prosValOpen,
                    msg: "Prose value operator(<...>) opened but not closed.",
                  }),
                    (e.basicError = !0),
                    (e.prosValOpen = null);
                  break;
                case i.MATCH:
                  o.errors.push({
                    line: o.findLine(o.lines, e.prosValOpen),
                    char: e.prosValOpen,
                    msg: "Prose value operator(<...>) found. The ABNF syntax is valid, but a parser cannot be generated from this grammar.",
                  }),
                    (e.prosValOpen = null);
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.prosvalopen = function (n, s, a) {
              switch (n.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  e.prosValOpen = a;
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.prosvalstring = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                  a.stringTabChar = !1;
                  break;
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  !1 !== a.stringTabChar &&
                    a.errors.push({
                      line: a.findLine(a.lines, a.stringTabChar),
                      char: a.stringTabChar,
                      msg: "Tab character (\\t, x09) not allowed in prose value string.",
                    });
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.repetition = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                  break;
                case i.NOMATCH:
                case i.MATCH:
                  a.repCount += 1;
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.rule = function (n, s, a, o) {
              switch (n.state) {
                case i.ACTIVE:
                  (o.altStack.length = 0),
                    (e = {
                      groupOpen: null,
                      groupError: !1,
                      optionOpen: null,
                      optionError: !1,
                      tlsOpen: null,
                      clsOpen: null,
                      prosValOpen: null,
                      basicError: !1,
                    }),
                    o.altStack.push(e);
                  break;
                case i.EMPTY:
                  throw Error(`${t}synRule: EMPTY: rule cannot be empty`);
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  o.ruleCount += 1;
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.ruleerror = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  a.errors.push({
                    line: a.findLine(a.lines, s, a.charsLength),
                    char: s,
                    msg: "Unrecognized SABNF line. Invalid rule, comment or blank line.",
                  });
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.rulenameerror = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  a.errors.push({
                    line: a.findLine(a.lines, s, a.charsLength),
                    char: s,
                    msg: "Rule names must be alphanum and begin with alphabetic character.",
                  });
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.stringtab = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  a.stringTabChar = s;
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.tlsclose = function (n, s, a, o) {
              switch (n.state) {
                case i.ACTIVE:
                case i.EMPTY:
                  break;
                case i.NOMATCH:
                  o.errors.push({
                    line: o.findLine(o.lines, e.tlsOpen),
                    char: e.tlsOpen,
                    msg: 'Case-insensitive literal string("...") opened but not closed.',
                  }),
                    (e.basicError = !0),
                    (e.tlsOpen = null);
                  break;
                case i.MATCH:
                  e.tlsOpen = null;
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.tlsopen = function (n, s, a) {
              switch (n.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  e.tlsOpen = a;
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.tlsstring = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                  a.stringTabChar = !1;
                  break;
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  !1 !== a.stringTabChar &&
                    a.errors.push({
                      line: a.findLine(a.lines, a.stringTabChar),
                      char: a.stringTabChar,
                      msg: "Tab character (\\t, x09) not allowed in literal string (see 'quoted-string' definition, RFC 7405.)",
                    });
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.udtop = function (e, n, a, o) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  if (o.strict) {
                    let t = s.utils.charsToString(n, a, e.phraseLength);
                    o.errors.push({
                      line: o.findLine(o.lines, a, o.charsLength),
                      char: a,
                      msg: `UDT operator found(${t}) - strict ABNF specified.`,
                    });
                  }
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.bkaop = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  a.strict
                    ? a.errors.push({
                        line: a.findLine(a.lines, s, a.charsLength),
                        char: s,
                        msg: "Positive look-behind operator(&&) found - strict ABNF specified.",
                      })
                    : a.lite &&
                      a.errors.push({
                        line: a.findLine(a.lines, s, a.charsLength),
                        char: s,
                        msg: "Positive look-behind operator(&&) found - apg-lite specified.",
                      });
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.bknop = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  a.strict
                    ? a.errors.push({
                        line: a.findLine(a.lines, s, a.charsLength),
                        char: s,
                        msg: "Negative look-behind operator(!!) found - strict ABNF specified.",
                      })
                    : a.lite &&
                      a.errors.push({
                        line: a.findLine(a.lines, s, a.charsLength),
                        char: s,
                        msg: "Negative look-behind operator(!!) found - apg-lite specified.",
                      });
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.bkrop = function (e, n, a, o) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  if (o.strict) {
                    let t = s.utils.charsToString(n, a, e.phraseLength);
                    o.errors.push({
                      line: o.findLine(o.lines, a, o.charsLength),
                      char: a,
                      msg: `Back reference operator(${t}) found - strict ABNF specified.`,
                    });
                  } else if (o.lite) {
                    let t = s.utils.charsToString(n, a, e.phraseLength);
                    o.errors.push({
                      line: o.findLine(o.lines, a, o.charsLength),
                      char: a,
                      msg: `Back reference operator(${t}) found - apg-lite specified.`,
                    });
                  }
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.abgop = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  a.strict
                    ? a.errors.push({
                        line: a.findLine(a.lines, s, a.charsLength),
                        char: s,
                        msg: "Beginning of string anchor(%^) found - strict ABNF specified.",
                      })
                    : a.lite &&
                      a.errors.push({
                        line: a.findLine(a.lines, s, a.charsLength),
                        char: s,
                        msg: "Beginning of string anchor(%^) found - apg-lite specified.",
                      });
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            }),
            (this.callbacks.aenop = function (e, n, s, a) {
              switch (e.state) {
                case i.ACTIVE:
                case i.EMPTY:
                case i.NOMATCH:
                  break;
                case i.MATCH:
                  a.strict
                    ? a.errors.push({
                        line: a.findLine(a.lines, s, a.charsLength),
                        char: s,
                        msg: "End of string anchor(%$) found - strict ABNF specified.",
                      })
                    : a.lite &&
                      a.errors.push({
                        line: a.findLine(a.lines, s, a.charsLength),
                        char: s,
                        msg: "End of string anchor(%$) found - apg-lite specified.",
                      });
                  break;
                default:
                  throw Error(`${t}synFile: unrecognized case.`);
              }
            });
        };
      },
      20979: function (e, t, n) {
        let { Buffer: s } = n(48764),
          i = n(46322),
          a = "UTF8",
          o = "UTF16",
          l = "UTF16BE",
          u = "UTF16LE",
          c = "UTF32",
          d = "UTF32BE",
          h = "UTF32LE",
          p = "UINT7",
          f = "ASCII",
          g = "BINARY",
          m = "UINT8",
          y = "UINT16",
          b = "UINT16LE",
          A = "UINT16BE",
          w = "UINT32",
          v = "UINT32LE",
          E = "UINT32BE",
          P = "ESCAPED",
          k = "STRING",
          T = function (e) {
            e.type = a;
            let t = e.data;
            (e.bom = 0),
              t.length >= 3 &&
                239 === t[0] &&
                187 === t[1] &&
                191 === t[2] &&
                (e.bom = 3);
          },
          x = function (e) {
            let t = e.data;
            switch (((e.bom = 0), e.type)) {
              case o:
                (e.type = l),
                  t.length >= 2 &&
                    (254 === t[0] && 255 === t[1]
                      ? (e.bom = 2)
                      : 255 === t[0] &&
                        254 === t[1] &&
                        ((e.type = u), (e.bom = 2)));
                break;
              case l:
                if (((e.type = l), t.length >= 2)) {
                  if (254 === t[0] && 255 === t[1]) e.bom = 2;
                  else if (255 === t[0] && 254 === t[1])
                    throw TypeError(
                      `src type: "${l}" specified but BOM is for "${u}"`
                    );
                }
                break;
              case u:
                if (((e.type = u), t.length >= 0)) {
                  if (254 === t[0] && 255 === t[1])
                    throw TypeError(
                      `src type: "${u}" specified but BOM is for "${l}"`
                    );
                  255 === t[0] && 254 === t[1] && (e.bom = 2);
                }
                break;
              default:
                throw TypeError(`UTF16 BOM: src type "${e.type}" unrecognized`);
            }
          },
          O = function (e) {
            let t = e.data;
            switch (((e.bom = 0), e.type)) {
              case c:
                (e.type = d),
                  t.length >= 4 &&
                    (0 === t[0] &&
                      0 === t[1] &&
                      254 === t[2] &&
                      255 === t[3] &&
                      (e.bom = 4),
                    255 === t[0] &&
                      254 === t[1] &&
                      0 === t[2] &&
                      0 === t[3] &&
                      ((e.type = h), (e.bom = 4)));
                break;
              case d:
                if (
                  ((e.type = d),
                  t.length >= 4 &&
                    (0 === t[0] &&
                      0 === t[1] &&
                      254 === t[2] &&
                      255 === t[3] &&
                      (e.bom = 4),
                    255 === t[0] && 254 === t[1] && 0 === t[2] && 0 === t[3]))
                )
                  throw TypeError(
                    `src type: ${d} specified but BOM is for ${h}"`
                  );
                break;
              case h:
                if (((e.type = h), t.length >= 4)) {
                  if (0 === t[0] && 0 === t[1] && 254 === t[2] && 255 === t[3])
                    throw TypeError(
                      `src type: "${h}" specified but BOM is for "${d}"`
                    );
                  255 === t[0] &&
                    254 === t[1] &&
                    0 === t[2] &&
                    0 === t[3] &&
                    (e.bom = 4);
                }
                break;
              default:
                throw TypeError(`UTF32 BOM: src type "${e.type}" unrecognized`);
            }
          },
          S = function (e, t) {
            let n = (function (e) {
              let t = { type: "", base64: !1 },
                n = /^(base64:)?([a-zA-Z0-9]+)$/i.exec(e);
              return (
                n &&
                  (n[2] && (t.type = n[2].toUpperCase()),
                  n[1] && (t.base64 = !0)),
                t
              );
            })(e.toUpperCase());
            if (n.base64) {
              if (n.type === k)
                throw TypeError(
                  `type: "${e} "BASE64:" prefix not allowed with type ${k}`
                );
              if (s.isBuffer(t)) n.data = i.base64.decode(t);
              else if ("string" == typeof t) {
                let e = s.from(t, "ascii");
                n.data = i.base64.decode(e);
              } else
                throw TypeError(
                  `type: "${e} unrecognized data type: typeof(data): ${typeof t}`
                );
            } else n.data = t;
            switch (n.type) {
              case a:
                T(n);
                break;
              case o:
              case l:
              case u:
                x(n);
                break;
              case c:
              case d:
              case h:
                O(n);
                break;
              case y:
                n.type = A;
                break;
              case w:
                n.type = E;
                break;
              case f:
                n.type = p;
                break;
              case g:
                n.type = m;
                break;
              case p:
              case m:
              case b:
              case A:
              case v:
              case E:
              case k:
              case P:
                break;
              default:
                throw TypeError(`type: "${e}" not recognized`);
            }
            if (n.type === k) {
              if ("string" != typeof n.data)
                throw TypeError(`type: "${e}" but data is not a string`);
            } else if (!s.isBuffer(n.data))
              throw TypeError(`type: "${e}" but data is not a Buffer`);
            return n;
          },
          C = function (e, t) {
            if (!Array.isArray(t))
              throw TypeError(`dst chars: not array: "${typeof t}`);
            if ("string" != typeof e)
              throw TypeError(`dst type: not string: "${typeof e}`);
            let n = (function (e) {
              let t, n;
              let s = { crlf: !1, lf: !1, base64: !1, type: "" };
              for (;;) {
                if (((n = e), "CRLF:" === (t = e.slice(0, 5)))) {
                  (s.crlf = !0), (n = e.slice(5));
                  break;
                }
                "LF:" === (t = e.slice(0, 3)) &&
                  ((s.lf = !0), (n = e.slice(3)));
                break;
              }
              return (
                1 === (t = n.split(":")).length
                  ? (s.type = t[0])
                  : 2 === t.length &&
                    "BASE64" === t[1] &&
                    ((s.base64 = !0), (s.type = t[0])),
                s
              );
            })(e.toUpperCase());
            switch (n.type) {
              case a:
              case l:
              case u:
              case d:
              case h:
              case p:
              case m:
              case b:
              case A:
              case v:
              case E:
              case P:
                break;
              case k:
                if (n.base64)
                  throw TypeError(
                    `":BASE64" suffix not allowed with type ${k}`
                  );
                break;
              case f:
                n.type = p;
                break;
              case g:
                n.type = m;
                break;
              case o:
                n.type = l;
                break;
              case c:
                n.type = d;
                break;
              case y:
                n.type = A;
                break;
              case w:
                n.type = E;
                break;
              default:
                throw TypeError(
                  `dst type unrecognized: "${e}" : must have form [crlf:|lf:]type[:base64]`
                );
            }
            return n;
          },
          B = function (e, t) {
            switch (e) {
              case a:
                return i.utf8.encode(t);
              case l:
                return i.utf16be.encode(t);
              case u:
                return i.utf16le.encode(t);
              case d:
                return i.utf32be.encode(t);
              case h:
                return i.utf32le.encode(t);
              case p:
                return i.uint7.encode(t);
              case m:
                return i.uint8.encode(t);
              case A:
                return i.uint16be.encode(t);
              case b:
                return i.uint16le.encode(t);
              case E:
                return i.uint32be.encode(t);
              case v:
                return i.uint32le.encode(t);
              case k:
                return i.string.encode(t);
              case P:
                return i.escaped.encode(t);
              default:
                throw TypeError(`encode type "${e}" not recognized`);
            }
          },
          N = function (e) {
            switch (e.type) {
              case a:
                return i.utf8.decode(e.data, e.bom);
              case u:
                return i.utf16le.decode(e.data, e.bom);
              case l:
                return i.utf16be.decode(e.data, e.bom);
              case d:
                return i.utf32be.decode(e.data, e.bom);
              case h:
                return i.utf32le.decode(e.data, e.bom);
              case p:
                return i.uint7.decode(e.data);
              case m:
                return i.uint8.decode(e.data);
              case A:
                return i.uint16be.decode(e.data);
              case b:
                return i.uint16le.decode(e.data);
              case E:
                return i.uint32be.decode(e.data);
              case v:
                return i.uint32le.decode(e.data);
              case k:
                return i.string.decode(e.data);
              case P:
                return i.escaped.decode(e.data);
              default:
                throw TypeError(`decode type "${e.type}" not recognized`);
            }
          };
        (t.decode = function (e, t) {
          return N(S(e, t));
        }),
          (t.encode = function (e, t) {
            let n, s;
            let a = C(e, t);
            return (
              a.crlf
                ? ((n = i.lineEnds.crlf(t)), (s = B(a.type, n)))
                : a.lf
                ? ((n = i.lineEnds.lf(t)), (s = B(a.type, n)))
                : (s = B(a.type, t)),
              a.base64 && (s = i.base64.encode(s)),
              s
            );
          }),
          (t.convert = function (e, n, s) {
            return t.encode(s, t.decode(e, n));
          });
      },
      46322: function (e, t, n) {
        let { Buffer: s } = n(48764),
          i = [
            "00",
            "01",
            "02",
            "03",
            "04",
            "05",
            "06",
            "07",
            "08",
            "09",
            "0A",
            "0B",
            "0C",
            "0D",
            "0E",
            "0F",
            "10",
            "11",
            "12",
            "13",
            "14",
            "15",
            "16",
            "17",
            "18",
            "19",
            "1A",
            "1B",
            "1C",
            "1D",
            "1E",
            "1F",
            "20",
            "21",
            "22",
            "23",
            "24",
            "25",
            "26",
            "27",
            "28",
            "29",
            "2A",
            "2B",
            "2C",
            "2D",
            "2E",
            "2F",
            "30",
            "31",
            "32",
            "33",
            "34",
            "35",
            "36",
            "37",
            "38",
            "39",
            "3A",
            "3B",
            "3C",
            "3D",
            "3E",
            "3F",
            "40",
            "41",
            "42",
            "43",
            "44",
            "45",
            "46",
            "47",
            "48",
            "49",
            "4A",
            "4B",
            "4C",
            "4D",
            "4E",
            "4F",
            "50",
            "51",
            "52",
            "53",
            "54",
            "55",
            "56",
            "57",
            "58",
            "59",
            "5A",
            "5B",
            "5C",
            "5D",
            "5E",
            "5F",
            "60",
            "61",
            "62",
            "63",
            "64",
            "65",
            "66",
            "67",
            "68",
            "69",
            "6A",
            "6B",
            "6C",
            "6D",
            "6E",
            "6F",
            "70",
            "71",
            "72",
            "73",
            "74",
            "75",
            "76",
            "77",
            "78",
            "79",
            "7A",
            "7B",
            "7C",
            "7D",
            "7E",
            "7F",
            "80",
            "81",
            "82",
            "83",
            "84",
            "85",
            "86",
            "87",
            "88",
            "89",
            "8A",
            "8B",
            "8C",
            "8D",
            "8E",
            "8F",
            "90",
            "91",
            "92",
            "93",
            "94",
            "95",
            "96",
            "97",
            "98",
            "99",
            "9A",
            "9B",
            "9C",
            "9D",
            "9E",
            "9F",
            "A0",
            "A1",
            "A2",
            "A3",
            "A4",
            "A5",
            "A6",
            "A7",
            "A8",
            "A9",
            "AA",
            "AB",
            "AC",
            "AD",
            "AE",
            "AF",
            "B0",
            "B1",
            "B2",
            "B3",
            "B4",
            "B5",
            "B6",
            "B7",
            "B8",
            "B9",
            "BA",
            "BB",
            "BC",
            "BD",
            "BE",
            "BF",
            "C0",
            "C1",
            "C2",
            "C3",
            "C4",
            "C5",
            "C6",
            "C7",
            "C8",
            "C9",
            "CA",
            "CB",
            "CC",
            "CD",
            "CE",
            "CF",
            "D0",
            "D1",
            "D2",
            "D3",
            "D4",
            "D5",
            "D6",
            "D7",
            "D8",
            "D9",
            "DA",
            "DB",
            "DC",
            "DD",
            "DE",
            "DF",
            "E0",
            "E1",
            "E2",
            "E3",
            "E4",
            "E5",
            "E6",
            "E7",
            "E8",
            "E9",
            "EA",
            "EB",
            "EC",
            "ED",
            "EE",
            "EF",
            "F0",
            "F1",
            "F2",
            "F3",
            "F4",
            "F5",
            "F6",
            "F7",
            "F8",
            "F9",
            "FA",
            "FB",
            "FC",
            "FD",
            "FE",
            "FF",
          ],
          a = [];
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
          .split("")
          .forEach((e) => {
            a.push(e.charCodeAt(0));
          }),
          (t.utf8 = {
            encode(e) {
              let t = [];
              return (
                e.forEach((e) => {
                  if (e >= 0 && e <= 127) t.push(e);
                  else if (e <= 2047)
                    t.push(192 + ((e >> 6) & 31)), t.push(128 + (63 & e));
                  else if (e < 55296 || (e > 57343 && e <= 65535))
                    t.push(224 + ((e >> 12) & 15)),
                      t.push(128 + ((e >> 6) & 63)),
                      t.push(128 + (63 & e));
                  else if (e >= 65536 && e <= 1114111) {
                    let n = (e >> 16) & 31;
                    t.push(240 + (n >> 2)),
                      t.push(128 + ((3 & n) << 4) + ((e >> 12) & 15)),
                      t.push(128 + ((e >> 6) & 63)),
                      t.push(128 + (63 & e));
                  } else
                    throw RangeError(
                      `utf8.encode: character out of range: char: ${e}`
                    );
                }),
                s.from(t)
              );
            },
            decode(e, t) {
              let n, s, i, a, o, l;
              let u = e.length,
                c = t ? 3 : 0,
                d = [];
              for (; c < u; ) {
                for (s = e[c], n = 4294967295; ; ) {
                  if (s >= 0 && s <= 127) {
                    (n = s), (l = 1);
                    break;
                  }
                  if ((i = c + 1) < u && s >= 194 && s <= 223) {
                    (n = (function (e, t) {
                      if ((192 & t) != 128) return 4294967293;
                      let n = ((31 & e) << 6) + (63 & t);
                      return n < 128 ? 4294967292 : n;
                    })(s, e[i])),
                      (l = 2);
                    break;
                  }
                  if ((a = c + 2) < u && s >= 224 && s <= 239) {
                    (n = (function (e, t, n) {
                      if ((192 & n) != 128 || (192 & t) != 128)
                        return 4294967293;
                      let s = ((15 & e) << 12) + ((63 & t) << 6) + (63 & n);
                      return s < 2048
                        ? 4294967292
                        : s >= 55296 && s <= 57343
                        ? 4294967294
                        : s;
                    })(s, e[i], e[a])),
                      (l = 3);
                    break;
                  }
                  (o = c + 3) < u &&
                    s >= 240 &&
                    s <= 244 &&
                    ((n = (function (e, t, n, s) {
                      if (
                        (192 & s) != 128 ||
                        (192 & n) != 128 ||
                        (192 & t) != 128
                      )
                        return 4294967293;
                      let i =
                        ((((7 & e) << 2) + ((t >> 4) & 3)) << 16) +
                        ((15 & t) << 12) +
                        ((63 & n) << 6) +
                        (63 & s);
                      return i < 65536
                        ? 4294967292
                        : i > 1114111
                        ? 4294967294
                        : i;
                    })(s, e[i], e[a], e[o])),
                    (l = 4));
                  break;
                }
                if (n > 1114111) {
                  let e = `byte[${c}]`;
                  if (4294967295 === n)
                    throw RangeError(
                      `utf8.decode: ill-formed UTF8 byte sequence found at: ${e}`
                    );
                  if (4294967293 === n)
                    throw RangeError(
                      `utf8.decode: illegal trailing byte found at: ${e}`
                    );
                  if (4294967294 === n)
                    throw RangeError(
                      `utf8.decode: code point out of range found at: ${e}`
                    );
                  if (4294967292 === n)
                    throw RangeError(
                      `utf8.decode: non-shortest form found at: ${e}`
                    );
                  throw RangeError(
                    `utf8.decode: unrecognized error found at: ${e}`
                  );
                }
                d.push(n), (c += l);
              }
              return d;
            },
          }),
          (t.utf16be = {
            encode(e) {
              let t, n, i;
              let a = [];
              for (let s = 0; s < e.length; s += 1)
                if (
                  ((t = e[s]) >= 0 && t <= 55295) ||
                  (t >= 57344 && t <= 65535)
                )
                  a.push((t >> 8) & 255), a.push(255 & t);
                else if (t >= 65536 && t <= 1114111)
                  (n = 55296 + ((i = t - 65536) >> 10)),
                    (i = 56320 + (1023 & i)),
                    a.push((n >> 8) & 255),
                    a.push(255 & n),
                    a.push((i >> 8) & 255),
                    a.push(255 & i);
                else
                  throw RangeError(
                    `utf16be.encode: UTF16BE value out of range: char[${s}]: ${t}`
                  );
              return s.from(a);
            },
            decode(e, t) {
              let n, s, i, a, o, l;
              if (e.length % 2 > 0)
                throw RangeError(
                  `utf16be.decode: data length must be even multiple of 2: length: ${e.length}`
                );
              let u = [],
                c = e.length,
                d = t ? 2 : 0,
                h = 0;
              for (; d < c; ) {
                for (;;) {
                  if ((i = d + 1) < c) {
                    if ((o = (e[d] << 8) + e[i]) < 55296 || o > 57343) {
                      (n = o), (s = 2);
                      break;
                    }
                    if (
                      (a = d + 3) < c &&
                      ((l = (e[d + 2] << 8) + e[a]),
                      o <= 56319 && l >= 56320 && l <= 57343)
                    ) {
                      (n = 65536 + ((o - 55296) << 10) + (l - 56320)), (s = 4);
                      break;
                    }
                  }
                  throw RangeError(
                    `utf16be.decode: ill-formed UTF16BE byte sequence found: byte[${d}]`
                  );
                }
                (u[h++] = n), (d += s);
              }
              return u;
            },
          }),
          (t.utf16le = {
            encode(e) {
              let t, n, i;
              let a = [];
              for (let s = 0; s < e.length; s += 1)
                if (
                  ((t = e[s]) >= 0 && t <= 55295) ||
                  (t >= 57344 && t <= 65535)
                )
                  a.push(255 & t), a.push((t >> 8) & 255);
                else if (t >= 65536 && t <= 1114111)
                  (n = 55296 + ((i = t - 65536) >> 10)),
                    (i = 56320 + (1023 & i)),
                    a.push(255 & n),
                    a.push((n >> 8) & 255),
                    a.push(255 & i),
                    a.push((i >> 8) & 255);
                else
                  throw RangeError(
                    `utf16le.encode: UTF16LE value out of range: char[${s}]: ${t}`
                  );
              return s.from(a);
            },
            decode(e, t) {
              let n, s, i, a, o, l;
              if (e.length % 2 > 0)
                throw RangeError(
                  `utf16le.decode: data length must be even multiple of 2: length: ${e.length}`
                );
              let u = [],
                c = e.length,
                d = t ? 2 : 0,
                h = 0;
              for (; d < c; ) {
                for (;;) {
                  if ((i = d + 1) < c) {
                    if ((o = (e[i] << 8) + e[d]) < 55296 || o > 57343) {
                      (n = o), (s = 2);
                      break;
                    }
                    if (
                      (a = d + 3) < c &&
                      ((l = (e[a] << 8) + e[d + 2]),
                      o <= 56319 && l >= 56320 && l <= 57343)
                    ) {
                      (n = 65536 + ((o - 55296) << 10) + (l - 56320)), (s = 4);
                      break;
                    }
                  }
                  throw RangeError(
                    `utf16le.decode: ill-formed UTF16LE byte sequence found: byte[${d}]`
                  );
                }
                (u[h++] = n), (d += s);
              }
              return u;
            },
          }),
          (t.utf32be = {
            encode(e) {
              let t = s.alloc(4 * e.length),
                n = 0;
              return (
                e.forEach((e) => {
                  if ((e >= 55296 && e <= 57343) || e > 1114111)
                    throw RangeError(
                      `utf32be.encode: UTF32BE character code out of range: char[${
                        n / 4
                      }]: ${e}`
                    );
                  (t[n++] = (e >> 24) & 255),
                    (t[n++] = (e >> 16) & 255),
                    (t[n++] = (e >> 8) & 255),
                    (t[n++] = 255 & e);
                }),
                t
              );
            },
            decode(e, t) {
              if (e.length % 4 > 0)
                throw RangeError(
                  `utf32be.decode: UTF32BE byte length must be even multiple of 4: length: ${e.length}`
                );
              let n = [],
                s = t ? 4 : 0;
              for (; s < e.length; s += 4) {
                let t =
                  (e[s] << 24) + (e[s + 1] << 16) + (e[s + 2] << 8) + e[s + 3];
                if ((t >= 55296 && t <= 57343) || t > 1114111)
                  throw RangeError(
                    `utf32be.decode: UTF32BE character code out of range: char[${
                      s / 4
                    }]: ${t}`
                  );
                n.push(t);
              }
              return n;
            },
          }),
          (t.utf32le = {
            encode(e) {
              let t = s.alloc(4 * e.length),
                n = 0;
              return (
                e.forEach((e) => {
                  if ((e >= 55296 && e <= 57343) || e > 1114111)
                    throw RangeError(
                      `utf32le.encode: UTF32LE character code out of range: char[${
                        n / 4
                      }]: ${e}`
                    );
                  (t[n++] = 255 & e),
                    (t[n++] = (e >> 8) & 255),
                    (t[n++] = (e >> 16) & 255),
                    (t[n++] = (e >> 24) & 255);
                }),
                t
              );
            },
            decode(e, t) {
              if (e.length % 4 > 0)
                throw RangeError(
                  `utf32be.decode: UTF32LE byte length must be even multiple of 4: length: ${e.length}`
                );
              let n = [],
                s = t ? 4 : 0;
              for (; s < e.length; s += 4) {
                let t =
                  (e[s + 3] << 24) + (e[s + 2] << 16) + (e[s + 1] << 8) + e[s];
                if ((t >= 55296 && t <= 57343) || t > 1114111)
                  throw RangeError(
                    `utf32le.encode: UTF32LE character code out of range: char[${
                      s / 4
                    }]: ${t}`
                  );
                n.push(t);
              }
              return n;
            },
          }),
          (t.uint7 = {
            encode(e) {
              let t = s.alloc(e.length);
              for (let n = 0; n < e.length; n += 1) {
                if (e[n] > 127)
                  throw RangeError(
                    `uint7.encode: UINT7 character code out of range: char[${n}]: ${e[n]}`
                  );
                t[n] = e[n];
              }
              return t;
            },
            decode(e) {
              let t = [];
              for (let n = 0; n < e.length; n += 1) {
                if (e[n] > 127)
                  throw RangeError(
                    `uint7.decode: UINT7 character code out of range: byte[${n}]: ${e[n]}`
                  );
                t[n] = e[n];
              }
              return t;
            },
          }),
          (t.uint8 = {
            encode(e) {
              let t = s.alloc(e.length);
              for (let n = 0; n < e.length; n += 1) {
                if (e[n] > 255)
                  throw RangeError(
                    `uint8.encode: UINT8 character code out of range: char[${n}]: ${e[n]}`
                  );
                t[n] = e[n];
              }
              return t;
            },
            decode(e) {
              let t = [];
              for (let n = 0; n < e.length; n += 1) t[n] = e[n];
              return t;
            },
          }),
          (t.uint16be = {
            encode(e) {
              let t = s.alloc(2 * e.length),
                n = 0;
              return (
                e.forEach((e) => {
                  if (e > 65535)
                    throw RangeError(
                      `uint16be.encode: UINT16BE character code out of range: char[${
                        n / 2
                      }]: ${e}`
                    );
                  (t[n++] = (e >> 8) & 255), (t[n++] = 255 & e);
                }),
                t
              );
            },
            decode(e) {
              if (e.length % 2 > 0)
                throw RangeError(
                  `uint16be.decode: UINT16BE byte length must be even multiple of 2: length: ${e.length}`
                );
              let t = [];
              for (let n = 0; n < e.length; n += 2)
                t.push((e[n] << 8) + e[n + 1]);
              return t;
            },
          }),
          (t.uint16le = {
            encode(e) {
              let t = s.alloc(2 * e.length),
                n = 0;
              return (
                e.forEach((e) => {
                  if (e > 65535)
                    throw RangeError(
                      `uint16le.encode: UINT16LE character code out of range: char[${
                        n / 2
                      }]: ${e}`
                    );
                  (t[n++] = 255 & e), (t[n++] = (e >> 8) & 255);
                }),
                t
              );
            },
            decode(e) {
              if (e.length % 2 > 0)
                throw RangeError(
                  `uint16le.decode: UINT16LE byte length must be even multiple of 2: length: ${e.length}`
                );
              let t = [];
              for (let n = 0; n < e.length; n += 2)
                t.push((e[n + 1] << 8) + e[n]);
              return t;
            },
          }),
          (t.uint32be = {
            encode(e) {
              let t = s.alloc(4 * e.length),
                n = 0;
              return (
                e.forEach((e) => {
                  (t[n++] = (e >> 24) & 255),
                    (t[n++] = (e >> 16) & 255),
                    (t[n++] = (e >> 8) & 255),
                    (t[n++] = 255 & e);
                }),
                t
              );
            },
            decode(e) {
              if (e.length % 4 > 0)
                throw RangeError(
                  `uint32be.decode: UINT32BE byte length must be even multiple of 4: length: ${e.length}`
                );
              let t = [];
              for (let n = 0; n < e.length; n += 4)
                t.push(
                  (e[n] << 24) + (e[n + 1] << 16) + (e[n + 2] << 8) + e[n + 3]
                );
              return t;
            },
          }),
          (t.uint32le = {
            encode(e) {
              let t = s.alloc(4 * e.length),
                n = 0;
              return (
                e.forEach((e) => {
                  (t[n++] = 255 & e),
                    (t[n++] = (e >> 8) & 255),
                    (t[n++] = (e >> 16) & 255),
                    (t[n++] = (e >> 24) & 255);
                }),
                t
              );
            },
            decode(e) {
              if (e.length % 4 > 0)
                throw RangeError(
                  `uint32le.decode: UINT32LE byte length must be even multiple of 4: length: ${e.length}`
                );
              let t = [];
              for (let n = 0; n < e.length; n += 4)
                t.push(
                  (e[n + 3] << 24) + (e[n + 2] << 16) + (e[n + 1] << 8) + e[n]
                );
              return t;
            },
          }),
          (t.string = {
            encode: (e) => t.utf16le.encode(e).toString("utf16le"),
            decode: (e) => t.utf16le.decode(s.from(e, "utf16le"), 0),
          }),
          (t.escaped = {
            encode(e) {
              let t = [];
              for (let n = 0; n < e.length; n += 1) {
                let a = e[n];
                if (96 === a) t.push(a), t.push(a);
                else if (10 === a) t.push(a);
                else if (a >= 32 && a <= 126) t.push(a);
                else {
                  let e = "";
                  if (a >= 0 && a <= 31) e += `\`x${i[a]}`;
                  else if (a >= 127 && a <= 255) e += `\`x${i[a]}`;
                  else if (a >= 256 && a <= 65535)
                    e += `\`u${i[(a >> 8) & 255]}${i[255 & a]}`;
                  else if (a >= 65536 && a <= 4294967295) {
                    e += "`u{";
                    let t = (a >> 24) & 255;
                    t > 0 && (e += i[t]),
                      (e += `${
                        i[(a >> 16) & 255] + i[(a >> 8) & 255] + i[255 & a]
                      }}`);
                  } else
                    throw Error(
                      "escape.encode(char): char > 0xffffffff not allowed"
                    );
                  s.from(e).forEach((e) => {
                    t.push(e);
                  });
                }
              }
              return s.from(t);
            },
            decode(e) {
              let t, n, s;
              function i(e) {
                return (
                  (e >= 48 && e <= 57) ||
                  (e >= 65 && e <= 70) ||
                  (e >= 97 && e <= 102)
                );
              }
              let a = [],
                o = e.length,
                l = 0;
              for (; l < o; ) {
                for (;;) {
                  if (((s = !0), 96 !== e[l])) {
                    a.push(e[l]), (l += 1), (s = !1);
                    break;
                  }
                  if ((t = l + 1) >= o) break;
                  if (96 === e[t]) {
                    a.push(96), (l += 2), (s = !1);
                    break;
                  }
                  if (120 === e[t]) {
                    if (
                      (n = (function (e, t, n) {
                        let s = { char: null, nexti: e + 2, error: !0 };
                        if (e + 1 < t && i(n[e]) && i(n[e + 1])) {
                          let t = String.fromCodePoint(n[e], n[e + 1]);
                          (s.char = parseInt(t, 16)),
                            Number.isNaN(s.char) || (s.error = !1);
                        }
                        return s;
                      })(t + 1, o, e)).error
                    )
                      break;
                    a.push(n.char), (l = n.nexti), (s = !1);
                    break;
                  }
                  if (117 === e[t]) {
                    if (123 === e[t + 1]) {
                      if (
                        (n = (function (e, t, n) {
                          let s = { char: null, nexti: e + 4, error: !0 },
                            a = "";
                          for (; e < t && i(n[e]); )
                            (a += String.fromCodePoint(n[e])), (e += 1);
                          return (
                            (s.char = parseInt(a, 16)),
                            125 !== n[e] ||
                              Number.isNaN(s.char) ||
                              (s.error = !1),
                            (s.nexti = e + 1),
                            s
                          );
                        })(t + 2, o, e)).error
                      )
                        break;
                      a.push(n.char), (l = n.nexti), (s = !1);
                      break;
                    }
                    if (
                      (n = (function (e, t, n) {
                        let s = { char: null, nexti: e + 4, error: !0 };
                        if (
                          e + 3 < t &&
                          i(n[e]) &&
                          i(n[e + 1]) &&
                          i(n[e + 2]) &&
                          i(n[e + 3])
                        ) {
                          let t = String.fromCodePoint(
                            n[e],
                            n[e + 1],
                            n[e + 2],
                            n[e + 3]
                          );
                          (s.char = parseInt(t, 16)),
                            Number.isNaN(s.char) || (s.error = !1);
                        }
                        return s;
                      })(t + 1, o, e)).error
                    )
                      break;
                    a.push(n.char), (l = n.nexti), (s = !1);
                  }
                  break;
                }
                if (s)
                  throw Error(
                    `escaped.decode: ill-formed escape sequence at buf[${l}]`
                  );
              }
              return a;
            },
          }),
          (t.lineEnds = {
            crlf(e) {
              let t = [],
                n = 0;
              for (; n < e.length; )
                switch (e[n]) {
                  case 13:
                    n + 1 < e.length && 10 === e[n + 1] ? (n += 2) : (n += 1),
                      t.push(13),
                      t.push(10);
                    break;
                  case 10:
                    t.push(13), t.push(10), (n += 1);
                    break;
                  default:
                    t.push(e[n]), (n += 1);
                }
              return (
                t.length > 0 &&
                  10 !== t[t.length - 1] &&
                  (t.push(13), t.push(10)),
                t
              );
            },
            lf(e) {
              let t = [],
                n = 0;
              for (; n < e.length; )
                switch (e[n]) {
                  case 13:
                    n + 1 < e.length && 10 === e[n + 1] ? (n += 2) : (n += 1),
                      t.push(10);
                    break;
                  case 10:
                    t.push(10), (n += 1);
                    break;
                  default:
                    t.push(e[n]), (n += 1);
                }
              return t.length > 0 && 10 !== t[t.length - 1] && t.push(10), t;
            },
          }),
          (t.base64 = {
            encode(e) {
              let t, n, i;
              if (0 === e.length) return s.alloc(0);
              let o = e.length % 3;
              o = o > 0 ? 3 - o : 0;
              let l = (e.length + o) / 3,
                u = s.alloc(4 * l);
              o > 0 && (l -= 1), (t = 0), (n = 0);
              for (let s = 0; s < l; s += 1)
                (i = (e[t++] << 16) + (e[t++] << 8) + e[t++]),
                  (u[n++] = a[(i >> 18) & 63]),
                  (u[n++] = a[(i >> 12) & 63]),
                  (u[n++] = a[(i >> 6) & 63]),
                  (u[n++] = a[63 & i]);
              return 0 === o
                ? u
                : 1 === o
                ? ((i = (e[t++] << 16) + (e[t] << 8)),
                  (u[n++] = a[(i >> 18) & 63]),
                  (u[n++] = a[(i >> 12) & 63]),
                  (u[n++] = a[(i >> 6) & 63]),
                  (u[n] = a[64]),
                  u)
                : 2 === o
                ? ((i = e[t] << 16),
                  (u[n++] = a[(i >> 18) & 63]),
                  (u[n++] = a[(i >> 12) & 63]),
                  (u[n++] = a[64]),
                  (u[n] = a[64]),
                  u)
                : void 0;
            },
            decode(e) {
              let t, n, i;
              if (0 === e.length) return s.alloc(0);
              let a = (function (e) {
                  let t = [],
                    n = 0;
                  for (let s = 0; s < e.length; s += 1) {
                    let i = e[s];
                    for (; 32 !== i && 9 !== i && 10 !== i && 13 !== i; ) {
                      if (i >= 65 && i <= 90) {
                        t.push(i - 65);
                        break;
                      }
                      if (i >= 97 && i <= 122) {
                        t.push(i - 71);
                        break;
                      }
                      if (i >= 48 && i <= 57) {
                        t.push(i + 4);
                        break;
                      }
                      if (43 === i) {
                        t.push(62);
                        break;
                      }
                      if (47 === i) {
                        t.push(63);
                        break;
                      }
                      if (61 === i) {
                        t.push(64), (n += 1);
                        break;
                      }
                      throw RangeError(
                        `base64.decode: invalid character buf[${s}]: ${i}`
                      );
                    }
                  }
                  if (t.length % 4 > 0)
                    throw RangeError(
                      `base64.decode: string length not integral multiple of 4: ${t.length}`
                    );
                  switch (n) {
                    case 0:
                      break;
                    case 1:
                      if (64 !== t[t.length - 1])
                        throw RangeError(
                          "base64.decode: one tail character found: not last character"
                        );
                      break;
                    case 2:
                      if (64 !== t[t.length - 1] || 64 !== t[t.length - 2])
                        throw RangeError(
                          "base64.decode: two tail characters found: not last characters"
                        );
                      break;
                    default:
                      throw RangeError(
                        `base64.decode: more than two tail characters found: ${n}`
                      );
                  }
                  return { tail: n, buf: s.from(t) };
                })(e),
                { tail: o } = a,
                l = a.buf,
                u = l.length / 4,
                c = s.alloc(3 * u - o);
              o > 0 && (u -= 1), (n = 0), (t = 0);
              for (let e = 0; e < u; e += 1)
                (i = (l[t++] << 18) + (l[t++] << 12) + (l[t++] << 6) + l[t++]),
                  (c[n++] = (i >> 16) & 255),
                  (c[n++] = (i >> 8) & 255),
                  (c[n++] = 255 & i);
              return (
                1 === o &&
                  ((i = (l[t++] << 18) + (l[t++] << 12) + (l[t] << 6)),
                  (c[n++] = (i >> 16) & 255),
                  (c[n] = (i >> 8) & 255)),
                2 === o &&
                  ((i = (l[t++] << 18) + (l[t++] << 12)),
                  (c[n] = (i >> 16) & 255)),
                c
              );
            },
            toString(e) {
              if (e.length % 4 > 0)
                throw RangeError(
                  `base64.toString: input buffer length not multiple of 4: ${e.length}`
                );
              let t = "",
                n = 0;
              for (let i = 0; i < e.length; i += 4) {
                for (let t = i; t < i + 4; t += 1) {
                  var s;
                  if (
                    !(
                      ((s = e[t]) >= 65 && s <= 90) ||
                      (s >= 97 && s <= 122) ||
                      (s >= 48 && s <= 57) ||
                      43 === s ||
                      47 === s ||
                      61 === s
                    )
                  )
                    throw RangeError(
                      `base64.toString: buf[${t}]: ${e[t]} : not valid base64 character code`
                    );
                }
                !(function (e, s, i, a) {
                  switch (n) {
                    case 76:
                      (t += `\r
${e}${s}${i}${a}`),
                        (n = 4);
                      break;
                    case 75:
                      (t += `${e}\r
${s}${i}${a}`),
                        (n = 3);
                      break;
                    case 74:
                      (t += `${e + s}\r
${i}${a}`),
                        (n = 2);
                      break;
                    case 73:
                      (t += `${e + s + i}\r
${a}`),
                        (n = 1);
                      break;
                    default:
                      (t += e + s + i + a), (n += 4);
                  }
                })(
                  String.fromCharCode(e[i]),
                  String.fromCharCode(e[i + 1]),
                  String.fromCharCode(e[i + 2]),
                  String.fromCharCode(e[i + 3])
                );
              }
              return t;
            },
          });
      },
      90580: function (e, t, n) {
        e.exports = function () {
          let e = n(58276),
            t = n(8544),
            s = this,
            i = null,
            a = null,
            o = null,
            l = 0,
            u = [],
            c = [],
            d = [],
            h = [];
          function p(e) {
            let t = "";
            for (let n = 0; n < e; n += 1) t += " ";
            return t;
          }
          (this.callbacks = []),
            (this.astObject = "astObject"),
            (this.init = function (e, t, n) {
              let p;
              (d.length = 0),
                (h.length = 0),
                (u.length = 0),
                (l = 0),
                (i = e),
                (a = t),
                (o = n);
              let f = [];
              for (p = 0; p < i.length; p += 1) f.push(i[p].lower);
              for (p = 0; p < a.length; p += 1) f.push(a[p].lower);
              for (p = 0, l = i.length + a.length; p < l; p += 1)
                (u[p] = !1), (c[p] = null);
              for (let e in s.callbacks) {
                let t = e.toLowerCase();
                if ((p = f.indexOf(t)) < 0)
                  throw Error(
                    `ast.js: init: node '${e}' not a rule or udt name`
                  );
                "function" == typeof s.callbacks[e] &&
                  ((u[p] = !0), (c[p] = s.callbacks[e])),
                  !0 === s.callbacks[e] && (u[p] = !0);
              }
            }),
            (this.ruleDefined = function (e) {
              return !1 !== u[e];
            }),
            (this.udtDefined = function (e) {
              return !1 !== u[i.length + e];
            }),
            (this.down = function (t, n) {
              let s = h.length;
              return (
                d.push(s),
                h.push({
                  name: n,
                  thisIndex: s,
                  thatIndex: null,
                  state: e.SEM_PRE,
                  callbackIndex: t,
                  phraseIndex: null,
                  phraseLength: null,
                  stack: d.length,
                }),
                s
              );
            }),
            (this.up = function (t, n, s, i) {
              let a = h.length,
                o = d.pop();
              return (
                h.push({
                  name: n,
                  thisIndex: a,
                  thatIndex: o,
                  state: e.SEM_POST,
                  callbackIndex: t,
                  phraseIndex: s,
                  phraseLength: i,
                  stack: d.length,
                }),
                (h[o].thatIndex = a),
                (h[o].phraseIndex = s),
                (h[o].phraseLength = i),
                a
              );
            }),
            (this.translate = function (t) {
              let n, s;
              for (let i = 0; i < h.length; i += 1)
                (n = c[(s = h[i]).callbackIndex]),
                  s.state === e.SEM_PRE
                    ? null !== n &&
                      n(e.SEM_PRE, o, s.phraseIndex, s.phraseLength, t) ===
                        e.SEM_SKIP &&
                      (i = s.thatIndex)
                    : null !== n &&
                      n(e.SEM_POST, o, s.phraseIndex, s.phraseLength, t);
            }),
            (this.setLength = function (e) {
              (h.length = e),
                e > 0 ? (d.length = h[e - 1].stack) : (d.length = 0);
            }),
            (this.getLength = function () {
              return h.length;
            }),
            (this.toXml = function (n) {
              let s = t.charsToDec,
                i = "decimal integer character codes";
              if ("string" == typeof n && n.length >= 3) {
                let e = n.slice(0, 3).toLowerCase();
                "asc" === e
                  ? ((s = t.charsToAscii),
                    (i = "ASCII for printing characters, hex for non-printing"))
                  : "hex" === e
                  ? ((s = t.charsToHex),
                    (i = "hexadecimal integer character codes"))
                  : "uni" === e &&
                    ((s = t.charsToUnicode),
                    (i = "Unicode UTF-32 integer character codes"));
              }
              let a = "",
                l = 0;
              return (
                (a +=
                  `<?xml version="1.0" encoding="utf-8"?>
<root nodes="${h.length / 2}" characters="${o.length}">
<!-- input string, ${i} -->
` +
                  p(l + 2) +
                  s(o) +
                  "\n"),
                h.forEach((t) => {
                  t.state === e.SEM_PRE
                    ? ((l += 1),
                      (a +=
                        p(l) +
                        `<node name="${t.name}" index="${t.phraseIndex}" length="${t.phraseLength}">
` +
                        p(l + 2) +
                        s(o, t.phraseIndex, t.phraseLength) +
                        "\n"))
                    : ((a +=
                        p(l) +
                        `</node><!-- name="${t.name}" -->
`),
                      (l -= 1));
                }),
                (a += "</root>\n")
              );
            }),
            (this.phrases = function () {
              let t, n;
              let s = {};
              for (t = 0; t < h.length; t += 1)
                (n = h[t]).state === e.SEM_PRE &&
                  (Array.isArray(s[n.name]) || (s[n.name] = []),
                  s[n.name].push({
                    index: n.phraseIndex,
                    length: n.phraseLength,
                  }));
              return s;
            });
        };
      },
      42761: function (e) {
        e.exports = function () {
          let e = -1,
            t = 0;
          (this.init = function (n) {
            if ("number" != typeof n || n <= 0)
              throw Error(
                "circular-buffer.js: init: circular buffer size must an integer > 0"
              );
            (t = Math.ceil(n)), (e = -1);
          }),
            (this.increment = function () {
              return ((e += 1) + t) % t;
            }),
            (this.maxSize = function () {
              return t;
            }),
            (this.items = function () {
              return e + 1;
            }),
            (this.getListIndex = function (n) {
              return -1 === e || n < 0 || n > e || e - n >= t
                ? -1
                : (n + t) % t;
            }),
            (this.forEach = function (n) {
              if (-1 !== e) {
                if (e < t) {
                  for (let t = 0; t <= e; t += 1) n(t, t);
                  return;
                }
                for (let s = e - t + 1; s <= e; s += 1) n((s + t) % t, s);
              }
            });
        };
      },
      91593: function (e) {
        e.exports = function () {
          return "/* This file automatically generated by jsonToless() and LESS. */\n.apg-mono {\n  font-family: monospace;\n}\n.apg-active {\n  font-weight: bold;\n  color: #000000;\n}\n.apg-match {\n  font-weight: bold;\n  color: #264BFF;\n}\n.apg-empty {\n  font-weight: bold;\n  color: #0fbd0f;\n}\n.apg-nomatch {\n  font-weight: bold;\n  color: #FF4000;\n}\n.apg-lh-match {\n  font-weight: bold;\n  color: #1A97BA;\n}\n.apg-lb-match {\n  font-weight: bold;\n  color: #5F1687;\n}\n.apg-remainder {\n  font-weight: bold;\n  color: #999999;\n}\n.apg-ctrl-char {\n  font-weight: bolder;\n  font-style: italic;\n  font-size: 0.6em;\n}\n.apg-line-end {\n  font-weight: bold;\n  color: #000000;\n}\n.apg-error {\n  font-weight: bold;\n  color: #FF4000;\n}\n.apg-phrase {\n  color: #000000;\n  background-color: #8caae6;\n}\n.apg-empty-phrase {\n  color: #0fbd0f;\n}\ntable.apg-state {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: left;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-state th,\ntable.apg-state td {\n  text-align: left;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-state th:nth-last-child(2),\ntable.apg-state td:nth-last-child(2) {\n  text-align: right;\n}\ntable.apg-state caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-stats {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-stats th,\ntable.apg-stats td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-stats caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-trace {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-trace caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-trace th,\ntable.apg-trace td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-trace th:last-child,\ntable.apg-trace th:nth-last-child(2),\ntable.apg-trace td:last-child,\ntable.apg-trace td:nth-last-child(2) {\n  text-align: left;\n}\ntable.apg-grammar {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-grammar caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-grammar th,\ntable.apg-grammar td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-grammar th:last-child,\ntable.apg-grammar td:last-child {\n  text-align: left;\n}\ntable.apg-rules {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-rules caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-rules th,\ntable.apg-rules td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-rules a {\n  color: #003399 !important;\n}\ntable.apg-rules a:hover {\n  color: #8caae6 !important;\n}\ntable.apg-attrs {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: center;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-attrs caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-attrs th,\ntable.apg-attrs td {\n  text-align: center;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-attrs th:nth-child(1),\ntable.apg-attrs th:nth-child(2),\ntable.apg-attrs th:nth-child(3) {\n  text-align: right;\n}\ntable.apg-attrs td:nth-child(1),\ntable.apg-attrs td:nth-child(2),\ntable.apg-attrs td:nth-child(3) {\n  text-align: right;\n}\ntable.apg-attrs a {\n  color: #003399 !important;\n}\ntable.apg-attrs a:hover {\n  color: #8caae6 !important;\n}\n";
        };
      },
      58276: function (e) {
        e.exports = {
          ALT: 1,
          CAT: 2,
          REP: 3,
          RNM: 4,
          TRG: 5,
          TBS: 6,
          TLS: 7,
          UDT: 11,
          AND: 12,
          NOT: 13,
          BKR: 14,
          BKA: 15,
          BKN: 16,
          ABG: 17,
          AEN: 18,
          ACTIVE: 100,
          MATCH: 101,
          EMPTY: 102,
          NOMATCH: 103,
          SEM_PRE: 200,
          SEM_POST: 201,
          SEM_OK: 300,
          SEM_SKIP: 301,
          ATTR_N: 400,
          ATTR_R: 401,
          ATTR_MR: 402,
          LOOKAROUND_NONE: 500,
          LOOKAROUND_AHEAD: 501,
          LOOKAROUND_BEHIND: 502,
          BKR_MODE_UM: 601,
          BKR_MODE_PM: 602,
          BKR_MODE_CS: 603,
          BKR_MODE_CI: 604,
        };
      },
      28737: function (e, t, n) {
        e.exports = {
          ast: n(90580),
          circular: n(42761),
          ids: n(58276),
          parser: n(48629),
          stats: n(35403),
          trace: n(99290),
          utils: n(8544),
          emitcss: n(91593),
          style: n(93932),
        };
      },
      48629: function (e, t, n) {
        e.exports = function () {
          let e, t, s, i, a;
          let o = n(58276),
            l = n(8544),
            u = "parser.js: ",
            c = this;
          (this.ast = null),
            (this.stats = null),
            (this.trace = null),
            (this.callbacks = []);
          let d = null,
            h = null,
            p = 0,
            f = 0,
            g = 0,
            m = null,
            y = null,
            b = null,
            A = null,
            w = null,
            v = 0,
            E = 1 / 0,
            P = 1 / 0,
            k = function (t, n, s) {
              let a = `${u}evaluateRule(): `;
              if (t >= b.length)
                throw Error(`${a}rule index: ${t} out of range`);
              if (n >= i) throw Error(`${a}phrase index: ${n} out of range`);
              let { length: l } = d;
              d.push({ type: o.RNM, index: t }), e(l, n, s), d.pop();
            },
            T = function (t, n, s) {
              let a = `${u}evaluateUdt(): `;
              if (t >= A.length)
                throw Error(`${a}udt index: ${t} out of range`);
              if (n >= i) throw Error(`${a}phrase index: ${n} out of range`);
              let { length: l } = d;
              d.push({ type: o.UDT, empty: A[t].empty, index: t }),
                e(l, n, s),
                d.pop();
            },
            x = function () {
              (p = 0),
                (f = 0),
                (g = 0),
                (v = 0),
                (a = [
                  {
                    lookAround: o.LOOKAROUND_NONE,
                    anchor: 0,
                    charsEnd: 0,
                    charsLength: 0,
                  },
                ]),
                (b = null),
                (A = null),
                (h = null),
                (t = 0),
                (s = 0),
                (i = 0),
                (m = null),
                (y = null),
                (w = null),
                (d = null);
            },
            O = function () {
              let e = [],
                t = function () {
                  let t = e[e.length - 1],
                    n = {};
                  for (let e in t) n[e] = t[e];
                  return n;
                };
              (this.push = function () {
                e.push(t());
              }),
                (this.pop = function (t) {
                  let n = t;
                  if ((n || (n = e.length - 1), n < 1 || n > e.length))
                    throw Error(`${u}backRef.pop(): bad length: ${n}`);
                  return (e.length = n), e[e.length - 1];
                }),
                (this.length = function () {
                  return e.length;
                }),
                (this.savePhrase = function (t, n, s) {
                  e[e.length - 1][t] = { phraseIndex: n, phraseLength: s };
                }),
                (this.getPhrase = function (t) {
                  return e[e.length - 1][t];
                }),
                (function () {
                  let t = {};
                  b.forEach((e) => {
                    e.isBkr && (t[e.lower] = null);
                  }),
                    A.length > 0 &&
                      A.forEach((e) => {
                        e.isBkr && (t[e.lower] = null);
                      }),
                    e.push(t);
                })();
            },
            S = function () {
              let e = this;
              (this.state = o.ACTIVE),
                (this.phraseLength = 0),
                (this.ruleIndex = 0),
                (this.udtIndex = 0),
                (this.lookAround = a[a.length - 1]),
                (this.uFrame = new O()),
                (this.pFrame = new O()),
                (this.evaluateRule = k),
                (this.evaluateUdt = T),
                (this.refresh = function () {
                  (e.state = o.ACTIVE),
                    (e.phraseLength = 0),
                    (e.lookAround = a[a.length - 1]);
                });
            },
            C = function () {
              return a[a.length - 1];
            },
            B = function () {
              return a.length > 1;
            },
            N = function () {
              let e = `${u}initializeAst(): `;
              for (;;) {
                if (void 0 === c.ast) {
                  c.ast = null;
                  break;
                }
                if (null === c.ast) break;
                if ("astObject" !== c.ast.astObject)
                  throw Error(`${e}ast object not recognized`);
                break;
              }
              null !== c.ast && c.ast.init(b, A, h);
            },
            R = function () {
              let e = `${u}initializeTrace(): `;
              for (;;) {
                if (void 0 === c.trace) {
                  c.trace = null;
                  break;
                }
                if (null === c.trace) break;
                if ("traceObject" !== c.trace.traceObject)
                  throw Error(`${e}trace object not recognized`);
                break;
              }
              null !== c.trace && c.trace.init(b, A, h);
            },
            I = function () {
              let e = `${u}initializeStats(): `;
              for (;;) {
                if (void 0 === c.stats) {
                  c.stats = null;
                  break;
                }
                if (null === c.stats) break;
                if ("statsObject" !== c.stats.statsObject)
                  throw Error(`${e}stats object not recognized`);
                break;
              }
              null !== c.stats && c.stats.init(b, A);
            },
            M = function (e) {
              let t = `${u}initializeGrammar(): `;
              if (!e) throw Error(`${t}grammar object undefined`);
              if ("grammarObject" !== e.grammarObject)
                throw Error(`${t}bad grammar object`);
              (b = e.rules), (A = e.udts);
            },
            L = function (e) {
              let t = `${u}initializeStartRule(): `,
                n = null;
              if ("number" == typeof e) {
                if (e >= b.length)
                  throw Error(
                    `${t}start rule index too large: max: ${b.length}: index: ${e}`
                  );
                n = e;
              } else if ("string" == typeof e) {
                let s = e.toLowerCase();
                for (let e = 0; e < b.length; e += 1)
                  if (s === b[e].lower) {
                    n = b[e].index;
                    break;
                  }
                if (null === n)
                  throw Error(`${t}start rule name '${e}' not recognized`);
              } else
                throw Error(
                  `${t}type of start rule '${typeof e}' not recognized`
                );
              return n;
            },
            _ = function (e, n, a) {
              let o = `${u}initializeInputChars(): `,
                c = e,
                d = n,
                p = a;
              if (void 0 === c) throw Error(`${o}input string is undefined`);
              if (null === c) throw Error(`${o}input string is null`);
              if ("string" == typeof c) c = l.stringToChars(c);
              else if (!Array.isArray(c))
                throw Error(`${o}input string is not a string or array`);
              if (c.length > 0 && "number" != typeof c[0])
                throw Error(`${o}input string not an array of integers`);
              if ("number" != typeof d) d = 0;
              else if ((d = Math.floor(d)) < 0 || d > c.length)
                throw Error(`${o}input beginning index out of range: ${d}`);
              if ("number" != typeof p) p = c.length - d;
              else if ((p = Math.floor(p)) < 0 || p > c.length - d)
                throw Error(`${o}input length out of range: ${p}`);
              (h = c), (i = (t = d) + (s = p));
            },
            F = function () {
              let e, t;
              let n = `${u}initializeCallbacks(): `;
              for (e = 0, m = [], y = []; e < b.length; e += 1) m[e] = null;
              for (e = 0; e < A.length; e += 1) y[e] = null;
              let s = [];
              for (e = 0; e < b.length; e += 1) s.push(b[e].lower);
              for (e = 0; e < A.length; e += 1) s.push(A[e].lower);
              for (let i in c.callbacks) {
                if ((e = s.indexOf(i.toLowerCase())) < 0)
                  throw Error(
                    `${n}syntax callback '${i}' not a rule or udt name`
                  );
                if (
                  ((t = c.callbacks[i]) || (t = null),
                  "function" == typeof t || null === t)
                )
                  e < b.length ? (m[e] = t) : (y[e - b.length] = t);
                else
                  throw Error(
                    `${n}syntax callback[${i}] must be function reference or 'false' (false/null/undefined/etc.)`
                  );
              }
              for (e = 0; e < A.length; e += 1)
                if (null === y[e])
                  throw Error(
                    `${n}all UDT callbacks must be defined. UDT callback[${A[e].lower}] not a function reference`
                  );
            };
          (this.setMaxTreeDepth = function (e) {
            if ("number" != typeof e || (E = Math.floor(e)) <= 0)
              throw Error(`parser: max tree depth must be integer > 0: ${e}`);
          }),
            (this.setMaxNodeHits = function (e) {
              if ("number" != typeof e || (P = Math.floor(e)) <= 0)
                throw Error(`parser: max node hits must be integer > 0: ${e}`);
            });
          let D = function (n, a, l) {
            let c;
            let p = `${u}parse(): `;
            M(n);
            let m = L(a);
            F(), R(), I(), N();
            let y = new S();
            switch (
              (null != l && (w = l),
              (d = [{ type: o.RNM, index: m }]),
              e(0, t, y),
              (d = null),
              y.state)
            ) {
              case o.ACTIVE:
                throw Error(`${p}final state should never be 'ACTIVE'`);
              case o.NOMATCH:
                c = !1;
                break;
              case o.EMPTY:
              case o.MATCH:
                c = y.phraseLength === s;
                break;
              default:
                throw Error("unrecognized state");
            }
            return {
              success: c,
              state: y.state,
              length: s,
              matched: y.phraseLength,
              maxMatched: v,
              maxTreeDepth: f,
              nodeHits: g,
              inputLength: h.length,
              subBegin: t,
              subEnd: i,
              subLength: s,
            };
          };
          (this.parseSubstring = function (e, t, n, s, i, a) {
            return x(), _(n, s, i), D(e, t, a);
          }),
            (this.parse = function (e, t, n, s) {
              return x(), _(n, 0, n.length), D(e, t, s);
            });
          let U = function (t, n, s) {
              let i = d[t];
              for (
                let t = 0;
                t < i.children.length &&
                (e(i.children[t], n, s), s.state === o.NOMATCH);
                t += 1
              );
            },
            j = function (t, n, s) {
              let i, a, l, u;
              let h = d[t],
                p = s.uFrame.length(),
                f = s.pFrame.length();
              c.ast && (a = c.ast.getLength()), (i = !0), (l = n), (u = 0);
              for (let t = 0; t < h.children.length; t += 1) {
                if ((e(h.children[t], l, s), s.state === o.NOMATCH)) {
                  i = !1;
                  break;
                }
                (l += s.phraseLength), (u += s.phraseLength);
              }
              i
                ? ((s.state = 0 === u ? o.EMPTY : o.MATCH),
                  (s.phraseLength = u))
                : ((s.state = o.NOMATCH),
                  (s.phraseLength = 0),
                  s.uFrame.pop(p),
                  s.pFrame.pop(f),
                  c.ast && c.ast.setLength(a));
            },
            H = function (t, n, s) {
              let a, l, u, h;
              let p = d[t];
              if (0 === p.max) {
                (s.state = o.EMPTY), (s.phraseLength = 0);
                return;
              }
              (l = n), (u = 0), (h = 0);
              let f = s.uFrame.length(),
                g = s.pFrame.length();
              for (
                c.ast && (a = c.ast.getLength());
                !(l >= i) &&
                (e(t + 1, l, s),
                s.state !== o.NOMATCH &&
                  s.state !== o.EMPTY &&
                  ((h += 1),
                  (u += s.phraseLength),
                  (l += s.phraseLength),
                  h !== p.max));

              );
              s.state === o.EMPTY
                ? ((s.state = 0 === u ? o.EMPTY : o.MATCH),
                  (s.phraseLength = u))
                : h >= p.min
                ? ((s.state = 0 === u ? o.EMPTY : o.MATCH),
                  (s.phraseLength = u))
                : ((s.state = o.NOMATCH),
                  (s.phraseLength = 0),
                  s.uFrame.pop(f),
                  s.pFrame.pop(g),
                  c.ast && c.ast.setLength(a));
            },
            $ = function (e, t, n, s) {
              if (t.phraseLength > n) {
                let s = `${u}opRNM(${e.name}): callback function error: `;
                throw Error(
                  (s += `sysData.phraseLength: ${t.phraseLength} must be <= remaining chars: ${n}`)
                );
              }
              switch (t.state) {
                case o.ACTIVE:
                  if (!0 !== s)
                    throw Error(
                      `${u}opRNM(${e.name}): callback function return error. ACTIVE state not allowed.`
                    );
                  break;
                case o.EMPTY:
                  t.phraseLength = 0;
                  break;
                case o.MATCH:
                  0 === t.phraseLength && (t.state = o.EMPTY);
                  break;
                case o.NOMATCH:
                  t.phraseLength = 0;
                  break;
                default:
                  throw Error(
                    `${u}opRNM(${e.name}): callback function return error. Unrecognized return state: ${t.state}`
                  );
              }
            },
            G = function (t, n, s) {
              let a, l, u, p, f, g;
              let y = d[t],
                A = b[y.index],
                v = m[A.index],
                E = !B();
              if (
                (E &&
                  ((l = c.ast && c.ast.ruleDefined(y.index)) &&
                    ((a = c.ast.getLength()),
                    c.ast.down(y.index, b[y.index].name)),
                  (p = s.uFrame.length()),
                  (f = s.pFrame.length()),
                  s.uFrame.push(),
                  s.pFrame.push(),
                  (g = s.pFrame),
                  (s.pFrame = new O())),
                null === v)
              )
                (u = d), (d = A.opcodes), e(0, n, s), (d = u);
              else {
                let t = i - n;
                (s.ruleIndex = A.index),
                  v(s, h, n, w),
                  $(A, s, t, !0),
                  s.state === o.ACTIVE &&
                    ((u = d),
                    (d = A.opcodes),
                    e(0, n, s),
                    (d = u),
                    (s.ruleIndex = A.index),
                    v(s, h, n, w),
                    $(A, s, t, !1));
              }
              E &&
                (l &&
                  (s.state === o.NOMATCH
                    ? c.ast.setLength(a)
                    : c.ast.up(y.index, A.name, n, s.phraseLength)),
                (s.pFrame = g),
                s.state === o.NOMATCH
                  ? (s.uFrame.pop(p), s.pFrame.pop(f))
                  : A.isBkr &&
                    (s.pFrame.savePhrase(A.lower, n, s.phraseLength),
                    s.uFrame.savePhrase(A.lower, n, s.phraseLength)));
            },
            K = function (e, t, n) {
              if (t.phraseLength > n) {
                let s = `${u}opUDT(${e.name}): callback function error: `;
                throw Error(
                  (s += `sysData.phraseLength: ${t.phraseLength} must be <= remaining chars: ${n}`)
                );
              }
              switch (t.state) {
                case o.ACTIVE:
                  throw Error(
                    `${u}opUDT(${e.name}): callback function return error. ACTIVE state not allowed.`
                  );
                case o.EMPTY:
                  if (!1 === e.empty)
                    throw Error(
                      `${u}opUDT(${e.name}): callback function return error. May not return EMPTY.`
                    );
                  t.phraseLength = 0;
                  break;
                case o.MATCH:
                  if (0 === t.phraseLength) {
                    if (!1 === e.empty)
                      throw Error(
                        `${u}opUDT(${e.name}): callback function return error. May not return EMPTY.`
                      );
                    t.state = o.EMPTY;
                  }
                  break;
                case o.NOMATCH:
                  t.phraseLength = 0;
                  break;
                default:
                  throw Error(
                    `${u}opUDT(${e.name}): callback function return error. Unrecognized return state: ${t.state}`
                  );
              }
            },
            V = function (e, t, n) {
              let s, a, l, u, p, f;
              let g = d[e],
                m = A[g.index];
              n.UdtIndex = m.index;
              let v = !B();
              v &&
                ((l = c.ast && c.ast.udtDefined(g.index)) &&
                  ((a = b.length + g.index),
                  (s = c.ast.getLength()),
                  c.ast.down(a, m.name)),
                (u = n.uFrame.length()),
                (p = n.pFrame.length()),
                n.uFrame.push(),
                n.pFrame.push(),
                (f = n.pFrame),
                (n.pFrame = new O()));
              let E = i - t;
              y[g.index](n, h, t, w),
                K(m, n, E),
                v &&
                  (l &&
                    (n.state === o.NOMATCH
                      ? c.ast.setLength(s)
                      : c.ast.up(a, m.name, t, n.phraseLength)),
                  (n.pFrame = f),
                  n.state === o.NOMATCH
                    ? (n.uFrame.pop(u), n.pFrame.pop(p))
                    : m.isBkr &&
                      (n.pFrame.savePhrase(m.lower, t, n.phraseLength),
                      n.uFrame.savePhrase(m.lower, t, n.phraseLength)));
            },
            z = function (n, l, u) {
              a.push({
                lookAround: o.LOOKAROUND_AHEAD,
                anchor: l,
                charsEnd: i,
                charsLength: s,
              }),
                (i = h.length),
                (s = h.length - t),
                e(n + 1, l, u);
              let c = a.pop();
              switch (
                ((i = c.charsEnd),
                (s = c.charsLength),
                (u.phraseLength = 0),
                u.state)
              ) {
                case o.EMPTY:
                case o.MATCH:
                  u.state = o.EMPTY;
                  break;
                case o.NOMATCH:
                  u.state = o.NOMATCH;
                  break;
                default:
                  throw Error(`opAND: invalid state ${u.state}`);
              }
            },
            J = function (n, l, u) {
              a.push({
                lookAround: o.LOOKAROUND_AHEAD,
                anchor: l,
                charsEnd: i,
                charsLength: s,
              }),
                (i = h.length),
                (s = h.length - t),
                e(n + 1, l, u);
              let c = a.pop();
              switch (
                ((i = c.charsEnd),
                (s = c.charsLength),
                (u.phraseLength = 0),
                u.state)
              ) {
                case o.EMPTY:
                case o.MATCH:
                  u.state = o.NOMATCH;
                  break;
                case o.NOMATCH:
                  u.state = o.EMPTY;
                  break;
                default:
                  throw Error(`opNOT: invalid state ${u.state}`);
              }
            },
            Q = function (e, t, n) {
              let s = d[e];
              (n.state = o.NOMATCH),
                t < i &&
                  s.min <= h[t] &&
                  h[t] <= s.max &&
                  ((n.state = o.MATCH), (n.phraseLength = 1));
            },
            q = function (e, t, n) {
              let s;
              let a = d[e],
                l = a.string.length;
              if (((n.state = o.NOMATCH), t + l <= i)) {
                for (s = 0; s < l; s += 1) if (h[t + s] !== a.string[s]) return;
                (n.state = o.MATCH), (n.phraseLength = l);
              }
            },
            W = function (e, t, n) {
              let s, a;
              let l = d[e];
              n.state = o.NOMATCH;
              let u = l.string.length;
              if (0 === u) {
                n.state = o.EMPTY;
                return;
              }
              if (t + u <= i) {
                for (s = 0; s < u; s += 1)
                  if (
                    ((a = h[t + s]) >= 65 && a <= 90 && (a += 32),
                    a !== l.string[s])
                  )
                    return;
                (n.state = o.MATCH), (n.phraseLength = u);
              }
            },
            Y = function (e, t, n) {
              (n.state = o.NOMATCH),
                (n.phraseLength = 0),
                (n.state = 0 === t ? o.EMPTY : o.NOMATCH);
            },
            Z = function (e, t, n) {
              (n.state = o.NOMATCH),
                (n.phraseLength = 0),
                (n.state = t === h.length ? o.EMPTY : o.NOMATCH);
            },
            X = function (e, t, n) {
              let s, a, l, u;
              let c = d[e];
              (n.state = o.NOMATCH),
                (u =
                  c.index < b.length
                    ? b[c.index].lower
                    : A[c.index - b.length].lower);
              let p =
                  c.bkrMode === o.BKR_MODE_PM
                    ? n.pFrame.getPhrase(u)
                    : n.uFrame.getPhrase(u),
                f = c.bkrCase === o.BKR_MODE_CI;
              if (null === p) return;
              let g = p.phraseIndex,
                m = p.phraseLength;
              if (0 === m) {
                n.state = o.EMPTY;
                return;
              }
              if (t + m <= i) {
                if (f) {
                  for (s = 0; s < m; s += 1)
                    if (
                      ((a = h[t + s]),
                      (l = h[g + s]),
                      a >= 65 && a <= 90 && (a += 32),
                      l >= 65 && l <= 90 && (l += 32),
                      a !== l)
                    )
                      return;
                  (n.state = o.MATCH), (n.phraseLength = m);
                } else
                  for (s = 0; s < m; s += 1)
                    if ((a = h[t + s]) !== (l = h[g + s])) return;
                (n.state = o.MATCH), (n.phraseLength = m);
              }
            },
            ee = function (t, n, s) {
              switch (
                (a.push({ lookAround: o.LOOKAROUND_BEHIND, anchor: n }),
                e(t + 1, n, s),
                a.pop(),
                (s.phraseLength = 0),
                s.state)
              ) {
                case o.EMPTY:
                case o.MATCH:
                  s.state = o.EMPTY;
                  break;
                case o.NOMATCH:
                  s.state = o.NOMATCH;
                  break;
                default:
                  throw Error(`opBKA: invalid state ${s.state}`);
              }
            },
            et = function (t, n, s) {
              switch (
                (a.push({ lookAround: o.LOOKAROUND_BEHIND, anchor: n }),
                e(t + 1, n, s),
                a.pop(),
                (s.phraseLength = 0),
                s.state)
              ) {
                case o.EMPTY:
                case o.MATCH:
                  s.state = o.NOMATCH;
                  break;
                case o.NOMATCH:
                  s.state = o.EMPTY;
                  break;
                default:
                  throw Error(`opBKN: invalid state ${s.state}`);
              }
            },
            er = function (t, n, s) {
              let i, a, l, u;
              let h = d[t],
                p = s.uFrame.length(),
                f = s.pFrame.length();
              c.ast && (a = c.ast.getLength()), (i = !0), (l = n), (u = 0);
              for (let t = h.children.length - 1; t >= 0; t -= 1)
                if (
                  (e(h.children[t], l, s),
                  (l -= s.phraseLength),
                  (u += s.phraseLength),
                  s.state === o.NOMATCH)
                ) {
                  i = !1;
                  break;
                }
              i
                ? ((s.state = 0 === u ? o.EMPTY : o.MATCH),
                  (s.phraseLength = u))
                : ((s.state = o.NOMATCH),
                  (s.phraseLength = 0),
                  s.uFrame.pop(p),
                  s.pFrame.pop(f),
                  c.ast && c.ast.setLength(a));
            },
            en = function (t, n, s) {
              let i, a, l, u;
              let h = d[t];
              (a = n), (l = 0), (u = 0);
              let p = s.uFrame.length(),
                f = s.pFrame.length();
              for (
                c.ast && (i = c.ast.getLength());
                !(a <= 0) &&
                (e(t + 1, a, s),
                s.state !== o.NOMATCH &&
                  s.state !== o.EMPTY &&
                  ((u += 1),
                  (l += s.phraseLength),
                  (a -= s.phraseLength),
                  u !== h.max));

              );
              s.state === o.EMPTY
                ? ((s.state = 0 === l ? o.EMPTY : o.MATCH),
                  (s.phraseLength = l))
                : u >= h.min
                ? ((s.state = 0 === l ? o.EMPTY : o.MATCH),
                  (s.phraseLength = l))
                : ((s.state = o.NOMATCH),
                  (s.phraseLength = 0),
                  s.uFrame.pop(p),
                  s.pFrame.pop(f),
                  c.ast && c.ast.setLength(i));
            },
            es = function (e, t, n) {
              let s = d[e];
              if (((n.state = o.NOMATCH), (n.phraseLength = 0), t > 0)) {
                let e = h[t - 1];
                s.min <= e &&
                  e <= s.max &&
                  ((n.state = o.MATCH), (n.phraseLength = 1));
              }
            },
            ei = function (e, t, n) {
              let s;
              let i = d[e];
              n.state = o.NOMATCH;
              let a = i.string.length,
                l = t - a;
              if (l >= 0) {
                for (s = 0; s < a; s += 1) if (h[l + s] !== i.string[s]) return;
                (n.state = o.MATCH), (n.phraseLength = a);
              }
            },
            ea = function (e, t, n) {
              let s;
              let i = d[e];
              n.state = o.NOMATCH;
              let a = i.string.length;
              if (0 === a) {
                n.state = o.EMPTY;
                return;
              }
              let l = t - a;
              if (l >= 0) {
                for (let e = 0; e < a; e += 1)
                  if (
                    ((s = h[l + e]) >= 65 && s <= 90 && (s += 32),
                    s !== i.string[e])
                  )
                    return;
                (n.state = o.MATCH), (n.phraseLength = a);
              }
            },
            eo = function (e, t, n) {
              let s, i, a, l;
              let u = d[e];
              (n.state = o.NOMATCH),
                (n.phraseLength = 0),
                (l =
                  u.index < b.length
                    ? b[u.index].lower
                    : A[u.index - b.length].lower);
              let c =
                  u.bkrMode === o.BKR_MODE_PM
                    ? n.pFrame.getPhrase(l)
                    : n.uFrame.getPhrase(l),
                p = u.bkrCase === o.BKR_MODE_CI;
              if (null === c) return;
              let f = c.phraseIndex,
                g = c.phraseLength;
              if (0 === g) {
                (n.state = o.EMPTY), (n.phraseLength = 0);
                return;
              }
              let m = t - g;
              if (m >= 0) {
                if (p) {
                  for (s = 0; s < g; s += 1)
                    if (
                      ((i = h[m + s]),
                      (a = h[f + s]),
                      i >= 65 && i <= 90 && (i += 32),
                      a >= 65 && a <= 90 && (a += 32),
                      i !== a)
                    )
                      return;
                  (n.state = o.MATCH), (n.phraseLength = g);
                } else
                  for (s = 0; s < g; s += 1)
                    if ((i = h[m + s]) !== (a = h[f + s])) return;
                (n.state = o.MATCH), (n.phraseLength = g);
              }
            };
          e = function (e, t, n) {
            let s = !0,
              i = d[e];
            if ((g += 1) > P)
              throw Error(`parser: maximum number of node hits exceeded: ${P}`);
            if ((p += 1) > f && (f = p) > E)
              throw Error(`parser: maximum parse tree depth exceeded: ${E}`);
            if ((n.refresh(), null !== c.trace)) {
              let e = C();
              c.trace.down(
                i,
                n.state,
                t,
                n.phraseLength,
                e.anchor,
                e.lookAround
              );
            }
            if (a[a.length - 1].lookAround === o.LOOKAROUND_BEHIND)
              switch (i.type) {
                case o.ALT:
                  U(e, t, n);
                  break;
                case o.CAT:
                  er(e, t, n);
                  break;
                case o.REP:
                  en(e, t, n);
                  break;
                case o.RNM:
                  G(e, t, n);
                  break;
                case o.UDT:
                  V(e, t, n);
                  break;
                case o.AND:
                  z(e, t, n);
                  break;
                case o.NOT:
                  J(e, t, n);
                  break;
                case o.TRG:
                  es(e, t, n);
                  break;
                case o.TBS:
                  ei(e, t, n);
                  break;
                case o.TLS:
                  ea(e, t, n);
                  break;
                case o.BKR:
                  eo(e, t, n);
                  break;
                case o.BKA:
                  ee(e, t, n);
                  break;
                case o.BKN:
                  et(e, t, n);
                  break;
                case o.ABG:
                  Y(e, t, n);
                  break;
                case o.AEN:
                  Z(e, t, n);
                  break;
                default:
                  s = !1;
              }
            else
              switch (i.type) {
                case o.ALT:
                  U(e, t, n);
                  break;
                case o.CAT:
                  j(e, t, n);
                  break;
                case o.REP:
                  H(e, t, n);
                  break;
                case o.RNM:
                  G(e, t, n);
                  break;
                case o.UDT:
                  V(e, t, n);
                  break;
                case o.AND:
                  z(e, t, n);
                  break;
                case o.NOT:
                  J(e, t, n);
                  break;
                case o.TRG:
                  Q(e, t, n);
                  break;
                case o.TBS:
                  q(e, t, n);
                  break;
                case o.TLS:
                  W(e, t, n);
                  break;
                case o.BKR:
                  X(e, t, n);
                  break;
                case o.BKA:
                  ee(e, t, n);
                  break;
                case o.BKN:
                  et(e, t, n);
                  break;
                case o.ABG:
                  Y(e, t, n);
                  break;
                case o.AEN:
                  Z(e, t, n);
                  break;
                default:
                  s = !1;
              }
            if (
              (!B() && t + n.phraseLength > v && (v = t + n.phraseLength),
              null !== c.stats && c.stats.collect(i, n),
              null !== c.trace)
            ) {
              let e = C();
              c.trace.up(i, n.state, t, n.phraseLength, e.anchor, e.lookAround);
            }
            return (p -= 1), s;
          };
        };
      },
      35403: function (e, t, n) {
        e.exports = function () {
          let e;
          let t = n(58276),
            s = n(8544),
            i = n(93932),
            a = [],
            o = [],
            l = [],
            u = [],
            c = [];
          this.statsObject = "statsObject";
          let d = function (e, t) {
              return e.lower < t.lower ? -1 : e.lower > t.lower ? 1 : 0;
            },
            h = function (e, t) {
              return e.total < t.total ? 1 : e.total > t.total ? -1 : d(e, t);
            },
            p = function (e, t) {
              return e.index < t.index ? -1 : e.index > t.index ? 1 : 0;
            },
            f = function () {
              (this.empty = 0),
                (this.match = 0),
                (this.nomatch = 0),
                (this.total = 0);
            },
            g = function () {
              (l.length = 0),
                (e = new f()),
                (l[t.ALT] = new f()),
                (l[t.CAT] = new f()),
                (l[t.REP] = new f()),
                (l[t.RNM] = new f()),
                (l[t.TRG] = new f()),
                (l[t.TBS] = new f()),
                (l[t.TLS] = new f()),
                (l[t.UDT] = new f()),
                (l[t.AND] = new f()),
                (l[t.NOT] = new f()),
                (l[t.BKR] = new f()),
                (l[t.BKA] = new f()),
                (l[t.BKN] = new f()),
                (l[t.ABG] = new f()),
                (l[t.AEN] = new f()),
                (u.length = 0);
              for (let e = 0; e < a.length; e += 1)
                u.push({
                  empty: 0,
                  match: 0,
                  nomatch: 0,
                  total: 0,
                  name: a[e].name,
                  lower: a[e].lower,
                  index: a[e].index,
                });
              if (o.length > 0) {
                c.length = 0;
                for (let e = 0; e < o.length; e += 1)
                  c.push({
                    empty: 0,
                    match: 0,
                    nomatch: 0,
                    total: 0,
                    name: o[e].name,
                    lower: o[e].lower,
                    index: o[e].index,
                  });
              }
            },
            m = function (e, n) {
              switch (((e.total += 1), n)) {
                case t.EMPTY:
                  e.empty += 1;
                  break;
                case t.MATCH:
                  e.match += 1;
                  break;
                case t.NOMATCH:
                  e.nomatch += 1;
                  break;
                default:
                  throw Error(
                    `stats.js: collect(): incStat(): unrecognized state: ${n}`
                  );
              }
            },
            y = function (e, t) {
              return `<tr><td class="${i.CLASS_ACTIVE}">${e}</td><td class="${i.CLASS_EMPTY}">${t.empty}</td><td class="${i.CLASS_MATCH}">${t.match}</td><td class="${i.CLASS_NOMATCH}">${t.nomatch}</td><td class="${i.CLASS_ACTIVE}">${t.total}</td></tr>
`;
            },
            b = function () {
              return (
                "" +
                (y("ALT", l[t.ALT]) +
                  y("CAT", l[t.CAT]) +
                  y("REP", l[t.REP]) +
                  y("RNM", l[t.RNM]) +
                  y("TRG", l[t.TRG]) +
                  y("TBS", l[t.TBS]) +
                  y("TLS", l[t.TLS]) +
                  y("UDT", l[t.UDT]) +
                  y("AND", l[t.AND]) +
                  y("NOT", l[t.NOT]) +
                  y("BKR", l[t.BKR]) +
                  y("BKA", l[t.BKA]) +
                  y("BKN", l[t.BKN]) +
                  y("ABG", l[t.ABG]) +
                  y("AEN", l[t.AEN]) +
                  y("totals", e))
              );
            },
            A = function () {
              let e = "";
              e +=
                "<tr><th></th><th></th><th></th><th></th><th></th></tr>\n<tr><th>rules</th><th></th><th></th><th></th><th></th></tr>\n";
              for (let t = 0; t < a.length; t += 1)
                u[t].total > 0 &&
                  (e += `<tr><td class="${i.CLASS_ACTIVE}">${u[t].name}</td><td class="${i.CLASS_EMPTY}">${u[t].empty}</td><td class="${i.CLASS_MATCH}">${u[t].match}</td><td class="${i.CLASS_NOMATCH}">${u[t].nomatch}</td><td class="${i.CLASS_ACTIVE}">${u[t].total}</td></tr>
`);
              if (o.length > 0) {
                e +=
                  "<tr><th></th><th></th><th></th><th></th><th></th></tr>\n<tr><th>udts</th><th></th><th></th><th></th><th></th></tr>\n";
                for (let t = 0; t < o.length; t += 1)
                  c[t].total > 0 &&
                    (e += `<tr><td class="${i.CLASS_ACTIVE}">${c[t].name}</td><td class="${i.CLASS_EMPTY}">${c[t].empty}</td><td class="${i.CLASS_MATCH}">${c[t].match}</td><td class="${i.CLASS_NOMATCH}">${c[t].nomatch}</td><td class="${i.CLASS_ACTIVE}">${c[t].total}</td></tr>
`);
              }
              return e;
            };
          (this.validate = function (e) {
            let t = !1;
            return "string" == typeof e && "stats" === e && (t = !0), t;
          }),
            (this.init = function (e, t) {
              (a = e), (o = t), g();
            }),
            (this.collect = function (n, s) {
              m(e, s.state, s.phraseLength),
                m(l[n.type], s.state, s.phraseLength),
                n.type === t.RNM && m(u[n.index], s.state, s.phraseLength),
                n.type === t.UDT && m(c[n.index], s.state, s.phraseLength);
            }),
            (this.toHtml = function (e, t) {
              let n = "";
              for (
                n += `<table class="${i.CLASS_STATS}">
`,
                  "string" == typeof t &&
                    (n += `<caption>${t}</caption>
`),
                  n += `<tr><th class="${i.CLASS_ACTIVE}">ops</th>
<th class="${i.CLASS_EMPTY}">EMPTY</th>
<th class="${i.CLASS_MATCH}">MATCH</th>
<th class="${i.CLASS_NOMATCH}">NOMATCH</th>
<th class="${i.CLASS_ACTIVE}">totals</th></tr>
`;
                ;

              ) {
                if (null == e || "ops" === e) {
                  n += b();
                  break;
                }
                if ("index" === e) {
                  u.sort(p), c.length > 0 && c.sort(p), (n += b() + A());
                  break;
                }
                if ("hits" === e) {
                  u.sort(h), c.length > 0 && c.sort(p), (n += b() + A());
                  break;
                }
                "alpha" === e &&
                  (u.sort(d), c.length > 0 && c.sort(d), (n += b() + A()));
                break;
              }
              return n + "</table>\n";
            }),
            (this.toHtmlPage = function (e, t, n) {
              return s.htmlToPage(this.toHtml(e, t), n);
            });
        };
      },
      93932: function (e) {
        e.exports = {
          CLASS_MONOSPACE: "apg-mono",
          CLASS_ACTIVE: "apg-active",
          CLASS_EMPTY: "apg-empty",
          CLASS_MATCH: "apg-match",
          CLASS_NOMATCH: "apg-nomatch",
          CLASS_LOOKAHEAD: "apg-lh-match",
          CLASS_LOOKBEHIND: "apg-lb-match",
          CLASS_REMAINDER: "apg-remainder",
          CLASS_CTRLCHAR: "apg-ctrl-char",
          CLASS_LINEEND: "apg-line-end",
          CLASS_ERROR: "apg-error",
          CLASS_PHRASE: "apg-phrase",
          CLASS_EMPTYPHRASE: "apg-empty-phrase",
          CLASS_STATE: "apg-state",
          CLASS_STATS: "apg-stats",
          CLASS_TRACE: "apg-trace",
          CLASS_GRAMMAR: "apg-grammar",
          CLASS_RULES: "apg-rules",
          CLASS_RULESLINK: "apg-rules-link",
          CLASS_ATTRIBUTES: "apg-attrs",
        };
      },
      99290: function (e, t, n) {
        e.exports = function () {
          let e = n(8544),
            t = n(93932),
            s = new (n(42761))(),
            i = n(58276),
            a = "trace.js: ",
            o = this,
            l = [],
            u = 5e3,
            c = -1,
            d = 0,
            h = 0,
            p = [],
            f = null,
            g = null,
            m = null,
            y = [],
            b = [],
            A = `<span class="${t.CLASS_LINEEND}">&bull;</span>`,
            w = `<span class="${t.CLASS_LINEEND}">&hellip;</span>`,
            v = `<span class="${t.CLASS_EMPTY}">&#120634;</span>`,
            E = function () {
              let e = function (e) {
                  (y[i.ALT] = e),
                    (y[i.CAT] = e),
                    (y[i.REP] = e),
                    (y[i.TLS] = e),
                    (y[i.TBS] = e),
                    (y[i.TRG] = e),
                    (y[i.AND] = e),
                    (y[i.NOT] = e),
                    (y[i.BKR] = e),
                    (y[i.BKA] = e),
                    (y[i.BKN] = e),
                    (y[i.ABG] = e),
                    (y[i.AEN] = e);
                },
                t = 0;
              for (let e in o.filter.operators) t += 1;
              if (0 === t) {
                e(!1);
                return;
              }
              for (let t in o.filter.operators) {
                let n = t.toUpperCase();
                if ("<ALL>" === n) {
                  e(!0);
                  return;
                }
                if ("<NONE>" === n) {
                  e(!1);
                  return;
                }
              }
              for (let t in (e(!1), o.filter.operators)) {
                let e = t.toUpperCase();
                if ("ALT" === e) y[i.ALT] = !0 === o.filter.operators[t];
                else if ("CAT" === e) y[i.CAT] = !0 === o.filter.operators[t];
                else if ("REP" === e) y[i.REP] = !0 === o.filter.operators[t];
                else if ("AND" === e) y[i.AND] = !0 === o.filter.operators[t];
                else if ("NOT" === e) y[i.NOT] = !0 === o.filter.operators[t];
                else if ("TLS" === e) y[i.TLS] = !0 === o.filter.operators[t];
                else if ("TBS" === e) y[i.TBS] = !0 === o.filter.operators[t];
                else if ("TRG" === e) y[i.TRG] = !0 === o.filter.operators[t];
                else if ("BKR" === e) y[i.BKR] = !0 === o.filter.operators[t];
                else if ("BKA" === e) y[i.BKA] = !0 === o.filter.operators[t];
                else if ("BKN" === e) y[i.BKN] = !0 === o.filter.operators[t];
                else if ("ABG" === e) y[i.ABG] = !0 === o.filter.operators[t];
                else if ("AEN" === e) y[i.AEN] = !0 === o.filter.operators[t];
                else
                  throw Error(
                    `${a}initOpratorFilter: '${t}' not a valid operator name. Must be <all>, <none>, alt, cat, rep, tls, tbs, trg, and, not, bkr, bka or bkn`
                  );
              }
            },
            P = function () {
              let e, t;
              let n = function (e) {
                  (y[i.RNM] = e), (y[i.UDT] = e);
                  let t = g.length + m.length;
                  b.length = 0;
                  for (let n = 0; n < t; n += 1) b.push(e);
                },
                s = [];
              for (t = 0; t < g.length; t += 1) s.push(g[t].lower);
              for (t = 0; t < m.length; t += 1) s.push(m[t].lower);
              for (let t in ((b.length = 0), (e = 0), o.filter.rules)) e += 1;
              if (0 === e) {
                n(!0);
                return;
              }
              for (let e in o.filter.rules) {
                let t = e.toLowerCase();
                if ("<all>" === t) {
                  n(!0);
                  return;
                }
                if ("<none>" === t) {
                  n(!1);
                  return;
                }
              }
              for (let e in (n(!1),
              (y[i.RNM] = !0),
              (y[i.UDT] = !0),
              o.filter.rules)) {
                let n = e.toLowerCase();
                if ((t = s.indexOf(n)) < 0)
                  throw Error(
                    `${a}initRuleFilter: '${e}' not a valid rule or udt name`
                  );
                b[t] = !0 === o.filter.rules[e];
              }
            };
          (this.traceObject = "traceObject"),
            (this.filter = { operators: [], rules: [] }),
            (this.setMaxRecords = function (e, t) {
              if (((c = -1), "number" == typeof e && e > 0)) u = Math.ceil(e);
              else {
                u = 0;
                return;
              }
              "number" == typeof t && (c = Math.floor(t)) < 0 && (c = -1);
            }),
            (this.getMaxRecords = function () {
              return u;
            }),
            (this.getLastRecord = function () {
              return c;
            }),
            (this.init = function (e, t, n) {
              (l.length = 0),
                (p.length = 0),
                (d = 0),
                (h = 0),
                (f = n),
                (g = e),
                (m = t),
                E(),
                P(),
                s.init(u);
            });
          let k = function (e) {
              return e.type === i.RNM
                ? !!y[e.type] && !!b[e.index]
                : e.type === i.UDT
                ? !!y[e.type] && !!b[g.length + e.index]
                : y[e.type];
            },
            T = function (e) {
              return -1 === c || e <= c;
            };
          (this.down = function (e, t, n, i, a, o) {
            T(d) &&
              k(e) &&
              (p.push(d),
              (l[s.increment()] = {
                dirUp: !1,
                depth: h,
                thisLine: d,
                thatLine: void 0,
                opcode: e,
                state: t,
                phraseIndex: n,
                phraseLength: i,
                lookAnchor: a,
                lookAround: o,
              }),
              (d += 1),
              (h += 1));
          }),
            (this.up = function (e, t, n, i, a, o) {
              if (T(d) && k(e)) {
                let u = d,
                  c = p.pop(),
                  f = s.getListIndex(c);
                -1 !== f && (l[f].thatLine = u),
                  (h -= 1),
                  (l[s.increment()] = {
                    dirUp: !0,
                    depth: h,
                    thisLine: u,
                    thatLine: c,
                    opcode: e,
                    state: t,
                    phraseIndex: n,
                    phraseLength: i,
                    lookAnchor: a,
                    lookAround: o,
                  }),
                  (d += 1);
              }
            });
          let x = function () {
            let t, n, a, o, u;
            function c(t, n) {
              let s, a, o;
              if (n)
                switch (
                  ((t.op = { id: n.type, name: e.opcodeToString(n.type) }),
                  (t.opData = void 0),
                  n.type)
                ) {
                  case i.RNM:
                    t.opData = g[n.index].name;
                    break;
                  case i.UDT:
                    t.opData = m[n.index].name;
                    break;
                  case i.BKR:
                    (s =
                      n.index < g.length
                        ? g[n.index].name
                        : m[n.index - g.length].name),
                      (a = n.bkrCase === i.BKR_MODE_CI ? "%i" : "%s"),
                      (o = n.bkrMode === i.BKR_MODE_UM ? "%u" : "%p"),
                      (t.opData = `\\\\${a}${o}${s}`);
                    break;
                  case i.TLS:
                    t.opData = [];
                    for (let e = 0; e < n.string.length; e += 1)
                      t.opData.push(n.string[e]);
                    break;
                  case i.TBS:
                    t.opData = [];
                    for (let e = 0; e < n.string.length; e += 1)
                      t.opData.push(n.string[e]);
                    break;
                  case i.TRG:
                  case i.REP:
                    t.opData = [n.min, n.max];
                    break;
                  default:
                    throw Error("unrecognized opcode");
                }
              else (t.op = { id: void 0, name: void 0 }), (t.opData = void 0);
            }
            function d(e, t, n) {
              return e === i.MATCH
                ? { index: t, length: n }
                : e === i.NOMATCH || e === i.EMPTY
                ? { index: t, length: 0 }
                : null;
            }
            let p = -1;
            function y(t, n, s) {
              let i = {
                id: p++,
                branch: -1,
                parent: t,
                up: !1,
                down: !1,
                depth: s,
                children: [],
              };
              return (
                n
                  ? ((i.down = !0),
                    (i.state = { id: n.state, name: e.stateToString(n.state) }),
                    (i.phrase = null),
                    c(i, n.opcode))
                  : ((i.state = { id: void 0, name: void 0 }),
                    (i.phrase = d()),
                    c(i, void 0)),
                i
              );
            }
            function b(t, n) {
              n &&
                ((t.up = !0),
                (t.state = { id: n.state, name: e.stateToString(n.state) }),
                (t.phrase = d(n.state, n.phraseIndex, n.phraseLength)),
                t.down || c(t, n.opcode));
            }
            let A = 0,
              w = -1,
              v = 1,
              E = [],
              P = !0,
              k = y(null, null, -1);
            for (
              E.push(k),
                n = k,
                s.forEach((e) => {
                  if (((o = l[e]), P && ((P = !1), o.depth > 0))) {
                    let e = o.dirUp ? o.depth + 1 : o.depth;
                    for (let t = 0; t < e; t += 1)
                      (a = n),
                        (n = y(n, null, t)),
                        E.push(n),
                        a.children.push(n);
                  }
                  o.dirUp
                    ? (b((n = E.pop()), o), (n = E[E.length - 1]))
                    : ((a = n),
                      (n = y(n, o, o.depth)),
                      E.push(n),
                      a.children.push(n));
                });
              E.length > 1;

            )
              b((n = E.pop()), null);
            if (0 === k.children.length)
              throw Error("trace.toTree(): parse tree has no nodes");
            if (0 === E.length)
              throw Error(
                "trace.toTree(): integrity check: dummy root node disappeared?"
              );
            let T = (t = k.children[0]);
            for (; t && !t.down && !t.up; ) (T = t), (t = t.children[0]);
            ((t = T).leftMost = !0),
              (t.rightMost = !0),
              (function e(t) {
                if (
                  ((w += 1),
                  (t.branch = v),
                  w > h && (h = w),
                  0 === t.children.length)
                )
                  A += 1;
                else
                  for (let n = 0; n < t.children.length; n += 1)
                    n > 0 && (v += 1),
                      (t.children[n].leftMost = !1),
                      (t.children[n].rightMost = !1),
                      t.leftMost && (t.children[n].leftMost = 0 === n),
                      t.rightMost &&
                        (t.children[n].rightMost = n === t.children.length - 1),
                      e(t.children[n]);
                w -= 1;
              })(t),
              (t.branch = 0);
            let x = {};
            x.string = [];
            for (let e = 0; e < f.length; e += 1) x.string[e] = f[e];
            x.rules = [];
            for (let e = 0; e < g.length; e += 1) x.rules[e] = g[e].name;
            x.udts = [];
            for (let e = 0; e < m.length; e += 1) x.udts[e] = m[e].name;
            return (
              (x.id = {}),
              (x.id.ALT = { id: i.ALT, name: "ALT" }),
              (x.id.CAT = { id: i.CAT, name: "CAT" }),
              (x.id.REP = { id: i.REP, name: "REP" }),
              (x.id.RNM = { id: i.RNM, name: "RNM" }),
              (x.id.TLS = { id: i.TLS, name: "TLS" }),
              (x.id.TBS = { id: i.TBS, name: "TBS" }),
              (x.id.TRG = { id: i.TRG, name: "TRG" }),
              (x.id.UDT = { id: i.UDT, name: "UDT" }),
              (x.id.AND = { id: i.AND, name: "AND" }),
              (x.id.NOT = { id: i.NOT, name: "NOT" }),
              (x.id.BKR = { id: i.BKR, name: "BKR" }),
              (x.id.BKA = { id: i.BKA, name: "BKA" }),
              (x.id.BKN = { id: i.BKN, name: "BKN" }),
              (x.id.ABG = { id: i.ABG, name: "ABG" }),
              (x.id.AEN = { id: i.AEN, name: "AEN" }),
              (x.id.ACTIVE = { id: i.ACTIVE, name: "ACTIVE" }),
              (x.id.MATCH = { id: i.MATCH, name: "MATCH" }),
              (x.id.EMPTY = { id: i.EMPTY, name: "EMPTY" }),
              (x.id.NOMATCH = { id: i.NOMATCH, name: "NOMATCH" }),
              (x.treeDepth = h),
              (x.leafNodes = A),
              (u = t.down ? (t.up ? "none" : "right") : t.up ? "left" : "both"),
              (x.branchesIncomplete = u),
              (x.tree = (function e(t, n) {
                let s;
                let i = {};
                if (
                  ((i.id = t.id),
                  (i.branch = t.branch),
                  (i.leftMost = t.leftMost),
                  (i.rightMost = t.rightMost),
                  (s = t.state.name ? t.state.name : "ACTIVE"),
                  (i.state = { id: t.state.id, name: s }),
                  (s = t.op.name ? t.op.name : "?"),
                  (i.op = { id: t.op.id, name: s }),
                  "string" == typeof t.opData)
                )
                  i.opData = t.opData;
                else if (Array.isArray(t.opData)) {
                  i.opData = [];
                  for (let e = 0; e < t.opData.length; e += 1)
                    i.opData[e] = t.opData[e];
                } else i.opData = void 0;
                t.phrase
                  ? (i.phrase = {
                      index: t.phrase.index,
                      length: t.phrase.length,
                    })
                  : (i.phrase = null),
                  (i.depth = t.depth),
                  (i.children = []);
                for (let s = 0; s < t.children.length; s += 1) {
                  let a = s !== t.children.length - 1;
                  i.children[s] = e(t.children[s], n, a);
                }
                return i;
              })(t, t.depth, !1)),
              x
            );
          };
          (this.toTree = function (e) {
            let t = x();
            return e ? JSON.stringify(t) : t;
          }),
            (this.toHtmlPage = function (t, n, s) {
              return e.htmlToPage(this.toHtml(t, n), s);
            });
          let O = function (e, n) {
            let s;
            switch (e) {
              case 16:
                s = "hexadecimal";
                break;
              case 10:
                s = "decimal";
                break;
              case 8:
                s = "ASCII";
                break;
              case 32:
                s = "UNICODE";
                break;
              default:
                throw Error(`${a}htmlHeader: unrecognized mode: ${e}`);
            }
            let i = "";
            return (
              (i += `<p>display mode: ${s}</p>
<table class="${t.CLASS_TRACE}">
`),
              "string" == typeof n && (i += `<caption>${n}</caption>`),
              i
            );
          };
          this.indent = function (e) {
            let t = "";
            for (let n = 0; n < e; n += 1) t += ".";
            return t;
          };
          let S = function (e, t) {
              let n = "";
              if (t.type === i.TRG) {
                if (16 === e || 32 === e) {
                  let s = t.min.toString(16).toUpperCase();
                  s.length % 2 != 0 && (s = `0${s}`),
                    (n += (16 === e ? "%x" : "U+") + s),
                    (s = t.max.toString(16).toUpperCase()).length % 2 != 0 &&
                      (s = `0${s}`),
                    (n += `&ndash;${s}`);
                } else
                  n = `%d${t.min.toString(10)}&ndash;${t.max.toString(10)}`;
              }
              return n;
            },
            C = function (e, t) {
              let n = "";
              if (t.type === i.REP) {
                if (16 === e) {
                  let e = t.min.toString(16).toUpperCase();
                  e.length % 2 != 0 && (e = `0${e}`),
                    (n = `x${e}`),
                    t.max < 1 / 0
                      ? (e = t.max.toString(16).toUpperCase()).length % 2 !=
                          0 && (e = `0${e}`)
                      : (e = "inf"),
                    (n += `&ndash;${e}`);
                } else
                  n =
                    t.max < 1 / 0
                      ? `${t.min.toString(10)}&ndash;${t.max.toString(10)}`
                      : `${t.min.toString(10)}&ndash;inf`;
              }
              return n;
            },
            B = function (e, t) {
              let n = "";
              if (t.type === i.TBS) {
                let s = Math.min(t.string.length, 10);
                if (16 === e || 32 === e) {
                  n += 16 === e ? "%x" : "U+";
                  for (let e = 0; e < s; e += 1) {
                    let s;
                    e > 0 && (n += "."),
                      (s = t.string[e].toString(16).toUpperCase()).length % 2 !=
                        0 && (s = `0${s}`),
                      (n += s);
                  }
                } else {
                  n = "%d";
                  for (let e = 0; e < s; e += 1)
                    e > 0 && (n += "."), (n += t.string[e].toString(10));
                }
                s < t.string.length && (n += w);
              }
              return n;
            },
            N = function (t, n) {
              let s = "";
              if (n.type === i.TLS) {
                let i = Math.min(n.string.length, 5);
                if (16 === t || 10 === t) {
                  let e, a, o;
                  16 === t ? ((s = "%x"), (o = 16)) : ((s = "%d"), (o = 10));
                  for (let t = 0; t < i; t += 1)
                    t > 0 && (s += "."),
                      (a = n.string[t]) >= 97 && a <= 122
                        ? ((e = a - 32),
                          (s += `${e.toString(o)}/${a.toString(
                            o
                          )}`.toUpperCase()))
                        : a >= 65 && a <= 90
                        ? ((e = a),
                          (a += 32),
                          (s += `${e.toString(o)}/${a.toString(
                            o
                          )}`.toUpperCase()))
                        : (s += a.toString(o).toUpperCase());
                  i < n.string.length && (s += w);
                } else {
                  s = '"';
                  for (let t = 0; t < i; t += 1) s += e.asciiChars[n.string[t]];
                  i < n.string.length && (s += w), (s += '"');
                }
              }
              return s;
            },
            R = function (t, n, s, i, a) {
              if (0 === i) return "";
              let o = "",
                l = a ? "," : "";
              switch (t) {
                case 16:
                  o = l + e.charsToHex(n, s, i);
                  break;
                case 10:
                  if (a) return `,${e.charsToDec(n, s, i)}`;
                  o = l + e.charsToDec(n, s, i);
                  break;
                case 32:
                  o = e.charsToUnicode(n, s, i);
                  break;
                default:
                  o = e.charsToAsciiHtml(n, s, i);
              }
              return o;
            },
            I = function (e, n, s, a, o, l) {
              let u,
                c,
                d,
                h,
                p = "",
                f = A,
                g = `<span class="${t.CLASS_LOOKBEHIND}">`,
                m = `<span class="${t.CLASS_REMAINDER}">`,
                y = "</span>",
                b = !1;
              switch (s) {
                case i.EMPTY:
                  p += v;
                case i.NOMATCH:
                case i.MATCH:
                case i.ACTIVE:
                  (c = l - (u = a - o)), (d = l), (h = n.length - d);
                  break;
                default:
                  throw Error("unrecognized state");
              }
              return (
                (f = A),
                c > 80
                  ? ((c = 80), (f = w), (h = 0))
                  : c + h > 80 && ((f = w), (h = 80 - c)),
                c > 0 && ((p += g + R(e, n, u, c, b) + y), (b = !0)),
                h > 0 && (p += m + R(e, n, d, h, b) + y),
                p + f
              );
            },
            M = function (e, n, s, a, o, l) {
              let u,
                c,
                d,
                h,
                p = "",
                f = A,
                g = `<span class="${t.CLASS_REMAINDER}">`,
                m = "</span>",
                y = !1;
              switch (s) {
                case i.EMPTY:
                  p += v;
                case i.NOMATCH:
                case i.ACTIVE:
                  (u = a), (c = 0), (d = a), (h = n.length - d);
                  break;
                case i.MATCH:
                  (u = a), (d = a + (c = o)), (h = n.length - d);
                  break;
                default:
                  throw Error("unrecognized state");
              }
              return (
                (f = A),
                c > 80
                  ? ((c = 80), (f = w), (h = 0))
                  : c + h > 80 && ((f = w), (h = 80 - c)),
                c > 0 && ((p += l + R(e, n, u, c, y) + m), (y = !0)),
                h > 0 && (p += g + R(e, n, d, h, y) + m),
                p + f
              );
            },
            L = function (n) {
              let a, u, c, d, h, p;
              if (null === g) return "";
              let y = "";
              return (
                (y +=
                  "<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th><th>operator</th><th>phrase</th></tr>\n"),
                s.forEach((s) => {
                  let b = l[s];
                  switch (
                    ((a = b.thisLine),
                    (u = void 0 !== b.thatLine ? b.thatLine : "--"),
                    (c = !1),
                    (d = !1),
                    (h = !1),
                    b.lookAround === i.LOOKAROUND_AHEAD &&
                      ((c = !0), (h = !0), (p = b.lookAnchor)),
                    (b.opcode.type === i.AND || b.opcode.type === i.NOT) &&
                      ((c = !0), (h = !0), (p = b.phraseIndex)),
                    b.lookAround === i.LOOKAROUND_BEHIND &&
                      ((d = !0), (h = !0), (p = b.lookAnchor)),
                    (b.opcode.type === i.BKA || b.opcode.type === i.BKN) &&
                      ((d = !0), (h = !0), (p = b.phraseIndex)),
                    (y += `<tr><td>${a}</td><td>${u}</td><td>${b.phraseIndex}</td><td>${b.phraseLength}</td><td>${b.depth}</td><td>`),
                    b.state)
                  ) {
                    case i.ACTIVE:
                      y += `<span class="${t.CLASS_ACTIVE}">&darr;&nbsp;</span>`;
                      break;
                    case i.MATCH:
                      y += `<span class="${t.CLASS_MATCH}">&uarr;M</span>`;
                      break;
                    case i.NOMATCH:
                      y += `<span class="${t.CLASS_NOMATCH}">&uarr;N</span>`;
                      break;
                    case i.EMPTY:
                      y += `<span class="${t.CLASS_EMPTY}">&uarr;E</span>`;
                      break;
                    default:
                      y += `<span class="${t.CLASS_ACTIVE}">--</span>`;
                  }
                  if (
                    ((y += "</td><td>" + o.indent(b.depth)),
                    c
                      ? (y += `<span class="${t.CLASS_LOOKAHEAD}">`)
                      : d && (y += `<span class="${t.CLASS_LOOKBEHIND}">`),
                    (y += e.opcodeToString(b.opcode.type)),
                    b.opcode.type === i.RNM &&
                      (y += `(${g[b.opcode.index].name}) `),
                    b.opcode.type === i.BKR)
                  ) {
                    let e = b.opcode.bkrCase === i.BKR_MODE_CI ? "%i" : "%s",
                      t = b.opcode.bkrMode === i.BKR_MODE_UM ? "%u" : "%p";
                    y += `(\\${e}${t}${g[b.opcode.index].name}) `;
                  }
                  (b.opcode.type === i.UDT &&
                    (y += `(${m[b.opcode.index].name}) `),
                  b.opcode.type === i.TRG && (y += `(${S(n, b.opcode)}) `),
                  b.opcode.type === i.TBS && (y += `(${B(n, b.opcode)}) `),
                  b.opcode.type === i.TLS && (y += `(${N(n, b.opcode)}) `),
                  b.opcode.type === i.REP && (y += `(${C(n, b.opcode)}) `),
                  h && (y += "</span>"),
                  (y += "</td><td>"),
                  d)
                    ? (y += I(n, f, b.state, b.phraseIndex, b.phraseLength, p))
                    : c
                    ? (y += M(
                        n,
                        f,
                        b.state,
                        b.phraseIndex,
                        b.phraseLength,
                        `<span class="${t.CLASS_LOOKAHEAD}">`
                      ))
                    : (y += M(
                        n,
                        f,
                        b.state,
                        b.phraseIndex,
                        b.phraseLength,
                        `<span class="${t.CLASS_MATCH}">`
                      )),
                    (y += "</td></tr>\n");
                }),
                (y +=
                  "<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th><th>operator</th><th>phrase</th></tr>\n</table>\n")
              );
            };
          this.toHtml = function (e, n) {
            let s = 8;
            if ("string" == typeof e && e.length >= 3) {
              let t = e.toLowerCase().slice(0, 3);
              "hex" === t
                ? (s = 16)
                : "dec" === t
                ? (s = 10)
                : "uni" === t && (s = 32);
            }
            return (
              O(s, n) +
              L(s) +
              "" +
              `</table>
<p class="${t.CLASS_MONOSPACE}">legend:<br>
(a)&nbsp;-&nbsp;line number<br>
(b)&nbsp;-&nbsp;matching line number<br>
(c)&nbsp;-&nbsp;phrase offset<br>
(d)&nbsp;-&nbsp;phrase length<br>
(e)&nbsp;-&nbsp;tree depth<br>
(f)&nbsp;-&nbsp;operator state<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${t.CLASS_ACTIVE}">&darr;</span>&nbsp;&nbsp;phrase opened<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${t.CLASS_MATCH}">&uarr;M</span> phrase matched<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${t.CLASS_EMPTY}">&uarr;E</span> empty phrase matched<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${t.CLASS_NOMATCH}">&uarr;N</span> phrase not matched<br>
operator&nbsp;-&nbsp;ALT, CAT, REP, RNM, TRG, TLS, TBS<sup>&dagger;</sup>, UDT, AND, NOT, BKA, BKN, BKR, ABG, AEN<sup>&Dagger;</sup><br>
phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to 80 characters of the phrase being matched<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${t.CLASS_MATCH}">matched characters</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${t.CLASS_LOOKAHEAD}">matched characters in look ahead mode</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${t.CLASS_LOOKBEHIND}">matched characters in look behind mode</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${t.CLASS_REMAINDER}">remainder characters(not yet examined by parser)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${t.CLASS_CTRLCHAR}">control characters, TAB, LF, CR, etc. (ASCII mode only)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${v} empty string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${A} end of input string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${w} input string display truncated<br>
</p>
<p class="${t.CLASS_MONOSPACE}">
<sup>&dagger;</sup>original ABNF operators:<br>
ALT - alternation<br>
CAT - concatenation<br>
REP - repetition<br>
RNM - rule name<br>
TRG - terminal range<br>
TLS - terminal literal string (case insensitive)<br>
TBS - terminal binary string (case sensitive)<br>
<br>
<sup>&Dagger;</sup>super set SABNF operators:<br>
UDT - user-defined terminal<br>
AND - positive look ahead<br>
NOT - negative look ahead<br>
BKA - positive look behind<br>
BKN - negative look behind<br>
BKR - back reference<br>
ABG - anchor - begin of input string<br>
AEN - anchor - end of input string<br>
</p>
`
            );
          };
        };
      },
      8544: function (e, t, n) {
        let s = n(93932),
          i = n(20979),
          a = n(91593),
          o = n(58276),
          l = "utilities.js: ",
          u = function (e, t, n) {
            let s;
            let i = t;
            for (;;) {
              if (e <= 0) {
                (i = 0), (s = 0);
                break;
              }
              if ("number" != typeof i) {
                (i = 0), (s = e);
                break;
              }
              if (i >= e) {
                (i = e), (s = e);
                break;
              }
              if ("number" != typeof n) {
                s = e;
                break;
              }
              (s = i + n) > e && (s = e);
              break;
            }
            return { beg: i, end: s };
          };
        (t.htmlToPage = function (e, t) {
          let n;
          if ("string" != typeof e)
            throw Error(`${l}htmlToPage: input HTML is not a string`);
          return (
            (n = "string" != typeof t ? "htmlToPage" : t),
            `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>${n}</title>
<style>
` +
              a() +
              "</style>\n</head>\n<body>\n" +
              `<p>${new Date()}</p>
` +
              e +
              "</body>\n</html>\n"
          );
        }),
          (t.parserResultToHtml = function (e, t) {
            let n,
              i,
              a = null;
            "string" == typeof t && "" !== t && (a = t),
              (n =
                !0 === e.success
                  ? `<span class="${s.CLASS_MATCH}">true</span>`
                  : `<span class="${s.CLASS_NOMATCH}">false</span>`),
              (i =
                e.state === o.EMPTY
                  ? `<span class="${s.CLASS_EMPTY}">EMPTY</span>`
                  : e.state === o.MATCH
                  ? `<span class="${s.CLASS_MATCH}">MATCH</span>`
                  : e.state === o.NOMATCH
                  ? `<span class="${s.CLASS_NOMATCH}">NOMATCH</span>`
                  : `<span class="${s.CLASS_NOMATCH}">unrecognized</span>`);
            let l = "";
            return (
              (l += `<table class="${s.CLASS_STATE}">
`),
              a &&
                (l += `<caption>${a}</caption>
`),
              (l += `<tr><th>state item</th><th>value</th><th>description</th></tr>
<tr><td>parser success</td><td>${n}</td>
<td><span class="${s.CLASS_MATCH}">true</span> if the parse succeeded,
 <span class="${s.CLASS_NOMATCH}">false</span> otherwise<br><i>NOTE: for success, entire string must be matched</i></td></tr>
<tr><td>parser state</td><td>${i}</td>
<td><span class="${s.CLASS_EMPTY}">EMPTY</span>, <span class="${s.CLASS_MATCH}">MATCH</span> or 
<span class="${s.CLASS_NOMATCH}">NOMATCH</span></td></tr>
<tr><td>string length</td><td>${e.length}</td><td>length of the input (sub)string</td></tr>
<tr><td>matched length</td><td>${e.matched}</td><td>number of input string characters matched</td></tr>
<tr><td>max matched</td><td>${e.maxMatched}</td><td>maximum number of input string characters matched</td></tr>
<tr><td>max tree depth</td><td>${e.maxTreeDepth}</td><td>maximum depth of the parse tree reached</td></tr>
<tr><td>node hits</td><td>${e.nodeHits}</td><td>number of parse tree node hits (opcode function calls)</td></tr>
<tr><td>input length</td><td>${e.inputLength}</td><td>length of full input string</td></tr>
<tr><td>sub-string begin</td><td>${e.subBegin}</td><td>sub-string first character index</td></tr>
<tr><td>sub-string end</td><td>${e.subEnd}</td><td>sub-string end-of-string index</td></tr>
<tr><td>sub-string length</td><td>${e.subLength}</td><td>sub-string length</td></tr>
</table>
`)
            );
          }),
          (t.charsToString = function (e, t, n) {
            let s, a;
            if ("number" == typeof t) {
              if (t >= e.length) return "";
              s = t < 0 ? 0 : t;
            } else s = 0;
            if ("number" == typeof n) {
              if (n <= 0) return "";
              a = n > e.length - s ? e.length : s + n;
            } else a = e.length;
            return s < a
              ? i.encode("UTF16LE", e.slice(s, a)).toString("utf16le")
              : "";
          }),
          (t.stringToChars = function (e) {
            return i.decode("STRING", e);
          }),
          (t.opcodeToString = function (e) {
            let t = "unknown";
            switch (e) {
              case o.ALT:
                t = "ALT";
                break;
              case o.CAT:
                t = "CAT";
                break;
              case o.RNM:
                t = "RNM";
                break;
              case o.UDT:
                t = "UDT";
                break;
              case o.AND:
                t = "AND";
                break;
              case o.NOT:
                t = "NOT";
                break;
              case o.REP:
                t = "REP";
                break;
              case o.TRG:
                t = "TRG";
                break;
              case o.TBS:
                t = "TBS";
                break;
              case o.TLS:
                t = "TLS";
                break;
              case o.BKR:
                t = "BKR";
                break;
              case o.BKA:
                t = "BKA";
                break;
              case o.BKN:
                t = "BKN";
                break;
              case o.ABG:
                t = "ABG";
                break;
              case o.AEN:
                t = "AEN";
                break;
              default:
                throw Error("unrecognized opcode");
            }
            return t;
          }),
          (t.stateToString = function (e) {
            let t = "unknown";
            switch (e) {
              case o.ACTIVE:
                t = "ACTIVE";
                break;
              case o.MATCH:
                t = "MATCH";
                break;
              case o.EMPTY:
                t = "EMPTY";
                break;
              case o.NOMATCH:
                t = "NOMATCH";
                break;
              default:
                throw Error("unrecognized state");
            }
            return t;
          }),
          (t.asciiChars = [
            "NUL",
            "SOH",
            "STX",
            "ETX",
            "EOT",
            "ENQ",
            "ACK",
            "BEL",
            "BS",
            "TAB",
            "LF",
            "VT",
            "FF",
            "CR",
            "SO",
            "SI",
            "DLE",
            "DC1",
            "DC2",
            "DC3",
            "DC4",
            "NAK",
            "SYN",
            "ETB",
            "CAN",
            "EM",
            "SUB",
            "ESC",
            "FS",
            "GS",
            "RS",
            "US",
            "&nbsp;",
            "!",
            "&#34;",
            "#",
            "$",
            "%",
            "&#38;",
            "&#39;",
            "(",
            ")",
            "*",
            "+",
            ",",
            "-",
            ".",
            "/",
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            ":",
            ";",
            "&#60;",
            "=",
            "&#62;",
            "?",
            "@",
            "A",
            "B",
            "C",
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
            "L",
            "M",
            "N",
            "O",
            "P",
            "Q",
            "R",
            "S",
            "T",
            "U",
            "V",
            "W",
            "X",
            "Y",
            "Z",
            "[",
            "&#92;",
            "]",
            "^",
            "_",
            "`",
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "i",
            "j",
            "k",
            "l",
            "m",
            "n",
            "o",
            "p",
            "q",
            "r",
            "s",
            "t",
            "u",
            "v",
            "w",
            "x",
            "y",
            "z",
            "{",
            "|",
            "}",
            "~",
            "DEL",
          ]),
          (t.charToHex = function (e) {
            let t = e.toString(16).toUpperCase();
            switch (t.length) {
              case 1:
              case 3:
              case 7:
                t = `0${t}`;
                break;
              case 2:
              case 6:
                t = `00${t}`;
                break;
              case 4:
                break;
              case 5:
                t = `000${t}`;
                break;
              default:
                throw Error("unrecognized option");
            }
            return t;
          }),
          (t.charsToDec = function (e, t, n) {
            let s = "";
            if (!Array.isArray(e))
              throw Error(`${l}charsToDec: input must be an array of integers`);
            let i = u(e.length, t, n);
            if (i.end > i.beg) {
              s += e[i.beg];
              for (let t = i.beg + 1; t < i.end; t += 1) s += `,${e[t]}`;
            }
            return s;
          }),
          (t.charsToHex = function (e, n, s) {
            let i = "";
            if (!Array.isArray(e))
              throw Error(`${l}charsToHex: input must be an array of integers`);
            let a = u(e.length, n, s);
            if (a.end > a.beg) {
              i += `\\x${t.charToHex(e[a.beg])}`;
              for (let n = a.beg + 1; n < a.end; n += 1)
                i += `,\\x${t.charToHex(e[n])}`;
            }
            return i;
          }),
          (t.charsToHtmlEntities = function (e, t, n) {
            let s = "";
            if (!Array.isArray(e))
              throw Error(`${l}charsToHex: input must be an array of integers`);
            let i = u(e.length, t, n);
            if (i.end > i.beg)
              for (let t = i.beg; t < i.end; t += 1)
                s += `&#x${e[t].toString(16)};`;
            return s;
          }),
          (t.charsToUnicode = function (e, n, s) {
            let i = "";
            if (!Array.isArray(e))
              throw Error(
                `${l}charsToUnicode: input must be an array of integers`
              );
            let a = u(e.length, n, s);
            if (a.end > a.beg)
              for (let n = a.beg; n < a.end; n += 1) {
                var o;
                (((o = e[n]) >= 55296 && o <= 57343) || o > 1114111 ? 1 : 0)
                  ? (i += ` U+${t.charToHex(e[n])}`)
                  : (i += `&#${e[n]};`);
              }
            return i;
          }),
          (t.charsToJsUnicode = function (e, n, s) {
            let i = "";
            if (!Array.isArray(e))
              throw Error(
                `${l}charsToJsUnicode: input must be an array of integers`
              );
            let a = u(e.length, n, s);
            if (a.end > a.beg) {
              i += `\\u${t.charToHex(e[a.beg])}`;
              for (let n = a.beg + 1; n < a.end; n += 1)
                i += `,\\u${t.charToHex(e[n])}`;
            }
            return i;
          }),
          (t.charsToAscii = function (e, n, s) {
            let i = "";
            if (!Array.isArray(e))
              throw Error(
                `${l}charsToAscii: input must be an array of integers`
              );
            let a = u(e.length, n, s);
            for (let n = a.beg; n < a.end; n += 1) {
              let s = e[n];
              s >= 32 && s <= 126
                ? (i += String.fromCharCode(s))
                : (i += `\\x${t.charToHex(s)}`);
            }
            return i;
          }),
          (t.charsToAsciiHtml = function (e, n, i) {
            let a;
            if (!Array.isArray(e))
              throw Error(
                `${l}charsToAsciiHtml: input must be an array of integers`
              );
            let o = "",
              c = u(e.length, n, i);
            for (let n = c.beg; n < c.end; n += 1)
              (a = e[n]) < 32 || 127 === a
                ? (o += `<span class="${s.CLASS_CTRLCHAR}">${t.asciiChars[a]}</span>`)
                : a > 127
                ? (o += `<span class="${s.CLASS_CTRLCHAR}">U+${t.charToHex(
                    a
                  )}</span>`)
                : (o += t.asciiChars[a]);
            return o;
          }),
          (t.stringToAsciiHtml = function (e) {
            let t = i.decode("STRING", e);
            return this.charsToAsciiHtml(t);
          });
      },
      50079: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createCurve = t.getHash = void 0);
        let s = n(60798),
          i = n(29681),
          a = n(12541);
        function o(e) {
          return {
            hash: e,
            hmac: (t, ...n) => (0, s.hmac)(e, t, (0, i.concatBytes)(...n)),
            randomBytes: i.randomBytes,
          };
        }
        (t.getHash = o),
          (t.createCurve = function (e, t) {
            let n = (t) => (0, a.weierstrass)({ ...e, ...o(t) });
            return Object.freeze({ ...n(t), create: n });
          });
      },
      92781: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.validateBasic = t.wNAF = void 0);
        let s = n(23570),
          i = n(43912),
          a = BigInt(0),
          o = BigInt(1);
        (t.wNAF = function (e, t) {
          let n = (e, t) => {
              let n = t.negate();
              return e ? n : t;
            },
            s = (e) => ({
              windows: Math.ceil(t / e) + 1,
              windowSize: 2 ** (e - 1),
            });
          return {
            constTimeNegate: n,
            unsafeLadder(t, n) {
              let s = e.ZERO,
                i = t;
              for (; n > a; )
                n & o && (s = s.add(i)), (i = i.double()), (n >>= o);
              return s;
            },
            precomputeWindow(e, t) {
              let { windows: n, windowSize: i } = s(t),
                a = [],
                o = e,
                l = o;
              for (let e = 0; e < n; e++) {
                (l = o), a.push(l);
                for (let e = 1; e < i; e++) (l = l.add(o)), a.push(l);
                o = l.double();
              }
              return a;
            },
            wNAF(t, i, a) {
              let { windows: l, windowSize: u } = s(t),
                c = e.ZERO,
                d = e.BASE,
                h = BigInt(2 ** t - 1),
                p = 2 ** t,
                f = BigInt(t);
              for (let e = 0; e < l; e++) {
                let t = e * u,
                  s = Number(a & h);
                (a >>= f), s > u && ((s -= p), (a += o));
                let l = t + Math.abs(s) - 1,
                  g = e % 2 != 0,
                  m = s < 0;
                0 === s ? (d = d.add(n(g, i[t]))) : (c = c.add(n(m, i[l])));
              }
              return { p: c, f: d };
            },
            wNAFCached(e, t, n, s) {
              let i = e._WINDOW_SIZE || 1,
                a = t.get(e);
              return (
                a ||
                  ((a = this.precomputeWindow(e, i)),
                  1 !== i && t.set(e, s(a))),
                this.wNAF(i, a, n)
              );
            },
          };
        }),
          (t.validateBasic = function (e) {
            return (
              (0, s.validateField)(e.Fp),
              (0, i.validateObject)(
                e,
                { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
                { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
              ),
              Object.freeze({
                ...(0, s.nLength)(e.n, e.nBitLength),
                ...e,
                p: e.Fp.ORDER,
              })
            );
          });
      },
      6791: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createHasher =
            t.isogenyMap =
            t.hash_to_field =
            t.expand_message_xof =
            t.expand_message_xmd =
              void 0);
        let s = n(23570),
          i = n(43912),
          a = i.bytesToNumberBE;
        function o(e, t) {
          if (e < 0 || e >= 1 << (8 * t))
            throw Error(`bad I2OSP call: value=${e} length=${t}`);
          let n = Array.from({ length: t }).fill(0);
          for (let s = t - 1; s >= 0; s--) (n[s] = 255 & e), (e >>>= 8);
          return new Uint8Array(n);
        }
        function l(e) {
          if (!(e instanceof Uint8Array)) throw Error("Uint8Array expected");
        }
        function u(e) {
          if (!Number.isSafeInteger(e)) throw Error("number expected");
        }
        function c(e, t, n, s) {
          l(e),
            l(t),
            u(n),
            t.length > 255 &&
              (t = s(
                (0, i.concatBytes)((0, i.utf8ToBytes)("H2C-OVERSIZE-DST-"), t)
              ));
          let { outputLen: a, blockLen: c } = s,
            d = Math.ceil(n / a);
          if (d > 255) throw Error("Invalid xmd length");
          let h = (0, i.concatBytes)(t, o(t.length, 1)),
            p = o(0, c),
            f = o(n, 2),
            g = Array(d),
            m = s((0, i.concatBytes)(p, e, f, o(0, 1), h));
          g[0] = s((0, i.concatBytes)(m, o(1, 1), h));
          for (let e = 1; e <= d; e++) {
            let t = [
              (function (e, t) {
                let n = new Uint8Array(e.length);
                for (let s = 0; s < e.length; s++) n[s] = e[s] ^ t[s];
                return n;
              })(m, g[e - 1]),
              o(e + 1, 1),
              h,
            ];
            g[e] = s((0, i.concatBytes)(...t));
          }
          return (0, i.concatBytes)(...g).slice(0, n);
        }
        function d(e, t, n, s, a) {
          if (
            (l(e),
            l(t),
            u(n),
            t.length > 255 &&
              (t = a
                .create({ dkLen: Math.ceil((2 * s) / 8) })
                .update((0, i.utf8ToBytes)("H2C-OVERSIZE-DST-"))
                .update(t)
                .digest()),
            n > 65535 || t.length > 255)
          )
            throw Error("expand_message_xof: invalid lenInBytes");
          return a
            .create({ dkLen: n })
            .update(e)
            .update(o(n, 2))
            .update(t)
            .update(o(t.length, 1))
            .digest();
        }
        function h(e, t, n) {
          let o;
          (0, i.validateObject)(n, {
            DST: "stringOrUint8Array",
            p: "bigint",
            m: "isSafeInteger",
            k: "isSafeInteger",
            hash: "hash",
          });
          let { p: h, k: p, m: f, hash: g, expand: m, DST: y } = n;
          l(e), u(t);
          let b = (function (e) {
              if (e instanceof Uint8Array) return e;
              if ("string" == typeof e) return (0, i.utf8ToBytes)(e);
              throw Error("DST must be Uint8Array or string");
            })(y),
            A = Math.ceil((h.toString(2).length + p) / 8),
            w = t * f * A;
          if ("xmd" === m) o = c(e, b, w, g);
          else if ("xof" === m) o = d(e, b, w, p, g);
          else if ("_internal_pass" === m) o = e;
          else throw Error('expand must be "xmd" or "xof"');
          let v = Array(t);
          for (let e = 0; e < t; e++) {
            let t = Array(f);
            for (let n = 0; n < f; n++) {
              let i = A * (n + e * f),
                l = o.subarray(i, i + A);
              t[n] = (0, s.mod)(a(l), h);
            }
            v[e] = t;
          }
          return v;
        }
        (t.expand_message_xmd = c),
          (t.expand_message_xof = d),
          (t.hash_to_field = h),
          (t.isogenyMap = function (e, t) {
            let n = t.map((e) => Array.from(e).reverse());
            return (t, s) => {
              let [i, a, o, l] = n.map((n) =>
                n.reduce((n, s) => e.add(e.mul(n, t), s))
              );
              return (
                (t = e.div(i, a)), (s = e.mul(s, e.div(o, l))), { x: t, y: s }
              );
            };
          }),
          (t.createHasher = function (e, t, n) {
            if ("function" != typeof t)
              throw Error("mapToCurve() must be defined");
            return {
              hashToCurve(s, i) {
                let a = h(s, 2, { ...n, DST: n.DST, ...i }),
                  o = e.fromAffine(t(a[0])),
                  l = e.fromAffine(t(a[1])),
                  u = o.add(l).clearCofactor();
                return u.assertValidity(), u;
              },
              encodeToCurve(s, i) {
                let a = h(s, 1, { ...n, DST: n.encodeDST, ...i }),
                  o = e.fromAffine(t(a[0])).clearCofactor();
                return o.assertValidity(), o;
              },
            };
          });
      },
      23570: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.mapHashToField =
            t.getMinHashLength =
            t.getFieldBytesLength =
            t.hashToPrivateScalar =
            t.FpSqrtEven =
            t.FpSqrtOdd =
            t.Field =
            t.nLength =
            t.FpIsSquare =
            t.FpDiv =
            t.FpInvertBatch =
            t.FpPow =
            t.validateField =
            t.isNegativeLE =
            t.FpSqrt =
            t.tonelliShanks =
            t.invert =
            t.pow2 =
            t.pow =
            t.mod =
              void 0);
        let s = n(43912),
          i = BigInt(0),
          a = BigInt(1),
          o = BigInt(2),
          l = BigInt(3),
          u = BigInt(4),
          c = BigInt(5),
          d = BigInt(8);
        function h(e, t) {
          let n = e % t;
          return n >= i ? n : t + n;
        }
        function p(e, t, n) {
          if (n <= i || t < i) throw Error("Expected power/modulo > 0");
          if (n === a) return i;
          let s = a;
          for (; t > i; )
            t & a && (s = (s * e) % n), (e = (e * e) % n), (t >>= a);
          return s;
        }
        function f(e, t) {
          if (e === i || t <= i)
            throw Error(
              `invert: expected positive integers, got n=${e} mod=${t}`
            );
          let n = h(e, t),
            s = t,
            o = i,
            l = a,
            u = a,
            c = i;
          for (; n !== i; ) {
            let e = s / n,
              t = s % n,
              i = o - u * e,
              a = l - c * e;
            (s = n), (n = t), (o = u), (l = c), (u = i), (c = a);
          }
          if (s !== a) throw Error("invert: does not exist");
          return h(o, t);
        }
        function g(e) {
          let t, n, s;
          let l = (e - a) / o;
          for (t = e - a, n = 0; t % o === i; t /= o, n++);
          for (s = o; s < e && p(s, l, e) !== e - a; s++);
          if (1 === n) {
            let t = (e + a) / u;
            return function (e, n) {
              let s = e.pow(n, t);
              if (!e.eql(e.sqr(s), n)) throw Error("Cannot find square root");
              return s;
            };
          }
          let c = (t + a) / o;
          return function (e, i) {
            if (e.pow(i, l) === e.neg(e.ONE))
              throw Error("Cannot find square root");
            let o = n,
              u = e.pow(e.mul(e.ONE, s), t),
              d = e.pow(i, c),
              h = e.pow(i, t);
            for (; !e.eql(h, e.ONE); ) {
              if (e.eql(h, e.ZERO)) return e.ZERO;
              let t = 1;
              for (let n = e.sqr(h); t < o && !e.eql(n, e.ONE); t++)
                n = e.sqr(n);
              let n = e.pow(u, a << BigInt(o - t - 1));
              (u = e.sqr(n)), (d = e.mul(d, n)), (h = e.mul(h, u)), (o = t);
            }
            return d;
          };
        }
        function m(e) {
          if (e % u === l) {
            let t = (e + a) / u;
            return function (e, n) {
              let s = e.pow(n, t);
              if (!e.eql(e.sqr(s), n)) throw Error("Cannot find square root");
              return s;
            };
          }
          if (e % d === c) {
            let t = (e - c) / d;
            return function (e, n) {
              let s = e.mul(n, o),
                i = e.pow(s, t),
                a = e.mul(n, i),
                l = e.mul(e.mul(a, o), i),
                u = e.mul(a, e.sub(l, e.ONE));
              if (!e.eql(e.sqr(u), n)) throw Error("Cannot find square root");
              return u;
            };
          }
          return g(e);
        }
        BigInt(9),
          BigInt(16),
          (t.mod = h),
          (t.pow = p),
          (t.pow2 = function (e, t, n) {
            let s = e;
            for (; t-- > i; ) (s *= s), (s %= n);
            return s;
          }),
          (t.invert = f),
          (t.tonelliShanks = g),
          (t.FpSqrt = m),
          (t.isNegativeLE = (e, t) => (h(e, t) & a) === a);
        let y = [
          "create",
          "isValid",
          "is0",
          "neg",
          "inv",
          "sqrt",
          "sqr",
          "eql",
          "add",
          "sub",
          "mul",
          "pow",
          "div",
          "addN",
          "subN",
          "mulN",
          "sqrN",
        ];
        function b(e, t, n) {
          if (n < i) throw Error("Expected power > 0");
          if (n === i) return e.ONE;
          if (n === a) return t;
          let s = e.ONE,
            o = t;
          for (; n > i; ) n & a && (s = e.mul(s, o)), (o = e.sqr(o)), (n >>= a);
          return s;
        }
        function A(e, t) {
          let n = Array(t.length),
            s = t.reduce(
              (t, s, i) => (e.is0(s) ? t : ((n[i] = t), e.mul(t, s))),
              e.ONE
            ),
            i = e.inv(s);
          return (
            t.reduceRight(
              (t, s, i) =>
                e.is0(s) ? t : ((n[i] = e.mul(t, n[i])), e.mul(t, s)),
              i
            ),
            n
          );
        }
        function w(e, t) {
          let n = void 0 !== t ? t : e.toString(2).length;
          return { nBitLength: n, nByteLength: Math.ceil(n / 8) };
        }
        function v(e) {
          if ("bigint" != typeof e) throw Error("field order must be bigint");
          return Math.ceil(e.toString(2).length / 8);
        }
        function E(e) {
          let t = v(e);
          return t + Math.ceil(t / 2);
        }
        (t.validateField = function (e) {
          let t = y.reduce((e, t) => ((e[t] = "function"), e), {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger",
          });
          return (0, s.validateObject)(e, t);
        }),
          (t.FpPow = b),
          (t.FpInvertBatch = A),
          (t.FpDiv = function (e, t, n) {
            return e.mul(t, "bigint" == typeof n ? f(n, e.ORDER) : e.inv(n));
          }),
          (t.FpIsSquare = function (e) {
            let t = (e.ORDER - a) / o;
            return (n) => {
              let s = e.pow(n, t);
              return e.eql(s, e.ZERO) || e.eql(s, e.ONE);
            };
          }),
          (t.nLength = w),
          (t.Field = function (e, t, n = !1, o = {}) {
            if (e <= i) throw Error(`Expected Field ORDER > 0, got ${e}`);
            let { nBitLength: l, nByteLength: u } = w(e, t);
            if (u > 2048)
              throw Error("Field lengths over 2048 bytes are not supported");
            let c = m(e),
              d = Object.freeze({
                ORDER: e,
                BITS: l,
                BYTES: u,
                MASK: (0, s.bitMask)(l),
                ZERO: i,
                ONE: a,
                create: (t) => h(t, e),
                isValid: (t) => {
                  if ("bigint" != typeof t)
                    throw Error(
                      `Invalid field element: expected bigint, got ${typeof t}`
                    );
                  return i <= t && t < e;
                },
                is0: (e) => e === i,
                isOdd: (e) => (e & a) === a,
                neg: (t) => h(-t, e),
                eql: (e, t) => e === t,
                sqr: (t) => h(t * t, e),
                add: (t, n) => h(t + n, e),
                sub: (t, n) => h(t - n, e),
                mul: (t, n) => h(t * n, e),
                pow: (e, t) => b(d, e, t),
                div: (t, n) => h(t * f(n, e), e),
                sqrN: (e) => e * e,
                addN: (e, t) => e + t,
                subN: (e, t) => e - t,
                mulN: (e, t) => e * t,
                inv: (t) => f(t, e),
                sqrt: o.sqrt || ((e) => c(d, e)),
                invertBatch: (e) => A(d, e),
                cmov: (e, t, n) => (n ? t : e),
                toBytes: (e) =>
                  n
                    ? (0, s.numberToBytesLE)(e, u)
                    : (0, s.numberToBytesBE)(e, u),
                fromBytes: (e) => {
                  if (e.length !== u)
                    throw Error(`Fp.fromBytes: expected ${u}, got ${e.length}`);
                  return n
                    ? (0, s.bytesToNumberLE)(e)
                    : (0, s.bytesToNumberBE)(e);
                },
              });
            return Object.freeze(d);
          }),
          (t.FpSqrtOdd = function (e, t) {
            if (!e.isOdd) throw Error("Field doesn't have isOdd");
            let n = e.sqrt(t);
            return e.isOdd(n) ? n : e.neg(n);
          }),
          (t.FpSqrtEven = function (e, t) {
            if (!e.isOdd) throw Error("Field doesn't have isOdd");
            let n = e.sqrt(t);
            return e.isOdd(n) ? e.neg(n) : n;
          }),
          (t.hashToPrivateScalar = function (e, t, n = !1) {
            let i = (e = (0, s.ensureBytes)("privateHash", e)).length,
              o = w(t).nByteLength + 8;
            if (o < 24 || i < o || i > 1024)
              throw Error(
                `hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${i}`
              );
            return (
              h(
                n ? (0, s.bytesToNumberLE)(e) : (0, s.bytesToNumberBE)(e),
                t - a
              ) + a
            );
          }),
          (t.getFieldBytesLength = v),
          (t.getMinHashLength = E),
          (t.mapHashToField = function (e, t, n = !1) {
            let i = e.length,
              o = v(t),
              l = E(t);
            if (i < 16 || i < l || i > 1024)
              throw Error(`expected ${l}-1024 bytes of input, got ${i}`);
            let u =
              h(
                n ? (0, s.bytesToNumberBE)(e) : (0, s.bytesToNumberLE)(e),
                t - a
              ) + a;
            return n
              ? (0, s.numberToBytesLE)(u, o)
              : (0, s.numberToBytesBE)(u, o);
          });
      },
      43912: function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.validateObject =
            t.createHmacDrbg =
            t.bitMask =
            t.bitSet =
            t.bitGet =
            t.bitLen =
            t.utf8ToBytes =
            t.equalBytes =
            t.concatBytes =
            t.ensureBytes =
            t.numberToVarBytesBE =
            t.numberToBytesLE =
            t.numberToBytesBE =
            t.bytesToNumberLE =
            t.bytesToNumberBE =
            t.hexToBytes =
            t.hexToNumber =
            t.numberToHexUnpadded =
            t.bytesToHex =
              void 0);
        let n = BigInt(0),
          s = BigInt(1),
          i = BigInt(2),
          a = (e) => e instanceof Uint8Array,
          o = Array.from({ length: 256 }, (e, t) =>
            t.toString(16).padStart(2, "0")
          );
        function l(e) {
          if (!a(e)) throw Error("Uint8Array expected");
          let t = "";
          for (let n = 0; n < e.length; n++) t += o[e[n]];
          return t;
        }
        function u(e) {
          let t = e.toString(16);
          return 1 & t.length ? `0${t}` : t;
        }
        function c(e) {
          if ("string" != typeof e)
            throw Error("hex string expected, got " + typeof e);
          return BigInt("" === e ? "0" : `0x${e}`);
        }
        function d(e) {
          if ("string" != typeof e)
            throw Error("hex string expected, got " + typeof e);
          let t = e.length;
          if (t % 2)
            throw Error(
              "padded hex string expected, got unpadded hex of length " + t
            );
          let n = new Uint8Array(t / 2);
          for (let t = 0; t < n.length; t++) {
            let s = 2 * t,
              i = Number.parseInt(e.slice(s, s + 2), 16);
            if (Number.isNaN(i) || i < 0) throw Error("Invalid byte sequence");
            n[t] = i;
          }
          return n;
        }
        function h(e, t) {
          return d(e.toString(16).padStart(2 * t, "0"));
        }
        function p(...e) {
          let t = new Uint8Array(e.reduce((e, t) => e + t.length, 0)),
            n = 0;
          return (
            e.forEach((e) => {
              if (!a(e)) throw Error("Uint8Array expected");
              t.set(e, n), (n += e.length);
            }),
            t
          );
        }
        (t.bytesToHex = l),
          (t.numberToHexUnpadded = u),
          (t.hexToNumber = c),
          (t.hexToBytes = d),
          (t.bytesToNumberBE = function (e) {
            return c(l(e));
          }),
          (t.bytesToNumberLE = function (e) {
            if (!a(e)) throw Error("Uint8Array expected");
            return c(l(Uint8Array.from(e).reverse()));
          }),
          (t.numberToBytesBE = h),
          (t.numberToBytesLE = function (e, t) {
            return h(e, t).reverse();
          }),
          (t.numberToVarBytesBE = function (e) {
            return d(u(e));
          }),
          (t.ensureBytes = function (e, t, n) {
            let s;
            if ("string" == typeof t)
              try {
                s = d(t);
              } catch (n) {
                throw Error(
                  `${e} must be valid hex string, got "${t}". Cause: ${n}`
                );
              }
            else if (a(t)) s = Uint8Array.from(t);
            else throw Error(`${e} must be hex string or Uint8Array`);
            let i = s.length;
            if ("number" == typeof n && i !== n)
              throw Error(`${e} expected ${n} bytes, got ${i}`);
            return s;
          }),
          (t.concatBytes = p),
          (t.equalBytes = function (e, t) {
            if (e.length !== t.length) return !1;
            for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
            return !0;
          }),
          (t.utf8ToBytes = function (e) {
            if ("string" != typeof e)
              throw Error(`utf8ToBytes expected string, got ${typeof e}`);
            return new Uint8Array(new TextEncoder().encode(e));
          }),
          (t.bitLen = function (e) {
            let t;
            for (t = 0; e > n; e >>= s, t += 1);
            return t;
          }),
          (t.bitGet = function (e, t) {
            return (e >> BigInt(t)) & s;
          }),
          (t.bitSet = (e, t, i) => e | ((i ? s : n) << BigInt(t))),
          (t.bitMask = (e) => (i << BigInt(e - 1)) - s);
        let f = (e) => new Uint8Array(e),
          g = (e) => Uint8Array.from(e);
        t.createHmacDrbg = function (e, t, n) {
          if ("number" != typeof e || e < 2)
            throw Error("hashLen must be a number");
          if ("number" != typeof t || t < 2)
            throw Error("qByteLen must be a number");
          if ("function" != typeof n) throw Error("hmacFn must be a function");
          let s = f(e),
            i = f(e),
            a = 0,
            o = () => {
              s.fill(1), i.fill(0), (a = 0);
            },
            l = (...e) => n(i, s, ...e),
            u = (e = f()) => {
              (i = l(g([0]), e)),
                (s = l()),
                0 !== e.length && ((i = l(g([1]), e)), (s = l()));
            },
            c = () => {
              if (a++ >= 1e3) throw Error("drbg: tried 1000 values");
              let e = 0,
                n = [];
              for (; e < t; ) {
                let t = (s = l()).slice();
                n.push(t), (e += s.length);
              }
              return p(...n);
            };
          return (e, t) => {
            let n;
            for (o(), u(e); !(n = t(c())); ) u();
            return o(), n;
          };
        };
        let m = {
          bigint: (e) => "bigint" == typeof e,
          function: (e) => "function" == typeof e,
          boolean: (e) => "boolean" == typeof e,
          string: (e) => "string" == typeof e,
          stringOrUint8Array: (e) =>
            "string" == typeof e || e instanceof Uint8Array,
          isSafeInteger: (e) => Number.isSafeInteger(e),
          array: (e) => Array.isArray(e),
          field: (e, t) => t.Fp.isValid(e),
          hash: (e) =>
            "function" == typeof e && Number.isSafeInteger(e.outputLen),
        };
        t.validateObject = function (e, t, n = {}) {
          let s = (t, n, s) => {
            let i = m[n];
            if ("function" != typeof i)
              throw Error(`Invalid validator "${n}", expected function`);
            let a = e[t];
            if ((!s || void 0 !== a) && !i(a, e))
              throw Error(
                `Invalid param ${String(t)}=${a} (${typeof a}), expected ${n}`
              );
          };
          for (let [e, n] of Object.entries(t)) s(e, n, !1);
          for (let [e, t] of Object.entries(n)) s(e, t, !0);
          return e;
        };
      },
      12541: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.mapToCurveSimpleSWU =
            t.SWUFpSqrtRatio =
            t.weierstrass =
            t.weierstrassPoints =
            t.DER =
              void 0);
        let s = n(23570),
          i = n(43912),
          a = n(43912),
          o = n(92781),
          { bytesToNumberBE: l, hexToBytes: u } = i;
        t.DER = {
          Err: class extends Error {
            constructor(e = "") {
              super(e);
            }
          },
          _parseInt(e) {
            let { Err: n } = t.DER;
            if (e.length < 2 || 2 !== e[0])
              throw new n("Invalid signature integer tag");
            let s = e[1],
              i = e.subarray(2, s + 2);
            if (!s || i.length !== s)
              throw new n("Invalid signature integer: wrong length");
            if (128 & i[0]) throw new n("Invalid signature integer: negative");
            if (0 === i[0] && !(128 & i[1]))
              throw new n(
                "Invalid signature integer: unnecessary leading zero"
              );
            return { d: l(i), l: e.subarray(s + 2) };
          },
          toSig(e) {
            let { Err: n } = t.DER,
              s = "string" == typeof e ? u(e) : e;
            if (!(s instanceof Uint8Array)) throw Error("ui8a expected");
            let i = s.length;
            if (i < 2 || 48 != s[0]) throw new n("Invalid signature tag");
            if (s[1] !== i - 2)
              throw new n("Invalid signature: incorrect length");
            let { d: a, l: o } = t.DER._parseInt(s.subarray(2)),
              { d: l, l: c } = t.DER._parseInt(o);
            if (c.length)
              throw new n("Invalid signature: left bytes after parsing");
            return { r: a, s: l };
          },
          hexFromSig(e) {
            let t = (e) => (8 & Number.parseInt(e[0], 16) ? "00" + e : e),
              n = (e) => {
                let t = e.toString(16);
                return 1 & t.length ? `0${t}` : t;
              },
              s = t(n(e.s)),
              i = t(n(e.r)),
              a = s.length / 2,
              o = i.length / 2,
              l = n(a),
              u = n(o);
            return `30${n(o + a + 4)}02${u}${i}02${l}${s}`;
          },
        };
        let c = BigInt(0),
          d = BigInt(1),
          h = BigInt(2),
          p = BigInt(3),
          f = BigInt(4);
        function g(e) {
          let t = (function (e) {
              let t = (0, o.validateBasic)(e);
              i.validateObject(
                t,
                { a: "field", b: "field" },
                {
                  allowedPrivateKeyLengths: "array",
                  wrapPrivateKey: "boolean",
                  isTorsionFree: "function",
                  clearCofactor: "function",
                  allowInfinityPoint: "boolean",
                  fromBytes: "function",
                  toBytes: "function",
                }
              );
              let { endo: n, Fp: s, a } = t;
              if (n) {
                if (!s.eql(a, s.ZERO))
                  throw Error(
                    "Endomorphism can only be defined for Koblitz curves that have a=0"
                  );
                if (
                  "object" != typeof n ||
                  "bigint" != typeof n.beta ||
                  "function" != typeof n.splitScalar
                )
                  throw Error(
                    "Expected endomorphism with beta: bigint and splitScalar: function"
                  );
              }
              return Object.freeze({ ...t });
            })(e),
            { Fp: n } = t,
            l =
              t.toBytes ||
              ((e, t, s) => {
                let a = t.toAffine();
                return i.concatBytes(
                  Uint8Array.from([4]),
                  n.toBytes(a.x),
                  n.toBytes(a.y)
                );
              }),
            u =
              t.fromBytes ||
              ((e) => {
                let t = e.subarray(1);
                return {
                  x: n.fromBytes(t.subarray(0, n.BYTES)),
                  y: n.fromBytes(t.subarray(n.BYTES, 2 * n.BYTES)),
                };
              });
          function h(e) {
            let { a: s, b: i } = t,
              a = n.sqr(e),
              o = n.mul(a, e);
            return n.add(n.add(o, n.mul(e, s)), i);
          }
          if (!n.eql(n.sqr(t.Gy), h(t.Gx)))
            throw Error("bad generator point: equation left != right");
          function f(e) {
            return "bigint" == typeof e && c < e && e < t.n;
          }
          function g(e) {
            if (!f(e))
              throw Error("Expected valid bigint: 0 < bigint < curve.n");
          }
          function m(e) {
            let n;
            let {
              allowedPrivateKeyLengths: o,
              nByteLength: l,
              wrapPrivateKey: u,
              n: c,
            } = t;
            if (o && "bigint" != typeof e) {
              if (
                (e instanceof Uint8Array && (e = i.bytesToHex(e)),
                "string" != typeof e || !o.includes(e.length))
              )
                throw Error("Invalid key");
              e = e.padStart(2 * l, "0");
            }
            try {
              n =
                "bigint" == typeof e
                  ? e
                  : i.bytesToNumberBE((0, a.ensureBytes)("private key", e, l));
            } catch (t) {
              throw Error(
                `private key must be ${l} bytes, hex or bigint, not ${typeof e}`
              );
            }
            return u && (n = s.mod(n, c)), g(n), n;
          }
          let y = new Map();
          function b(e) {
            if (!(e instanceof A)) throw Error("ProjectivePoint expected");
          }
          class A {
            constructor(e, t, s) {
              if (
                ((this.px = e),
                (this.py = t),
                (this.pz = s),
                null == e || !n.isValid(e))
              )
                throw Error("x required");
              if (null == t || !n.isValid(t)) throw Error("y required");
              if (null == s || !n.isValid(s)) throw Error("z required");
            }
            static fromAffine(e) {
              let { x: t, y: s } = e || {};
              if (!e || !n.isValid(t) || !n.isValid(s))
                throw Error("invalid affine point");
              if (e instanceof A) throw Error("projective point not allowed");
              let i = (e) => n.eql(e, n.ZERO);
              return i(t) && i(s) ? A.ZERO : new A(t, s, n.ONE);
            }
            get x() {
              return this.toAffine().x;
            }
            get y() {
              return this.toAffine().y;
            }
            static normalizeZ(e) {
              let t = n.invertBatch(e.map((e) => e.pz));
              return e.map((e, n) => e.toAffine(t[n])).map(A.fromAffine);
            }
            static fromHex(e) {
              let t = A.fromAffine(u((0, a.ensureBytes)("pointHex", e)));
              return t.assertValidity(), t;
            }
            static fromPrivateKey(e) {
              return A.BASE.multiply(m(e));
            }
            _setWindowSize(e) {
              (this._WINDOW_SIZE = e), y.delete(this);
            }
            assertValidity() {
              if (this.is0()) {
                if (t.allowInfinityPoint && !n.is0(this.py)) return;
                throw Error("bad point: ZERO");
              }
              let { x: e, y: s } = this.toAffine();
              if (!n.isValid(e) || !n.isValid(s))
                throw Error("bad point: x or y not FE");
              let i = n.sqr(s),
                a = h(e);
              if (!n.eql(i, a))
                throw Error("bad point: equation left != right");
              if (!this.isTorsionFree())
                throw Error("bad point: not in prime-order subgroup");
            }
            hasEvenY() {
              let { y: e } = this.toAffine();
              if (n.isOdd) return !n.isOdd(e);
              throw Error("Field doesn't support isOdd");
            }
            equals(e) {
              b(e);
              let { px: t, py: s, pz: i } = this,
                { px: a, py: o, pz: l } = e,
                u = n.eql(n.mul(t, l), n.mul(a, i)),
                c = n.eql(n.mul(s, l), n.mul(o, i));
              return u && c;
            }
            negate() {
              return new A(this.px, n.neg(this.py), this.pz);
            }
            double() {
              let { a: e, b: s } = t,
                i = n.mul(s, p),
                { px: a, py: o, pz: l } = this,
                u = n.ZERO,
                c = n.ZERO,
                d = n.ZERO,
                h = n.mul(a, a),
                f = n.mul(o, o),
                g = n.mul(l, l),
                m = n.mul(a, o);
              return (
                (m = n.add(m, m)),
                (d = n.mul(a, l)),
                (d = n.add(d, d)),
                (u = n.mul(e, d)),
                (c = n.mul(i, g)),
                (c = n.add(u, c)),
                (u = n.sub(f, c)),
                (c = n.add(f, c)),
                (c = n.mul(u, c)),
                (u = n.mul(m, u)),
                (d = n.mul(i, d)),
                (g = n.mul(e, g)),
                (m = n.sub(h, g)),
                (m = n.mul(e, m)),
                (m = n.add(m, d)),
                (d = n.add(h, h)),
                (h = n.add(d, h)),
                (h = n.add(h, g)),
                (h = n.mul(h, m)),
                (c = n.add(c, h)),
                (g = n.mul(o, l)),
                (g = n.add(g, g)),
                (h = n.mul(g, m)),
                (u = n.sub(u, h)),
                (d = n.mul(g, f)),
                (d = n.add(d, d)),
                new A(u, c, (d = n.add(d, d)))
              );
            }
            add(e) {
              b(e);
              let { px: s, py: i, pz: a } = this,
                { px: o, py: l, pz: u } = e,
                c = n.ZERO,
                d = n.ZERO,
                h = n.ZERO,
                f = t.a,
                g = n.mul(t.b, p),
                m = n.mul(s, o),
                y = n.mul(i, l),
                w = n.mul(a, u),
                v = n.add(s, i),
                E = n.add(o, l);
              (v = n.mul(v, E)),
                (E = n.add(m, y)),
                (v = n.sub(v, E)),
                (E = n.add(s, a));
              let P = n.add(o, u);
              return (
                (E = n.mul(E, P)),
                (P = n.add(m, w)),
                (E = n.sub(E, P)),
                (P = n.add(i, a)),
                (c = n.add(l, u)),
                (P = n.mul(P, c)),
                (c = n.add(y, w)),
                (P = n.sub(P, c)),
                (h = n.mul(f, E)),
                (c = n.mul(g, w)),
                (h = n.add(c, h)),
                (c = n.sub(y, h)),
                (h = n.add(y, h)),
                (d = n.mul(c, h)),
                (y = n.add(m, m)),
                (y = n.add(y, m)),
                (w = n.mul(f, w)),
                (E = n.mul(g, E)),
                (y = n.add(y, w)),
                (w = n.sub(m, w)),
                (w = n.mul(f, w)),
                (E = n.add(E, w)),
                (m = n.mul(y, E)),
                (d = n.add(d, m)),
                (m = n.mul(P, E)),
                (c = n.mul(v, c)),
                (c = n.sub(c, m)),
                (m = n.mul(v, y)),
                (h = n.mul(P, h)),
                new A(c, d, (h = n.add(h, m)))
              );
            }
            subtract(e) {
              return this.add(e.negate());
            }
            is0() {
              return this.equals(A.ZERO);
            }
            wNAF(e) {
              return v.wNAFCached(this, y, e, (e) => {
                let t = n.invertBatch(e.map((e) => e.pz));
                return e.map((e, n) => e.toAffine(t[n])).map(A.fromAffine);
              });
            }
            multiplyUnsafe(e) {
              let s = A.ZERO;
              if (e === c) return s;
              if ((g(e), e === d)) return this;
              let { endo: i } = t;
              if (!i) return v.unsafeLadder(this, e);
              let { k1neg: a, k1: o, k2neg: l, k2: u } = i.splitScalar(e),
                h = s,
                p = s,
                f = this;
              for (; o > c || u > c; )
                o & d && (h = h.add(f)),
                  u & d && (p = p.add(f)),
                  (f = f.double()),
                  (o >>= d),
                  (u >>= d);
              return (
                a && (h = h.negate()),
                l && (p = p.negate()),
                (p = new A(n.mul(p.px, i.beta), p.py, p.pz)),
                h.add(p)
              );
            }
            multiply(e) {
              let s, i;
              g(e);
              let { endo: a } = t;
              if (a) {
                let { k1neg: t, k1: o, k2neg: l, k2: u } = a.splitScalar(e),
                  { p: c, f: d } = this.wNAF(o),
                  { p: h, f: p } = this.wNAF(u);
                (c = v.constTimeNegate(t, c)),
                  (h = v.constTimeNegate(l, h)),
                  (h = new A(n.mul(h.px, a.beta), h.py, h.pz)),
                  (s = c.add(h)),
                  (i = d.add(p));
              } else {
                let { p: t, f: n } = this.wNAF(e);
                (s = t), (i = n);
              }
              return A.normalizeZ([s, i])[0];
            }
            multiplyAndAddUnsafe(e, t, n) {
              let s = A.BASE,
                i = (e, t) =>
                  t !== c && t !== d && e.equals(s)
                    ? e.multiply(t)
                    : e.multiplyUnsafe(t),
                a = i(this, t).add(i(e, n));
              return a.is0() ? void 0 : a;
            }
            toAffine(e) {
              let { px: t, py: s, pz: i } = this,
                a = this.is0();
              null == e && (e = a ? n.ONE : n.inv(i));
              let o = n.mul(t, e),
                l = n.mul(s, e),
                u = n.mul(i, e);
              if (a) return { x: n.ZERO, y: n.ZERO };
              if (!n.eql(u, n.ONE)) throw Error("invZ was invalid");
              return { x: o, y: l };
            }
            isTorsionFree() {
              let { h: e, isTorsionFree: n } = t;
              if (e === d) return !0;
              if (n) return n(A, this);
              throw Error(
                "isTorsionFree() has not been declared for the elliptic curve"
              );
            }
            clearCofactor() {
              let { h: e, clearCofactor: n } = t;
              return e === d ? this : n ? n(A, this) : this.multiplyUnsafe(t.h);
            }
            toRawBytes(e = !0) {
              return this.assertValidity(), l(A, this, e);
            }
            toHex(e = !0) {
              return i.bytesToHex(this.toRawBytes(e));
            }
          }
          (A.BASE = new A(t.Gx, t.Gy, n.ONE)),
            (A.ZERO = new A(n.ZERO, n.ONE, n.ZERO));
          let w = t.nBitLength,
            v = (0, o.wNAF)(A, t.endo ? Math.ceil(w / 2) : w);
          return {
            CURVE: t,
            ProjectivePoint: A,
            normPrivateKeyToScalar: m,
            weierstrassEquation: h,
            isWithinCurveOrder: f,
          };
        }
        function m(e, t) {
          let n = e.ORDER,
            s = c;
          for (let e = n - d; e % h === c; e /= h) s += d;
          let i = s,
            a = h << (i - d - d),
            o = a * h,
            l = (n - d) / o,
            u = (l - d) / h,
            g = o - d,
            m = e.pow(t, l),
            y = e.pow(t, (l + d) / h),
            b = (t, n) => {
              let s = m,
                o = e.pow(n, g),
                l = e.sqr(o);
              l = e.mul(l, n);
              let c = e.mul(t, l);
              (c = e.pow(c, u)),
                (c = e.mul(c, o)),
                (o = e.mul(c, n)),
                (l = e.mul(c, t));
              let p = e.mul(l, o);
              c = e.pow(p, a);
              let f = e.eql(c, e.ONE);
              (o = e.mul(l, y)),
                (c = e.mul(p, s)),
                (l = e.cmov(o, l, f)),
                (p = e.cmov(c, p, f));
              for (let t = i; t > d; t--) {
                let n = t - h;
                n = h << (n - d);
                let i = e.pow(p, n),
                  a = e.eql(i, e.ONE);
                (o = e.mul(l, s)),
                  (s = e.mul(s, s)),
                  (i = e.mul(p, s)),
                  (l = e.cmov(o, l, a)),
                  (p = e.cmov(i, p, a));
              }
              return { isValid: f, value: l };
            };
          if (e.ORDER % f === p) {
            let n = (e.ORDER - p) / f,
              s = e.sqrt(e.neg(t));
            b = (t, i) => {
              let a = e.sqr(i),
                o = e.mul(t, i);
              a = e.mul(a, o);
              let l = e.pow(a, n);
              l = e.mul(l, o);
              let u = e.mul(l, s),
                c = e.mul(e.sqr(l), i),
                d = e.eql(c, t),
                h = e.cmov(u, l, d);
              return { isValid: d, value: h };
            };
          }
          return b;
        }
        (t.weierstrassPoints = g),
          (t.weierstrass = function (e) {
            let n = (function (e) {
                let t = (0, o.validateBasic)(e);
                return (
                  i.validateObject(
                    t,
                    { hash: "hash", hmac: "function", randomBytes: "function" },
                    {
                      bits2int: "function",
                      bits2int_modN: "function",
                      lowS: "boolean",
                    }
                  ),
                  Object.freeze({ lowS: !0, ...t })
                );
              })(e),
              { Fp: l, n: u } = n,
              h = l.BYTES + 1,
              p = 2 * l.BYTES + 1;
            function f(e) {
              return s.mod(e, u);
            }
            function m(e) {
              return s.invert(e, u);
            }
            let {
                ProjectivePoint: y,
                normPrivateKeyToScalar: b,
                weierstrassEquation: A,
                isWithinCurveOrder: w,
              } = g({
                ...n,
                toBytes(e, t, n) {
                  let s = t.toAffine(),
                    a = l.toBytes(s.x),
                    o = i.concatBytes;
                  return n
                    ? o(Uint8Array.from([t.hasEvenY() ? 2 : 3]), a)
                    : o(Uint8Array.from([4]), a, l.toBytes(s.y));
                },
                fromBytes(e) {
                  let t = e.length,
                    n = e[0],
                    s = e.subarray(1);
                  if (t === h && (2 === n || 3 === n)) {
                    let e = i.bytesToNumberBE(s);
                    if (!(c < e && e < l.ORDER))
                      throw Error("Point is not on curve");
                    let t = A(e),
                      a = l.sqrt(t);
                    return (
                      ((1 & n) == 1) != ((a & d) === d) && (a = l.neg(a)),
                      { x: e, y: a }
                    );
                  }
                  if (t === p && 4 === n)
                    return {
                      x: l.fromBytes(s.subarray(0, l.BYTES)),
                      y: l.fromBytes(s.subarray(l.BYTES, 2 * l.BYTES)),
                    };
                  throw Error(
                    `Point of length ${t} was invalid. Expected ${h} compressed bytes or ${p} uncompressed bytes`
                  );
                },
              }),
              v = (e) => i.bytesToHex(i.numberToBytesBE(e, n.nByteLength)),
              E = (e, t, n) => i.bytesToNumberBE(e.slice(t, n));
            class P {
              constructor(e, t, n) {
                (this.r = e),
                  (this.s = t),
                  (this.recovery = n),
                  this.assertValidity();
              }
              static fromCompact(e) {
                let t = n.nByteLength;
                return new P(
                  E(
                    (e = (0, a.ensureBytes)("compactSignature", e, 2 * t)),
                    0,
                    t
                  ),
                  E(e, t, 2 * t)
                );
              }
              static fromDER(e) {
                let { r: n, s } = t.DER.toSig((0, a.ensureBytes)("DER", e));
                return new P(n, s);
              }
              assertValidity() {
                if (!w(this.r)) throw Error("r must be 0 < r < CURVE.n");
                if (!w(this.s)) throw Error("s must be 0 < s < CURVE.n");
              }
              addRecoveryBit(e) {
                return new P(this.r, this.s, e);
              }
              recoverPublicKey(e) {
                let { r: t, s, recovery: i } = this,
                  o = x((0, a.ensureBytes)("msgHash", e));
                if (null == i || ![0, 1, 2, 3].includes(i))
                  throw Error("recovery id invalid");
                let u = 2 === i || 3 === i ? t + n.n : t;
                if (u >= l.ORDER) throw Error("recovery id 2 or 3 invalid");
                let c = (1 & i) == 0 ? "02" : "03",
                  d = y.fromHex(c + v(u)),
                  h = m(u),
                  p = f(-o * h),
                  g = f(s * h),
                  b = y.BASE.multiplyAndAddUnsafe(d, p, g);
                if (!b) throw Error("point at infinify");
                return b.assertValidity(), b;
              }
              hasHighS() {
                return this.s > u >> d;
              }
              normalizeS() {
                return this.hasHighS()
                  ? new P(this.r, f(-this.s), this.recovery)
                  : this;
              }
              toDERRawBytes() {
                return i.hexToBytes(this.toDERHex());
              }
              toDERHex() {
                return t.DER.hexFromSig({ r: this.r, s: this.s });
              }
              toCompactRawBytes() {
                return i.hexToBytes(this.toCompactHex());
              }
              toCompactHex() {
                return v(this.r) + v(this.s);
              }
            }
            function k(e) {
              let t = e instanceof Uint8Array,
                n = "string" == typeof e,
                s = (t || n) && e.length;
              return t
                ? s === h || s === p
                : n
                ? s === 2 * h || s === 2 * p
                : e instanceof y;
            }
            let T =
                n.bits2int ||
                function (e) {
                  let t = i.bytesToNumberBE(e),
                    s = 8 * e.length - n.nBitLength;
                  return s > 0 ? t >> BigInt(s) : t;
                },
              x =
                n.bits2int_modN ||
                function (e) {
                  return f(T(e));
                },
              O = i.bitMask(n.nBitLength);
            function S(e) {
              if ("bigint" != typeof e) throw Error("bigint expected");
              if (!(c <= e && e < O))
                throw Error(`bigint expected < 2^${n.nBitLength}`);
              return i.numberToBytesBE(e, n.nByteLength);
            }
            let C = { lowS: n.lowS, prehash: !1 },
              B = { lowS: n.lowS, prehash: !1 };
            return (
              y.BASE._setWindowSize(8),
              {
                CURVE: n,
                getPublicKey: function (e, t = !0) {
                  return y.fromPrivateKey(e).toRawBytes(t);
                },
                getSharedSecret: function (e, t, n = !0) {
                  if (k(e)) throw Error("first arg must be private key");
                  if (!k(t)) throw Error("second arg must be public key");
                  return y.fromHex(t).multiply(b(e)).toRawBytes(n);
                },
                sign: function (e, t, s = C) {
                  let { seed: o, k2sig: h } = (function (e, t, s = C) {
                    if (["recovered", "canonical"].some((e) => e in s))
                      throw Error("sign() legacy options not supported");
                    let { hash: o, randomBytes: h } = n,
                      { lowS: p, prehash: g, extraEntropy: A } = s;
                    null == p && (p = !0),
                      (e = (0, a.ensureBytes)("msgHash", e)),
                      g && (e = (0, a.ensureBytes)("prehashed msgHash", o(e)));
                    let v = x(e),
                      E = b(t),
                      k = [S(E), S(v)];
                    if (null != A) {
                      let e = !0 === A ? h(l.BYTES) : A;
                      k.push((0, a.ensureBytes)("extraEntropy", e));
                    }
                    return {
                      seed: i.concatBytes(...k),
                      k2sig: function (e) {
                        let t = T(e);
                        if (!w(t)) return;
                        let n = m(t),
                          s = y.BASE.multiply(t).toAffine(),
                          i = f(s.x);
                        if (i === c) return;
                        let a = f(n * f(v + i * E));
                        if (a === c) return;
                        let o = (s.x === i ? 0 : 2) | Number(s.y & d),
                          l = a;
                        if (p && a > u >> d)
                          (l = a > u >> d ? f(-a) : a), (o ^= 1);
                        return new P(i, l, o);
                      },
                    };
                  })(e, t, s);
                  return i.createHmacDrbg(
                    n.hash.outputLen,
                    n.nByteLength,
                    n.hmac
                  )(o, h);
                },
                verify: function (e, s, i, o = B) {
                  let l, u;
                  if (
                    ((s = (0, a.ensureBytes)("msgHash", s)),
                    (i = (0, a.ensureBytes)("publicKey", i)),
                    "strict" in o)
                  )
                    throw Error("options.strict was renamed to lowS");
                  let { lowS: c, prehash: d } = o;
                  try {
                    if ("string" == typeof e || e instanceof Uint8Array)
                      try {
                        u = P.fromDER(e);
                      } catch (n) {
                        if (!(n instanceof t.DER.Err)) throw n;
                        u = P.fromCompact(e);
                      }
                    else if (
                      "object" == typeof e &&
                      "bigint" == typeof e.r &&
                      "bigint" == typeof e.s
                    ) {
                      let { r: t, s: n } = e;
                      u = new P(t, n);
                    } else throw Error("PARSE");
                    l = y.fromHex(i);
                  } catch (e) {
                    if ("PARSE" === e.message)
                      throw Error(
                        "signature must be Signature instance, Uint8Array or hex string"
                      );
                    return !1;
                  }
                  if (c && u.hasHighS()) return !1;
                  d && (s = n.hash(s));
                  let { r: h, s: p } = u,
                    g = x(s),
                    b = m(p),
                    A = f(g * b),
                    w = f(h * b),
                    v = y.BASE.multiplyAndAddUnsafe(l, A, w)?.toAffine();
                  return !!v && f(v.x) === h;
                },
                ProjectivePoint: y,
                Signature: P,
                utils: {
                  isValidPrivateKey(e) {
                    try {
                      return b(e), !0;
                    } catch (e) {
                      return !1;
                    }
                  },
                  normPrivateKeyToScalar: b,
                  randomPrivateKey: () => {
                    let e = s.getMinHashLength(n.n);
                    return s.mapHashToField(n.randomBytes(e), n.n);
                  },
                  precompute: (e = 8, t = y.BASE) => (
                    t._setWindowSize(e), t.multiply(BigInt(3)), t
                  ),
                },
              }
            );
          }),
          (t.SWUFpSqrtRatio = m),
          (t.mapToCurveSimpleSWU = function (e, t) {
            if (
              (s.validateField(e),
              !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z))
            )
              throw Error("mapToCurveSimpleSWU: invalid opts");
            let n = m(e, t.Z);
            if (!e.isOdd) throw Error("Fp.isOdd is not implemented!");
            return (s) => {
              let i, a, o, l, u, c, d, h;
              (i = e.sqr(s)),
                (i = e.mul(i, t.Z)),
                (a = e.sqr(i)),
                (a = e.add(a, i)),
                (o = e.add(a, e.ONE)),
                (o = e.mul(o, t.B)),
                (l = e.cmov(t.Z, e.neg(a), !e.eql(a, e.ZERO))),
                (l = e.mul(l, t.A)),
                (a = e.sqr(o)),
                (c = e.sqr(l)),
                (u = e.mul(c, t.A)),
                (a = e.add(a, u)),
                (a = e.mul(a, o)),
                (c = e.mul(c, l)),
                (u = e.mul(c, t.B)),
                (a = e.add(a, u)),
                (d = e.mul(i, o));
              let { isValid: p, value: f } = n(a, c);
              (h = e.mul(i, s)),
                (h = e.mul(h, f)),
                (d = e.cmov(d, o, p)),
                (h = e.cmov(h, f, p));
              let g = e.isOdd(s) === e.isOdd(h);
              return (
                (h = e.cmov(e.neg(h), h, g)), { x: (d = e.div(d, l)), y: h }
              );
            };
          });
      },
      82958: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.encodeToCurve = t.hashToCurve = t.schnorr = t.secp256k1 = void 0);
        let s = n(67366),
          i = n(29681),
          a = n(23570),
          o = n(12541),
          l = n(43912),
          u = n(6791),
          c = n(50079),
          d = BigInt(
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
          ),
          h = BigInt(
            "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
          ),
          p = BigInt(1),
          f = BigInt(2),
          g = (e, t) => (e + t / f) / t;
        function m(e) {
          let t = BigInt(3),
            n = BigInt(6),
            s = BigInt(11),
            i = BigInt(22),
            o = BigInt(23),
            l = BigInt(44),
            u = BigInt(88),
            c = (e * e * e) % d,
            h = (c * c * e) % d,
            p = ((0, a.pow2)(h, t, d) * h) % d,
            g = ((0, a.pow2)(p, t, d) * h) % d,
            m = ((0, a.pow2)(g, f, d) * c) % d,
            b = ((0, a.pow2)(m, s, d) * m) % d,
            A = ((0, a.pow2)(b, i, d) * b) % d,
            w = ((0, a.pow2)(A, l, d) * A) % d,
            v = ((0, a.pow2)(w, u, d) * w) % d,
            E = ((0, a.pow2)(v, l, d) * A) % d,
            P = ((0, a.pow2)(E, t, d) * h) % d,
            k = ((0, a.pow2)(P, o, d) * b) % d,
            T = ((0, a.pow2)(k, n, d) * c) % d,
            x = (0, a.pow2)(T, f, d);
          if (!y.eql(y.sqr(x), e)) throw Error("Cannot find square root");
          return x;
        }
        let y = (0, a.Field)(d, void 0, void 0, { sqrt: m });
        t.secp256k1 = (0, c.createCurve)(
          {
            a: BigInt(0),
            b: BigInt(7),
            Fp: y,
            n: h,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240"
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424"
            ),
            h: BigInt(1),
            lowS: !0,
            endo: {
              beta: BigInt(
                "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
              ),
              splitScalar: (e) => {
                let t = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                  n = -p * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                  s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                  i = BigInt("0x100000000000000000000000000000000"),
                  o = g(t * e, h),
                  l = g(-n * e, h),
                  u = (0, a.mod)(e - o * t - l * s, h),
                  c = (0, a.mod)(-o * n - l * t, h),
                  d = u > i,
                  f = c > i;
                if ((d && (u = h - u), f && (c = h - c), u > i || c > i))
                  throw Error("splitScalar: Endomorphism failed, k=" + e);
                return { k1neg: d, k1: u, k2neg: f, k2: c };
              },
            },
          },
          s.sha256
        );
        let b = BigInt(0),
          A = (e) => "bigint" == typeof e && b < e && e < d,
          w = (e) => "bigint" == typeof e && b < e && e < h,
          v = {};
        function E(e, ...t) {
          let n = v[e];
          if (void 0 === n) {
            let t = (0, s.sha256)(Uint8Array.from(e, (e) => e.charCodeAt(0)));
            (n = (0, l.concatBytes)(t, t)), (v[e] = n);
          }
          return (0, s.sha256)((0, l.concatBytes)(n, ...t));
        }
        let P = (e) => e.toRawBytes(!0).slice(1),
          k = (e) => (0, l.numberToBytesBE)(e, 32),
          T = (e) => (0, a.mod)(e, d),
          x = (e) => (0, a.mod)(e, h),
          O = t.secp256k1.ProjectivePoint,
          S = (e, t, n) => O.BASE.multiplyAndAddUnsafe(e, t, n);
        function C(e) {
          let n = t.secp256k1.utils.normPrivateKeyToScalar(e),
            s = O.fromPrivateKey(n);
          return { scalar: s.hasEvenY() ? n : x(-n), bytes: P(s) };
        }
        function B(e) {
          if (!A(e)) throw Error("bad x: need 0 < x < p");
          let t = T(e * e),
            n = m(T(t * e + BigInt(7)));
          n % f !== b && (n = T(-n));
          let s = new O(e, n, p);
          return s.assertValidity(), s;
        }
        function N(...e) {
          return x((0, l.bytesToNumberBE)(E("BIP0340/challenge", ...e)));
        }
        function R(e, t, n) {
          let s = (0, l.ensureBytes)("signature", e, 64),
            i = (0, l.ensureBytes)("message", t),
            a = (0, l.ensureBytes)("publicKey", n, 32);
          try {
            let e = B((0, l.bytesToNumberBE)(a)),
              t = (0, l.bytesToNumberBE)(s.subarray(0, 32));
            if (!A(t)) return !1;
            let n = (0, l.bytesToNumberBE)(s.subarray(32, 64));
            if (!w(n)) return !1;
            let o = N(k(t), P(e), i),
              u = S(e, n, x(-o));
            if (!u || !u.hasEvenY() || u.toAffine().x !== t) return !1;
            return !0;
          } catch (e) {
            return !1;
          }
        }
        t.schnorr = {
          getPublicKey: function (e) {
            return C(e).bytes;
          },
          sign: function (e, t, n = (0, i.randomBytes)(32)) {
            let s = (0, l.ensureBytes)("message", e),
              { bytes: a, scalar: o } = C(t),
              u = (0, l.ensureBytes)("auxRand", n, 32),
              c = k(o ^ (0, l.bytesToNumberBE)(E("BIP0340/aux", u))),
              d = E("BIP0340/nonce", c, a, s),
              h = x((0, l.bytesToNumberBE)(d));
            if (h === b) throw Error("sign failed: k is zero");
            let { bytes: p, scalar: f } = C(h),
              g = N(p, a, s),
              m = new Uint8Array(64);
            if ((m.set(p, 0), m.set(k(x(f + g * o)), 32), !R(m, s, a)))
              throw Error("sign: Invalid signature produced");
            return m;
          },
          verify: R,
          utils: {
            randomPrivateKey: t.secp256k1.utils.randomPrivateKey,
            lift_x: B,
            pointToBytes: P,
            numberToBytesBE: l.numberToBytesBE,
            bytesToNumberBE: l.bytesToNumberBE,
            taggedHash: E,
            mod: a.mod,
          },
        };
        let I = (0, u.isogenyMap)(
            y,
            [
              [
                "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
                "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
                "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
                "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c",
              ],
              [
                "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
                "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
                "0x0000000000000000000000000000000000000000000000000000000000000001",
              ],
              [
                "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
                "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
                "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
                "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84",
              ],
              [
                "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
                "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
                "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
                "0x0000000000000000000000000000000000000000000000000000000000000001",
              ],
            ].map((e) => e.map((e) => BigInt(e)))
          ),
          M = (0, o.mapToCurveSimpleSWU)(y, {
            A: BigInt(
              "0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"
            ),
            B: BigInt("1771"),
            Z: y.create(BigInt("-11")),
          }),
          L = (0, u.createHasher)(
            t.secp256k1.ProjectivePoint,
            (e) => {
              let { x: t, y: n } = M(y.create(e[0]));
              return I(t, n);
            },
            {
              DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
              encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
              p: y.ORDER,
              m: 1,
              k: 128,
              expand: "xmd",
              hash: s.sha256,
            }
          );
        (t.hashToCurve = L.hashToCurve), (t.encodeToCurve = L.encodeToCurve);
      },
      46363: function (e, t) {
        "use strict";
        function n(e) {
          if (!Number.isSafeInteger(e) || e < 0)
            throw Error(`Wrong positive integer: ${e}`);
        }
        function s(e) {
          if ("boolean" != typeof e) throw Error(`Expected boolean, not ${e}`);
        }
        function i(e, ...t) {
          if (!(e instanceof Uint8Array)) throw Error("Expected Uint8Array");
          if (t.length > 0 && !t.includes(e.length))
            throw Error(
              `Expected Uint8Array of length ${t}, not of length=${e.length}`
            );
        }
        function a(e) {
          if ("function" != typeof e || "function" != typeof e.create)
            throw Error("Hash should be wrapped by utils.wrapConstructor");
          n(e.outputLen), n(e.blockLen);
        }
        function o(e, t = !0) {
          if (e.destroyed) throw Error("Hash instance has been destroyed");
          if (t && e.finished)
            throw Error("Hash#digest() has already been called");
        }
        function l(e, t) {
          i(e);
          let n = t.outputLen;
          if (e.length < n)
            throw Error(
              `digestInto() expects output buffer of length at least ${n}`
            );
        }
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.output = t.exists = t.hash = t.bytes = t.bool = t.number = void 0),
          (t.number = n),
          (t.bool = s),
          (t.bytes = i),
          (t.hash = a),
          (t.exists = o),
          (t.output = l),
          (t.default = {
            number: n,
            bool: s,
            bytes: i,
            hash: a,
            exists: o,
            output: l,
          });
      },
      70915: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SHA2 = void 0);
        let s = n(46363),
          i = n(29681);
        class a extends i.Hash {
          constructor(e, t, n, s) {
            super(),
              (this.blockLen = e),
              (this.outputLen = t),
              (this.padOffset = n),
              (this.isLE = s),
              (this.finished = !1),
              (this.length = 0),
              (this.pos = 0),
              (this.destroyed = !1),
              (this.buffer = new Uint8Array(e)),
              (this.view = (0, i.createView)(this.buffer));
          }
          update(e) {
            (0, s.exists)(this);
            let { view: t, buffer: n, blockLen: a } = this,
              o = (e = (0, i.toBytes)(e)).length;
            for (let s = 0; s < o; ) {
              let l = Math.min(a - this.pos, o - s);
              if (l === a) {
                let t = (0, i.createView)(e);
                for (; a <= o - s; s += a) this.process(t, s);
                continue;
              }
              n.set(e.subarray(s, s + l), this.pos),
                (this.pos += l),
                (s += l),
                this.pos === a && (this.process(t, 0), (this.pos = 0));
            }
            return (this.length += e.length), this.roundClean(), this;
          }
          digestInto(e) {
            (0, s.exists)(this), (0, s.output)(e, this), (this.finished = !0);
            let { buffer: t, view: n, blockLen: a, isLE: o } = this,
              { pos: l } = this;
            (t[l++] = 128),
              this.buffer.subarray(l).fill(0),
              this.padOffset > a - l && (this.process(n, 0), (l = 0));
            for (let e = l; e < a; e++) t[e] = 0;
            (function (e, t, n, s) {
              if ("function" == typeof e.setBigUint64)
                return e.setBigUint64(t, n, s);
              let i = BigInt(32),
                a = BigInt(4294967295),
                o = Number((n >> i) & a),
                l = Number(n & a),
                u = s ? 4 : 0,
                c = s ? 0 : 4;
              e.setUint32(t + u, o, s), e.setUint32(t + c, l, s);
            })(n, a - 8, BigInt(8 * this.length), o),
              this.process(n, 0);
            let u = (0, i.createView)(e),
              c = this.outputLen;
            if (c % 4)
              throw Error("_sha2: outputLen should be aligned to 32bit");
            let d = c / 4,
              h = this.get();
            if (d > h.length) throw Error("_sha2: outputLen bigger than state");
            for (let e = 0; e < d; e++) u.setUint32(4 * e, h[e], o);
          }
          digest() {
            let { buffer: e, outputLen: t } = this;
            this.digestInto(e);
            let n = e.slice(0, t);
            return this.destroy(), n;
          }
          _cloneInto(e) {
            e || (e = new this.constructor()), e.set(...this.get());
            let {
              blockLen: t,
              buffer: n,
              length: s,
              finished: i,
              destroyed: a,
              pos: o,
            } = this;
            return (
              (e.length = s),
              (e.pos = o),
              (e.finished = i),
              (e.destroyed = a),
              s % t && e.buffer.set(n),
              e
            );
          }
        }
        t.SHA2 = a;
      },
      94881: function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.add5L =
            t.add5H =
            t.add4H =
            t.add4L =
            t.add3H =
            t.add3L =
            t.add =
            t.rotlBL =
            t.rotlBH =
            t.rotlSL =
            t.rotlSH =
            t.rotr32L =
            t.rotr32H =
            t.rotrBL =
            t.rotrBH =
            t.rotrSL =
            t.rotrSH =
            t.shrSL =
            t.shrSH =
            t.toBig =
            t.split =
            t.fromBig =
              void 0);
        let n = BigInt(4294967296 - 1),
          s = BigInt(32);
        function i(e, t = !1) {
          return t
            ? { h: Number(e & n), l: Number((e >> s) & n) }
            : { h: 0 | Number((e >> s) & n), l: 0 | Number(e & n) };
        }
        function a(e, t = !1) {
          let n = new Uint32Array(e.length),
            s = new Uint32Array(e.length);
          for (let a = 0; a < e.length; a++) {
            let { h: o, l } = i(e[a], t);
            [n[a], s[a]] = [o, l];
          }
          return [n, s];
        }
        (t.fromBig = i), (t.split = a);
        let o = (e, t) => (BigInt(e >>> 0) << s) | BigInt(t >>> 0);
        t.toBig = o;
        let l = (e, t, n) => e >>> n;
        t.shrSH = l;
        let u = (e, t, n) => (e << (32 - n)) | (t >>> n);
        t.shrSL = u;
        let c = (e, t, n) => (e >>> n) | (t << (32 - n));
        t.rotrSH = c;
        let d = (e, t, n) => (e << (32 - n)) | (t >>> n);
        t.rotrSL = d;
        let h = (e, t, n) => (e << (64 - n)) | (t >>> (n - 32));
        t.rotrBH = h;
        let p = (e, t, n) => (e >>> (n - 32)) | (t << (64 - n));
        t.rotrBL = p;
        let f = (e, t) => t;
        t.rotr32H = f;
        let g = (e, t) => e;
        t.rotr32L = g;
        let m = (e, t, n) => (e << n) | (t >>> (32 - n));
        t.rotlSH = m;
        let y = (e, t, n) => (t << n) | (e >>> (32 - n));
        t.rotlSL = y;
        let b = (e, t, n) => (t << (n - 32)) | (e >>> (64 - n));
        t.rotlBH = b;
        let A = (e, t, n) => (e << (n - 32)) | (t >>> (64 - n));
        function w(e, t, n, s) {
          let i = (t >>> 0) + (s >>> 0);
          return { h: (e + n + ((i / 4294967296) | 0)) | 0, l: 0 | i };
        }
        (t.rotlBL = A), (t.add = w);
        let v = (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0);
        t.add3L = v;
        let E = (e, t, n, s) => (t + n + s + ((e / 4294967296) | 0)) | 0;
        t.add3H = E;
        let P = (e, t, n, s) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (s >>> 0);
        t.add4L = P;
        let k = (e, t, n, s, i) => (t + n + s + i + ((e / 4294967296) | 0)) | 0;
        t.add4H = k;
        let T = (e, t, n, s, i) =>
          (e >>> 0) + (t >>> 0) + (n >>> 0) + (s >>> 0) + (i >>> 0);
        t.add5L = T;
        let x = (e, t, n, s, i, a) =>
          (t + n + s + i + a + ((e / 4294967296) | 0)) | 0;
        (t.add5H = x),
          (t.default = {
            fromBig: i,
            split: a,
            toBig: o,
            shrSH: l,
            shrSL: u,
            rotrSH: c,
            rotrSL: d,
            rotrBH: h,
            rotrBL: p,
            rotr32H: f,
            rotr32L: g,
            rotlSH: m,
            rotlSL: y,
            rotlBH: b,
            rotlBL: A,
            add: w,
            add3L: v,
            add3H: E,
            add4L: P,
            add4H: k,
            add5H: x,
            add5L: T,
          });
      },
      70754: function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.crypto = void 0),
          (t.crypto =
            "object" == typeof globalThis && "crypto" in globalThis
              ? globalThis.crypto
              : void 0);
      },
      60798: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hmac = t.HMAC = void 0);
        let s = n(46363),
          i = n(29681);
        class a extends i.Hash {
          constructor(e, t) {
            super(),
              (this.finished = !1),
              (this.destroyed = !1),
              (0, s.hash)(e);
            let n = (0, i.toBytes)(t);
            if (
              ((this.iHash = e.create()),
              "function" != typeof this.iHash.update)
            )
              throw Error(
                "Expected instance of class which extends utils.Hash"
              );
            (this.blockLen = this.iHash.blockLen),
              (this.outputLen = this.iHash.outputLen);
            let a = this.blockLen,
              o = new Uint8Array(a);
            o.set(n.length > a ? e.create().update(n).digest() : n);
            for (let e = 0; e < o.length; e++) o[e] ^= 54;
            this.iHash.update(o), (this.oHash = e.create());
            for (let e = 0; e < o.length; e++) o[e] ^= 106;
            this.oHash.update(o), o.fill(0);
          }
          update(e) {
            return (0, s.exists)(this), this.iHash.update(e), this;
          }
          digestInto(e) {
            (0, s.exists)(this),
              (0, s.bytes)(e, this.outputLen),
              (this.finished = !0),
              this.iHash.digestInto(e),
              this.oHash.update(e),
              this.oHash.digestInto(e),
              this.destroy();
          }
          digest() {
            let e = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(e), e;
          }
          _cloneInto(e) {
            e || (e = Object.create(Object.getPrototypeOf(this), {}));
            let {
              oHash: t,
              iHash: n,
              finished: s,
              destroyed: i,
              blockLen: a,
              outputLen: o,
            } = this;
            return (
              (e.finished = s),
              (e.destroyed = i),
              (e.blockLen = a),
              (e.outputLen = o),
              (e.oHash = t._cloneInto(e.oHash)),
              (e.iHash = n._cloneInto(e.iHash)),
              e
            );
          }
          destroy() {
            (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
          }
        }
        (t.HMAC = a),
          (t.hmac = (e, t, n) => new a(e, t).update(n).digest()),
          (t.hmac.create = (e, t) => new a(e, t));
      },
      24112: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.pbkdf2Async = t.pbkdf2 = void 0);
        let s = n(46363),
          i = n(60798),
          a = n(29681);
        function o(e, t, n, o) {
          (0, s.hash)(e);
          let {
            c: l,
            dkLen: u,
            asyncTick: c,
          } = (0, a.checkOpts)({ dkLen: 32, asyncTick: 10 }, o);
          if (((0, s.number)(l), (0, s.number)(u), (0, s.number)(c), l < 1))
            throw Error("PBKDF2: iterations (c) should be >= 1");
          let d = (0, a.toBytes)(t),
            h = (0, a.toBytes)(n),
            p = new Uint8Array(u),
            f = i.hmac.create(e, d),
            g = f._cloneInto().update(h);
          return { c: l, dkLen: u, asyncTick: c, DK: p, PRF: f, PRFSalt: g };
        }
        function l(e, t, n, s, i) {
          return e.destroy(), t.destroy(), s && s.destroy(), i.fill(0), n;
        }
        async function u(e, t, n, s) {
          let i;
          let {
              c: u,
              dkLen: c,
              asyncTick: d,
              DK: h,
              PRF: p,
              PRFSalt: f,
            } = o(e, t, n, s),
            g = new Uint8Array(4),
            m = (0, a.createView)(g),
            y = new Uint8Array(p.outputLen);
          for (let e = 1, t = 0; t < c; e++, t += p.outputLen) {
            let n = h.subarray(t, t + p.outputLen);
            m.setInt32(0, e, !1),
              (i = f._cloneInto(i)).update(g).digestInto(y),
              n.set(y.subarray(0, n.length)),
              await (0, a.asyncLoop)(u - 1, d, () => {
                p._cloneInto(i).update(y).digestInto(y);
                for (let e = 0; e < n.length; e++) n[e] ^= y[e];
              });
          }
          return l(p, f, h, i, y);
        }
        (t.pbkdf2 = function (e, t, n, s) {
          let i;
          let { c: u, dkLen: c, DK: d, PRF: h, PRFSalt: p } = o(e, t, n, s),
            f = new Uint8Array(4),
            g = (0, a.createView)(f),
            m = new Uint8Array(h.outputLen);
          for (let e = 1, t = 0; t < c; e++, t += h.outputLen) {
            let n = d.subarray(t, t + h.outputLen);
            g.setInt32(0, e, !1),
              (i = p._cloneInto(i)).update(f).digestInto(m),
              n.set(m.subarray(0, n.length));
            for (let e = 1; e < u; e++) {
              h._cloneInto(i).update(m).digestInto(m);
              for (let e = 0; e < n.length; e++) n[e] ^= m[e];
            }
          }
          return l(h, p, d, i, m);
        }),
          (t.pbkdf2Async = u);
      },
      67746: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ripemd160 = t.RIPEMD160 = void 0);
        let s = n(70915),
          i = n(29681),
          a = new Uint8Array([
            7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
          ]),
          o = Uint8Array.from({ length: 16 }, (e, t) => t),
          l = o.map((e) => (9 * e + 5) % 16),
          u = [o],
          c = [l];
        for (let e = 0; e < 4; e++)
          for (let t of [u, c]) t.push(t[e].map((e) => a[e]));
        let d = [
            [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
            [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
            [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
            [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
            [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
          ].map((e) => new Uint8Array(e)),
          h = u.map((e, t) => e.map((e) => d[t][e])),
          p = c.map((e, t) => e.map((e) => d[t][e])),
          f = new Uint32Array([
            0, 1518500249, 1859775393, 2400959708, 2840853838,
          ]),
          g = new Uint32Array([
            1352829926, 1548603684, 1836072691, 2053994217, 0,
          ]),
          m = (e, t) => (e << t) | (e >>> (32 - t));
        function y(e, t, n, s) {
          return 0 === e
            ? t ^ n ^ s
            : 1 === e
            ? (t & n) | (~t & s)
            : 2 === e
            ? (t | ~n) ^ s
            : 3 === e
            ? (t & s) | (n & ~s)
            : t ^ (n | ~s);
        }
        let b = new Uint32Array(16);
        class A extends s.SHA2 {
          constructor() {
            super(64, 20, 8, !0),
              (this.h0 = 1732584193),
              (this.h1 = -271733879),
              (this.h2 = -1732584194),
              (this.h3 = 271733878),
              (this.h4 = -1009589776);
          }
          get() {
            let { h0: e, h1: t, h2: n, h3: s, h4: i } = this;
            return [e, t, n, s, i];
          }
          set(e, t, n, s, i) {
            (this.h0 = 0 | e),
              (this.h1 = 0 | t),
              (this.h2 = 0 | n),
              (this.h3 = 0 | s),
              (this.h4 = 0 | i);
          }
          process(e, t) {
            for (let n = 0; n < 16; n++, t += 4) b[n] = e.getUint32(t, !0);
            let n = 0 | this.h0,
              s = n,
              i = 0 | this.h1,
              a = i,
              o = 0 | this.h2,
              l = o,
              d = 0 | this.h3,
              A = d,
              w = 0 | this.h4,
              v = w;
            for (let e = 0; e < 5; e++) {
              let t = 4 - e,
                E = f[e],
                P = g[e],
                k = u[e],
                T = c[e],
                x = h[e],
                O = p[e];
              for (let t = 0; t < 16; t++) {
                let s = (m(n + y(e, i, o, d) + b[k[t]] + E, x[t]) + w) | 0;
                (n = w), (w = d), (d = 0 | m(o, 10)), (o = i), (i = s);
              }
              for (let e = 0; e < 16; e++) {
                let n = (m(s + y(t, a, l, A) + b[T[e]] + P, O[e]) + v) | 0;
                (s = v), (v = A), (A = 0 | m(l, 10)), (l = a), (a = n);
              }
            }
            this.set(
              (this.h1 + o + A) | 0,
              (this.h2 + d + v) | 0,
              (this.h3 + w + s) | 0,
              (this.h4 + n + a) | 0,
              (this.h0 + i + l) | 0
            );
          }
          roundClean() {
            b.fill(0);
          }
          destroy() {
            (this.destroyed = !0), this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
          }
        }
        (t.RIPEMD160 = A),
          (t.ripemd160 = (0, i.wrapConstructor)(() => new A()));
      },
      49468: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.scryptAsync = t.scrypt = void 0);
        let s = n(46363),
          i = n(67366),
          a = n(24112),
          o = n(29681),
          l = (e, t) => (e << t) | (e >>> (32 - t));
        function u(e, t, n, s, i, a) {
          let o = e[t++] ^ n[s++],
            u = e[t++] ^ n[s++],
            c = e[t++] ^ n[s++],
            d = e[t++] ^ n[s++],
            h = e[t++] ^ n[s++],
            p = e[t++] ^ n[s++],
            f = e[t++] ^ n[s++],
            g = e[t++] ^ n[s++],
            m = e[t++] ^ n[s++],
            y = e[t++] ^ n[s++],
            b = e[t++] ^ n[s++],
            A = e[t++] ^ n[s++],
            w = e[t++] ^ n[s++],
            v = e[t++] ^ n[s++],
            E = e[t++] ^ n[s++],
            P = e[t++] ^ n[s++],
            k = o,
            T = u,
            x = c,
            O = d,
            S = h,
            C = p,
            B = f,
            N = g,
            R = m,
            I = y,
            M = b,
            L = A,
            _ = w,
            F = v,
            D = E,
            U = P;
          for (let e = 0; e < 8; e += 2)
            (S ^= l((k + _) | 0, 7)),
              (R ^= l((S + k) | 0, 9)),
              (_ ^= l((R + S) | 0, 13)),
              (k ^= l((_ + R) | 0, 18)),
              (I ^= l((C + T) | 0, 7)),
              (F ^= l((I + C) | 0, 9)),
              (T ^= l((F + I) | 0, 13)),
              (C ^= l((T + F) | 0, 18)),
              (D ^= l((M + B) | 0, 7)),
              (x ^= l((D + M) | 0, 9)),
              (B ^= l((x + D) | 0, 13)),
              (M ^= l((B + x) | 0, 18)),
              (O ^= l((U + L) | 0, 7)),
              (N ^= l((O + U) | 0, 9)),
              (L ^= l((N + O) | 0, 13)),
              (U ^= l((L + N) | 0, 18)),
              (T ^= l((k + O) | 0, 7)),
              (x ^= l((T + k) | 0, 9)),
              (O ^= l((x + T) | 0, 13)),
              (k ^= l((O + x) | 0, 18)),
              (B ^= l((C + S) | 0, 7)),
              (N ^= l((B + C) | 0, 9)),
              (S ^= l((N + B) | 0, 13)),
              (C ^= l((S + N) | 0, 18)),
              (L ^= l((M + I) | 0, 7)),
              (R ^= l((L + M) | 0, 9)),
              (I ^= l((R + L) | 0, 13)),
              (M ^= l((I + R) | 0, 18)),
              (_ ^= l((U + D) | 0, 7)),
              (F ^= l((_ + U) | 0, 9)),
              (D ^= l((F + _) | 0, 13)),
              (U ^= l((D + F) | 0, 18));
          (i[a++] = (o + k) | 0),
            (i[a++] = (u + T) | 0),
            (i[a++] = (c + x) | 0),
            (i[a++] = (d + O) | 0),
            (i[a++] = (h + S) | 0),
            (i[a++] = (p + C) | 0),
            (i[a++] = (f + B) | 0),
            (i[a++] = (g + N) | 0),
            (i[a++] = (m + R) | 0),
            (i[a++] = (y + I) | 0),
            (i[a++] = (b + M) | 0),
            (i[a++] = (A + L) | 0),
            (i[a++] = (w + _) | 0),
            (i[a++] = (v + F) | 0),
            (i[a++] = (E + D) | 0),
            (i[a++] = (P + U) | 0);
        }
        function c(e, t, n, s, i) {
          let a = s + 0,
            o = s + 16 * i;
          for (let s = 0; s < 16; s++) n[o + s] = e[t + (2 * i - 1) * 16 + s];
          for (let s = 0; s < i; s++, a += 16, t += 16)
            u(n, o, e, t, n, a),
              s > 0 && (o += 16),
              u(n, a, e, (t += 16), n, o);
        }
        function d(e, t, n) {
          let {
            N: l,
            r: u,
            p: c,
            dkLen: d,
            asyncTick: h,
            maxmem: p,
            onProgress: f,
          } = (0, o.checkOpts)(
            { dkLen: 32, asyncTick: 10, maxmem: 1073742848 },
            n
          );
          if (
            ((0, s.number)(l),
            (0, s.number)(u),
            (0, s.number)(c),
            (0, s.number)(d),
            (0, s.number)(h),
            (0, s.number)(p),
            void 0 !== f && "function" != typeof f)
          )
            throw Error("progressCb should be function");
          let g = 128 * u,
            m = g / 4;
          if (
            l <= 1 ||
            (l & (l - 1)) != 0 ||
            l >= 2 ** (g / 8) ||
            l > 4294967296
          )
            throw Error(
              "Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32"
            );
          if (c < 0 || c > ((4294967296 - 1) * 32) / g)
            throw Error(
              "Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)"
            );
          if (d < 0 || d > (4294967296 - 1) * 32)
            throw Error(
              "Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32"
            );
          let y = g * (l + c);
          if (y > p)
            throw Error(
              `Scrypt: parameters too large, ${y} (128 * r * (N + p)) > ${p} (maxmem)`
            );
          let b = (0, a.pbkdf2)(i.sha256, e, t, { c: 1, dkLen: g * c }),
            A = (0, o.u32)(b),
            w = (0, o.u32)(new Uint8Array(g * l)),
            v = (0, o.u32)(new Uint8Array(g)),
            E = () => {};
          if (f) {
            let e = 2 * l * c,
              t = Math.max(Math.floor(e / 1e4), 1),
              n = 0;
            E = () => {
              n++, f && (!(n % t) || n === e) && f(n / e);
            };
          }
          return {
            N: l,
            r: u,
            p: c,
            dkLen: d,
            blockSize32: m,
            V: w,
            B32: A,
            B: b,
            tmp: v,
            blockMixCb: E,
            asyncTick: h,
          };
        }
        function h(e, t, n, s, o) {
          let l = (0, a.pbkdf2)(i.sha256, e, n, { c: 1, dkLen: t });
          return n.fill(0), s.fill(0), o.fill(0), l;
        }
        async function p(e, t, n) {
          let {
            N: s,
            r: i,
            p: a,
            dkLen: l,
            blockSize32: u,
            V: p,
            B32: f,
            B: g,
            tmp: m,
            blockMixCb: y,
            asyncTick: b,
          } = d(e, t, n);
          for (let e = 0; e < a; e++) {
            let t = u * e;
            for (let e = 0; e < u; e++) p[e] = f[t + e];
            let n = 0;
            await (0, o.asyncLoop)(s - 1, b, () => {
              c(p, n, p, (n += u), i), y();
            }),
              c(p, (s - 1) * u, f, t, i),
              y(),
              await (0, o.asyncLoop)(s, b, () => {
                let e = f[t + u - 16] % s;
                for (let n = 0; n < u; n++) m[n] = f[t + n] ^ p[e * u + n];
                c(m, 0, f, t, i), y();
              });
          }
          return h(e, l, g, p, m);
        }
        (t.scrypt = function (e, t, n) {
          let {
            N: s,
            r: i,
            p: a,
            dkLen: o,
            blockSize32: l,
            V: u,
            B32: p,
            B: f,
            tmp: g,
            blockMixCb: m,
          } = d(e, t, n);
          for (let e = 0; e < a; e++) {
            let t = l * e;
            for (let e = 0; e < l; e++) u[e] = p[t + e];
            for (let e = 0, t = 0; e < s - 1; e++) c(u, t, u, (t += l), i), m();
            c(u, (s - 1) * l, p, t, i), m();
            for (let e = 0; e < s; e++) {
              let e = p[t + l - 16] % s;
              for (let n = 0; n < l; n++) g[n] = p[t + n] ^ u[e * l + n];
              c(g, 0, p, t, i), m();
            }
          }
          return h(e, o, f, u, g);
        }),
          (t.scryptAsync = p);
      },
      67366: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.sha224 = t.sha256 = void 0);
        let s = n(70915),
          i = n(29681),
          a = (e, t, n) => (e & t) ^ (~e & n),
          o = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
          l = new Uint32Array([
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ]),
          u = new Uint32Array([
            1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
            2600822924, 528734635, 1541459225,
          ]),
          c = new Uint32Array(64);
        class d extends s.SHA2 {
          constructor() {
            super(64, 32, 8, !1),
              (this.A = 0 | u[0]),
              (this.B = 0 | u[1]),
              (this.C = 0 | u[2]),
              (this.D = 0 | u[3]),
              (this.E = 0 | u[4]),
              (this.F = 0 | u[5]),
              (this.G = 0 | u[6]),
              (this.H = 0 | u[7]);
          }
          get() {
            let { A: e, B: t, C: n, D: s, E: i, F: a, G: o, H: l } = this;
            return [e, t, n, s, i, a, o, l];
          }
          set(e, t, n, s, i, a, o, l) {
            (this.A = 0 | e),
              (this.B = 0 | t),
              (this.C = 0 | n),
              (this.D = 0 | s),
              (this.E = 0 | i),
              (this.F = 0 | a),
              (this.G = 0 | o),
              (this.H = 0 | l);
          }
          process(e, t) {
            for (let n = 0; n < 16; n++, t += 4) c[n] = e.getUint32(t, !1);
            for (let e = 16; e < 64; e++) {
              let t = c[e - 15],
                n = c[e - 2],
                s = (0, i.rotr)(t, 7) ^ (0, i.rotr)(t, 18) ^ (t >>> 3),
                a = (0, i.rotr)(n, 17) ^ (0, i.rotr)(n, 19) ^ (n >>> 10);
              c[e] = (a + c[e - 7] + s + c[e - 16]) | 0;
            }
            let { A: n, B: s, C: u, D: d, E: h, F: p, G: f, H: g } = this;
            for (let e = 0; e < 64; e++) {
              let t =
                  (g +
                    ((0, i.rotr)(h, 6) ^
                      (0, i.rotr)(h, 11) ^
                      (0, i.rotr)(h, 25)) +
                    a(h, p, f) +
                    l[e] +
                    c[e]) |
                  0,
                m =
                  (((0, i.rotr)(n, 2) ^
                    (0, i.rotr)(n, 13) ^
                    (0, i.rotr)(n, 22)) +
                    o(n, s, u)) |
                  0;
              (g = f),
                (f = p),
                (p = h),
                (h = (d + t) | 0),
                (d = u),
                (u = s),
                (s = n),
                (n = (t + m) | 0);
            }
            (n = (n + this.A) | 0),
              (s = (s + this.B) | 0),
              (u = (u + this.C) | 0),
              (d = (d + this.D) | 0),
              (h = (h + this.E) | 0),
              (p = (p + this.F) | 0),
              (f = (f + this.G) | 0),
              (g = (g + this.H) | 0),
              this.set(n, s, u, d, h, p, f, g);
          }
          roundClean() {
            c.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        class h extends d {
          constructor() {
            super(),
              (this.A = -1056596264),
              (this.B = 914150663),
              (this.C = 812702999),
              (this.D = -150054599),
              (this.E = -4191439),
              (this.F = 1750603025),
              (this.G = 1694076839),
              (this.H = -1090891868),
              (this.outputLen = 28);
          }
        }
        (t.sha256 = (0, i.wrapConstructor)(() => new d())),
          (t.sha224 = (0, i.wrapConstructor)(() => new h()));
      },
      7910: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.shake256 =
            t.shake128 =
            t.keccak_512 =
            t.keccak_384 =
            t.keccak_256 =
            t.keccak_224 =
            t.sha3_512 =
            t.sha3_384 =
            t.sha3_256 =
            t.sha3_224 =
            t.Keccak =
            t.keccakP =
              void 0);
        let s = n(46363),
          i = n(94881),
          a = n(29681),
          [o, l, u] = [[], [], []],
          c = BigInt(0),
          d = BigInt(1),
          h = BigInt(2),
          p = BigInt(7),
          f = BigInt(256),
          g = BigInt(113);
        for (let e = 0, t = d, n = 1, s = 0; e < 24; e++) {
          ([n, s] = [s, (2 * n + 3 * s) % 5]),
            o.push(2 * (5 * s + n)),
            l.push((((e + 1) * (e + 2)) / 2) % 64);
          let i = c;
          for (let e = 0; e < 7; e++)
            (t = ((t << d) ^ ((t >> p) * g)) % f) & h &&
              (i ^= d << ((d << BigInt(e)) - d));
          u.push(i);
        }
        let [m, y] = (0, i.split)(u, !0),
          b = (e, t, n) =>
            n > 32 ? (0, i.rotlBH)(e, t, n) : (0, i.rotlSH)(e, t, n),
          A = (e, t, n) =>
            n > 32 ? (0, i.rotlBL)(e, t, n) : (0, i.rotlSL)(e, t, n);
        function w(e, t = 24) {
          let n = new Uint32Array(10);
          for (let s = 24 - t; s < 24; s++) {
            for (let t = 0; t < 10; t++)
              n[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
            for (let t = 0; t < 10; t += 2) {
              let s = (t + 8) % 10,
                i = (t + 2) % 10,
                a = n[i],
                o = n[i + 1],
                l = b(a, o, 1) ^ n[s],
                u = A(a, o, 1) ^ n[s + 1];
              for (let n = 0; n < 50; n += 10)
                (e[t + n] ^= l), (e[t + n + 1] ^= u);
            }
            let t = e[2],
              i = e[3];
            for (let n = 0; n < 24; n++) {
              let s = l[n],
                a = b(t, i, s),
                u = A(t, i, s),
                c = o[n];
              (t = e[c]), (i = e[c + 1]), (e[c] = a), (e[c + 1] = u);
            }
            for (let t = 0; t < 50; t += 10) {
              for (let s = 0; s < 10; s++) n[s] = e[t + s];
              for (let s = 0; s < 10; s++)
                e[t + s] ^= ~n[(s + 2) % 10] & n[(s + 4) % 10];
            }
            (e[0] ^= m[s]), (e[1] ^= y[s]);
          }
          n.fill(0);
        }
        t.keccakP = w;
        class v extends a.Hash {
          constructor(e, t, n, i = !1, o = 24) {
            if (
              (super(),
              (this.blockLen = e),
              (this.suffix = t),
              (this.outputLen = n),
              (this.enableXOF = i),
              (this.rounds = o),
              (this.pos = 0),
              (this.posOut = 0),
              (this.finished = !1),
              (this.destroyed = !1),
              (0, s.number)(n),
              0 >= this.blockLen || this.blockLen >= 200)
            )
              throw Error("Sha3 supports only keccak-f1600 function");
            (this.state = new Uint8Array(200)),
              (this.state32 = (0, a.u32)(this.state));
          }
          keccak() {
            w(this.state32, this.rounds), (this.posOut = 0), (this.pos = 0);
          }
          update(e) {
            (0, s.exists)(this);
            let { blockLen: t, state: n } = this,
              i = (e = (0, a.toBytes)(e)).length;
            for (let s = 0; s < i; ) {
              let a = Math.min(t - this.pos, i - s);
              for (let t = 0; t < a; t++) n[this.pos++] ^= e[s++];
              this.pos === t && this.keccak();
            }
            return this;
          }
          finish() {
            if (this.finished) return;
            this.finished = !0;
            let { state: e, suffix: t, pos: n, blockLen: s } = this;
            (e[n] ^= t),
              (128 & t) != 0 && n === s - 1 && this.keccak(),
              (e[s - 1] ^= 128),
              this.keccak();
          }
          writeInto(e) {
            (0, s.exists)(this, !1), (0, s.bytes)(e), this.finish();
            let t = this.state,
              { blockLen: n } = this;
            for (let s = 0, i = e.length; s < i; ) {
              this.posOut >= n && this.keccak();
              let a = Math.min(n - this.posOut, i - s);
              e.set(t.subarray(this.posOut, this.posOut + a), s),
                (this.posOut += a),
                (s += a);
            }
            return e;
          }
          xofInto(e) {
            if (!this.enableXOF)
              throw Error("XOF is not possible for this instance");
            return this.writeInto(e);
          }
          xof(e) {
            return (0, s.number)(e), this.xofInto(new Uint8Array(e));
          }
          digestInto(e) {
            if (((0, s.output)(e, this), this.finished))
              throw Error("digest() was already called");
            return this.writeInto(e), this.destroy(), e;
          }
          digest() {
            return this.digestInto(new Uint8Array(this.outputLen));
          }
          destroy() {
            (this.destroyed = !0), this.state.fill(0);
          }
          _cloneInto(e) {
            let {
              blockLen: t,
              suffix: n,
              outputLen: s,
              rounds: i,
              enableXOF: a,
            } = this;
            return (
              e || (e = new v(t, n, s, a, i)),
              e.state32.set(this.state32),
              (e.pos = this.pos),
              (e.posOut = this.posOut),
              (e.finished = this.finished),
              (e.rounds = i),
              (e.suffix = n),
              (e.outputLen = s),
              (e.enableXOF = a),
              (e.destroyed = this.destroyed),
              e
            );
          }
        }
        t.Keccak = v;
        let E = (e, t, n) => (0, a.wrapConstructor)(() => new v(t, e, n));
        (t.sha3_224 = E(6, 144, 28)),
          (t.sha3_256 = E(6, 136, 32)),
          (t.sha3_384 = E(6, 104, 48)),
          (t.sha3_512 = E(6, 72, 64)),
          (t.keccak_224 = E(1, 144, 28)),
          (t.keccak_256 = E(1, 136, 32)),
          (t.keccak_384 = E(1, 104, 48)),
          (t.keccak_512 = E(1, 72, 64));
        let P = (e, t, n) =>
          (0, a.wrapXOFConstructorWithOpts)(
            (s = {}) => new v(t, e, void 0 === s.dkLen ? n : s.dkLen, !0)
          );
        (t.shake128 = P(31, 168, 16)), (t.shake256 = P(31, 136, 32));
      },
      40937: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.sha384 =
            t.sha512_256 =
            t.sha512_224 =
            t.sha512 =
            t.SHA512 =
              void 0);
        let s = n(70915),
          i = n(94881),
          a = n(29681),
          [o, l] = i.default.split(
            [
              "0x428a2f98d728ae22",
              "0x7137449123ef65cd",
              "0xb5c0fbcfec4d3b2f",
              "0xe9b5dba58189dbbc",
              "0x3956c25bf348b538",
              "0x59f111f1b605d019",
              "0x923f82a4af194f9b",
              "0xab1c5ed5da6d8118",
              "0xd807aa98a3030242",
              "0x12835b0145706fbe",
              "0x243185be4ee4b28c",
              "0x550c7dc3d5ffb4e2",
              "0x72be5d74f27b896f",
              "0x80deb1fe3b1696b1",
              "0x9bdc06a725c71235",
              "0xc19bf174cf692694",
              "0xe49b69c19ef14ad2",
              "0xefbe4786384f25e3",
              "0x0fc19dc68b8cd5b5",
              "0x240ca1cc77ac9c65",
              "0x2de92c6f592b0275",
              "0x4a7484aa6ea6e483",
              "0x5cb0a9dcbd41fbd4",
              "0x76f988da831153b5",
              "0x983e5152ee66dfab",
              "0xa831c66d2db43210",
              "0xb00327c898fb213f",
              "0xbf597fc7beef0ee4",
              "0xc6e00bf33da88fc2",
              "0xd5a79147930aa725",
              "0x06ca6351e003826f",
              "0x142929670a0e6e70",
              "0x27b70a8546d22ffc",
              "0x2e1b21385c26c926",
              "0x4d2c6dfc5ac42aed",
              "0x53380d139d95b3df",
              "0x650a73548baf63de",
              "0x766a0abb3c77b2a8",
              "0x81c2c92e47edaee6",
              "0x92722c851482353b",
              "0xa2bfe8a14cf10364",
              "0xa81a664bbc423001",
              "0xc24b8b70d0f89791",
              "0xc76c51a30654be30",
              "0xd192e819d6ef5218",
              "0xd69906245565a910",
              "0xf40e35855771202a",
              "0x106aa07032bbd1b8",
              "0x19a4c116b8d2d0c8",
              "0x1e376c085141ab53",
              "0x2748774cdf8eeb99",
              "0x34b0bcb5e19b48a8",
              "0x391c0cb3c5c95a63",
              "0x4ed8aa4ae3418acb",
              "0x5b9cca4f7763e373",
              "0x682e6ff3d6b2b8a3",
              "0x748f82ee5defb2fc",
              "0x78a5636f43172f60",
              "0x84c87814a1f0ab72",
              "0x8cc702081a6439ec",
              "0x90befffa23631e28",
              "0xa4506cebde82bde9",
              "0xbef9a3f7b2c67915",
              "0xc67178f2e372532b",
              "0xca273eceea26619c",
              "0xd186b8c721c0c207",
              "0xeada7dd6cde0eb1e",
              "0xf57d4f7fee6ed178",
              "0x06f067aa72176fba",
              "0x0a637dc5a2c898a6",
              "0x113f9804bef90dae",
              "0x1b710b35131c471b",
              "0x28db77f523047d84",
              "0x32caab7b40c72493",
              "0x3c9ebe0a15c9bebc",
              "0x431d67c49c100d4c",
              "0x4cc5d4becb3e42b6",
              "0x597f299cfc657e2a",
              "0x5fcb6fab3ad6faec",
              "0x6c44198c4a475817",
            ].map((e) => BigInt(e))
          ),
          u = new Uint32Array(80),
          c = new Uint32Array(80);
        class d extends s.SHA2 {
          constructor() {
            super(128, 64, 16, !1),
              (this.Ah = 1779033703),
              (this.Al = -205731576),
              (this.Bh = -1150833019),
              (this.Bl = -2067093701),
              (this.Ch = 1013904242),
              (this.Cl = -23791573),
              (this.Dh = -1521486534),
              (this.Dl = 1595750129),
              (this.Eh = 1359893119),
              (this.El = -1377402159),
              (this.Fh = -1694144372),
              (this.Fl = 725511199),
              (this.Gh = 528734635),
              (this.Gl = -79577749),
              (this.Hh = 1541459225),
              (this.Hl = 327033209);
          }
          get() {
            let {
              Ah: e,
              Al: t,
              Bh: n,
              Bl: s,
              Ch: i,
              Cl: a,
              Dh: o,
              Dl: l,
              Eh: u,
              El: c,
              Fh: d,
              Fl: h,
              Gh: p,
              Gl: f,
              Hh: g,
              Hl: m,
            } = this;
            return [e, t, n, s, i, a, o, l, u, c, d, h, p, f, g, m];
          }
          set(e, t, n, s, i, a, o, l, u, c, d, h, p, f, g, m) {
            (this.Ah = 0 | e),
              (this.Al = 0 | t),
              (this.Bh = 0 | n),
              (this.Bl = 0 | s),
              (this.Ch = 0 | i),
              (this.Cl = 0 | a),
              (this.Dh = 0 | o),
              (this.Dl = 0 | l),
              (this.Eh = 0 | u),
              (this.El = 0 | c),
              (this.Fh = 0 | d),
              (this.Fl = 0 | h),
              (this.Gh = 0 | p),
              (this.Gl = 0 | f),
              (this.Hh = 0 | g),
              (this.Hl = 0 | m);
          }
          process(e, t) {
            for (let n = 0; n < 16; n++, t += 4)
              (u[n] = e.getUint32(t)), (c[n] = e.getUint32((t += 4)));
            for (let e = 16; e < 80; e++) {
              let t = 0 | u[e - 15],
                n = 0 | c[e - 15],
                s =
                  i.default.rotrSH(t, n, 1) ^
                  i.default.rotrSH(t, n, 8) ^
                  i.default.shrSH(t, n, 7),
                a =
                  i.default.rotrSL(t, n, 1) ^
                  i.default.rotrSL(t, n, 8) ^
                  i.default.shrSL(t, n, 7),
                o = 0 | u[e - 2],
                l = 0 | c[e - 2],
                d =
                  i.default.rotrSH(o, l, 19) ^
                  i.default.rotrBH(o, l, 61) ^
                  i.default.shrSH(o, l, 6),
                h =
                  i.default.rotrSL(o, l, 19) ^
                  i.default.rotrBL(o, l, 61) ^
                  i.default.shrSL(o, l, 6),
                p = i.default.add4L(a, h, c[e - 7], c[e - 16]),
                f = i.default.add4H(p, s, d, u[e - 7], u[e - 16]);
              (u[e] = 0 | f), (c[e] = 0 | p);
            }
            let {
              Ah: n,
              Al: s,
              Bh: a,
              Bl: d,
              Ch: h,
              Cl: p,
              Dh: f,
              Dl: g,
              Eh: m,
              El: y,
              Fh: b,
              Fl: A,
              Gh: w,
              Gl: v,
              Hh: E,
              Hl: P,
            } = this;
            for (let e = 0; e < 80; e++) {
              let t =
                  i.default.rotrSH(m, y, 14) ^
                  i.default.rotrSH(m, y, 18) ^
                  i.default.rotrBH(m, y, 41),
                k =
                  i.default.rotrSL(m, y, 14) ^
                  i.default.rotrSL(m, y, 18) ^
                  i.default.rotrBL(m, y, 41),
                T = (m & b) ^ (~m & w),
                x = (y & A) ^ (~y & v),
                O = i.default.add5L(P, k, x, l[e], c[e]),
                S = i.default.add5H(O, E, t, T, o[e], u[e]),
                C = 0 | O,
                B =
                  i.default.rotrSH(n, s, 28) ^
                  i.default.rotrBH(n, s, 34) ^
                  i.default.rotrBH(n, s, 39),
                N =
                  i.default.rotrSL(n, s, 28) ^
                  i.default.rotrBL(n, s, 34) ^
                  i.default.rotrBL(n, s, 39),
                R = (n & a) ^ (n & h) ^ (a & h),
                I = (s & d) ^ (s & p) ^ (d & p);
              (E = 0 | w),
                (P = 0 | v),
                (w = 0 | b),
                (v = 0 | A),
                (b = 0 | m),
                (A = 0 | y),
                ({ h: m, l: y } = i.default.add(0 | f, 0 | g, 0 | S, 0 | C)),
                (f = 0 | h),
                (g = 0 | p),
                (h = 0 | a),
                (p = 0 | d),
                (a = 0 | n),
                (d = 0 | s);
              let M = i.default.add3L(C, N, I);
              (n = i.default.add3H(M, S, B, R)), (s = 0 | M);
            }
            ({ h: n, l: s } = i.default.add(
              0 | this.Ah,
              0 | this.Al,
              0 | n,
              0 | s
            )),
              ({ h: a, l: d } = i.default.add(
                0 | this.Bh,
                0 | this.Bl,
                0 | a,
                0 | d
              )),
              ({ h: h, l: p } = i.default.add(
                0 | this.Ch,
                0 | this.Cl,
                0 | h,
                0 | p
              )),
              ({ h: f, l: g } = i.default.add(
                0 | this.Dh,
                0 | this.Dl,
                0 | f,
                0 | g
              )),
              ({ h: m, l: y } = i.default.add(
                0 | this.Eh,
                0 | this.El,
                0 | m,
                0 | y
              )),
              ({ h: b, l: A } = i.default.add(
                0 | this.Fh,
                0 | this.Fl,
                0 | b,
                0 | A
              )),
              ({ h: w, l: v } = i.default.add(
                0 | this.Gh,
                0 | this.Gl,
                0 | w,
                0 | v
              )),
              ({ h: E, l: P } = i.default.add(
                0 | this.Hh,
                0 | this.Hl,
                0 | E,
                0 | P
              )),
              this.set(n, s, a, d, h, p, f, g, m, y, b, A, w, v, E, P);
          }
          roundClean() {
            u.fill(0), c.fill(0);
          }
          destroy() {
            this.buffer.fill(0),
              this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
        }
        t.SHA512 = d;
        class h extends d {
          constructor() {
            super(),
              (this.Ah = -1942145080),
              (this.Al = 424955298),
              (this.Bh = 1944164710),
              (this.Bl = -1982016298),
              (this.Ch = 502970286),
              (this.Cl = 855612546),
              (this.Dh = 1738396948),
              (this.Dl = 1479516111),
              (this.Eh = 258812777),
              (this.El = 2077511080),
              (this.Fh = 2011393907),
              (this.Fl = 79989058),
              (this.Gh = 1067287976),
              (this.Gl = 1780299464),
              (this.Hh = 286451373),
              (this.Hl = -1848208735),
              (this.outputLen = 28);
          }
        }
        class p extends d {
          constructor() {
            super(),
              (this.Ah = 573645204),
              (this.Al = -64227540),
              (this.Bh = -1621794909),
              (this.Bl = -934517566),
              (this.Ch = 596883563),
              (this.Cl = 1867755857),
              (this.Dh = -1774684391),
              (this.Dl = 1497426621),
              (this.Eh = -1775747358),
              (this.El = -1467023389),
              (this.Fh = -1101128155),
              (this.Fl = 1401305490),
              (this.Gh = 721525244),
              (this.Gl = 746961066),
              (this.Hh = 246885852),
              (this.Hl = -2117784414),
              (this.outputLen = 32);
          }
        }
        class f extends d {
          constructor() {
            super(),
              (this.Ah = -876896931),
              (this.Al = -1056596264),
              (this.Bh = 1654270250),
              (this.Bl = 914150663),
              (this.Ch = -1856437926),
              (this.Cl = 812702999),
              (this.Dh = 355462360),
              (this.Dl = -150054599),
              (this.Eh = 1731405415),
              (this.El = -4191439),
              (this.Fh = -1900787065),
              (this.Fl = 1750603025),
              (this.Gh = -619958771),
              (this.Gl = 1694076839),
              (this.Hh = 1203062813),
              (this.Hl = -1090891868),
              (this.outputLen = 48);
          }
        }
        (t.sha512 = (0, a.wrapConstructor)(() => new d())),
          (t.sha512_224 = (0, a.wrapConstructor)(() => new h())),
          (t.sha512_256 = (0, a.wrapConstructor)(() => new p())),
          (t.sha384 = (0, a.wrapConstructor)(() => new f()));
      },
      29681: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.randomBytes =
            t.wrapXOFConstructorWithOpts =
            t.wrapConstructorWithOpts =
            t.wrapConstructor =
            t.checkOpts =
            t.Hash =
            t.concatBytes =
            t.toBytes =
            t.utf8ToBytes =
            t.asyncLoop =
            t.nextTick =
            t.hexToBytes =
            t.bytesToHex =
            t.isLE =
            t.rotr =
            t.createView =
            t.u32 =
            t.u8 =
              void 0);
        let s = n(70754),
          i = (e) => e instanceof Uint8Array;
        if (
          ((t.u8 = (e) => new Uint8Array(e.buffer, e.byteOffset, e.byteLength)),
          (t.u32 = (e) =>
            new Uint32Array(
              e.buffer,
              e.byteOffset,
              Math.floor(e.byteLength / 4)
            )),
          (t.createView = (e) =>
            new DataView(e.buffer, e.byteOffset, e.byteLength)),
          (t.rotr = (e, t) => (e << (32 - t)) | (e >>> t)),
          (t.isLE =
            68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0]),
          !t.isLE)
        )
          throw Error("Non little-endian hardware is not supported");
        let a = Array.from({ length: 256 }, (e, t) =>
          t.toString(16).padStart(2, "0")
        );
        (t.bytesToHex = function (e) {
          if (!i(e)) throw Error("Uint8Array expected");
          let t = "";
          for (let n = 0; n < e.length; n++) t += a[e[n]];
          return t;
        }),
          (t.hexToBytes = function (e) {
            if ("string" != typeof e)
              throw Error("hex string expected, got " + typeof e);
            let t = e.length;
            if (t % 2)
              throw Error(
                "padded hex string expected, got unpadded hex of length " + t
              );
            let n = new Uint8Array(t / 2);
            for (let t = 0; t < n.length; t++) {
              let s = 2 * t,
                i = Number.parseInt(e.slice(s, s + 2), 16);
              if (Number.isNaN(i) || i < 0)
                throw Error("Invalid byte sequence");
              n[t] = i;
            }
            return n;
          });
        let o = async () => {};
        async function l(e, n, s) {
          let i = Date.now();
          for (let a = 0; a < e; a++) {
            s(a);
            let e = Date.now() - i;
            (e >= 0 && e < n) || (await (0, t.nextTick)(), (i += e));
          }
        }
        function u(e) {
          if ("string" != typeof e)
            throw Error(`utf8ToBytes expected string, got ${typeof e}`);
          return new Uint8Array(new TextEncoder().encode(e));
        }
        function c(e) {
          if (("string" == typeof e && (e = u(e)), !i(e)))
            throw Error(`expected Uint8Array, got ${typeof e}`);
          return e;
        }
        (t.nextTick = o),
          (t.asyncLoop = l),
          (t.utf8ToBytes = u),
          (t.toBytes = c),
          (t.concatBytes = function (...e) {
            let t = new Uint8Array(e.reduce((e, t) => e + t.length, 0)),
              n = 0;
            return (
              e.forEach((e) => {
                if (!i(e)) throw Error("Uint8Array expected");
                t.set(e, n), (n += e.length);
              }),
              t
            );
          });
        class d {
          clone() {
            return this._cloneInto();
          }
        }
        t.Hash = d;
        let h = {}.toString;
        (t.checkOpts = function (e, t) {
          if (void 0 !== t && "[object Object]" !== h.call(t))
            throw Error("Options should be object or undefined");
          return Object.assign(e, t);
        }),
          (t.wrapConstructor = function (e) {
            let t = (t) => e().update(c(t)).digest(),
              n = e();
            return (
              (t.outputLen = n.outputLen),
              (t.blockLen = n.blockLen),
              (t.create = () => e()),
              t
            );
          }),
          (t.wrapConstructorWithOpts = function (e) {
            let t = (t, n) => e(n).update(c(t)).digest(),
              n = e({});
            return (
              (t.outputLen = n.outputLen),
              (t.blockLen = n.blockLen),
              (t.create = (t) => e(t)),
              t
            );
          }),
          (t.wrapXOFConstructorWithOpts = function (e) {
            let t = (t, n) => e(n).update(c(t)).digest(),
              n = e({});
            return (
              (t.outputLen = n.outputLen),
              (t.blockLen = n.blockLen),
              (t.create = (t) => e(t)),
              t
            );
          }),
          (t.randomBytes = function (e = 32) {
            if (s.crypto && "function" == typeof s.crypto.getRandomValues)
              return s.crypto.getRandomValues(new Uint8Array(e));
            throw Error("crypto.getRandomValues must be defined");
          });
      },
      67956: function (e, t, n) {
        "use strict";
        var s =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, n, s) {
                  void 0 === s && (s = n);
                  var i = Object.getOwnPropertyDescriptor(t, n);
                  (!i ||
                    ("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) &&
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[n];
                      },
                    }),
                    Object.defineProperty(e, s, i);
                }
              : function (e, t, n, s) {
                  void 0 === s && (s = n), (e[s] = t[n]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          a =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var n in e)
                  "default" !== n &&
                    Object.prototype.hasOwnProperty.call(e, n) &&
                    s(t, e, n);
              return i(t, e), t;
            },
          o =
            (this && this.__awaiter) ||
            function (e, t, n, s) {
              return new (n || (n = Promise))(function (i, a) {
                function o(e) {
                  try {
                    u(s.next(e));
                  } catch (e) {
                    a(e);
                  }
                }
                function l(e) {
                  try {
                    u(s.throw(e));
                  } catch (e) {
                    a(e);
                  }
                }
                function u(e) {
                  var t;
                  e.done
                    ? i(e.value)
                    : ((t = e.value) instanceof n
                        ? t
                        : new n(function (e) {
                            e(t);
                          })
                      ).then(o, l);
                }
                u((s = s.apply(e, t || [])).next());
              });
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SiweMessage = void 0);
        let l = n(20200),
          u = a(n(80481)),
          c = n(31422),
          d = n(5734),
          h = n(56564);
        class p {
          constructor(e) {
            if ("string" == typeof e) {
              let t = new l.ParsedMessage(e);
              (this.scheme = t.scheme),
                (this.domain = t.domain),
                (this.address = t.address),
                (this.statement = t.statement),
                (this.uri = t.uri),
                (this.version = t.version),
                (this.nonce = t.nonce),
                (this.issuedAt = t.issuedAt),
                (this.expirationTime = t.expirationTime),
                (this.notBefore = t.notBefore),
                (this.requestId = t.requestId),
                (this.chainId = t.chainId),
                (this.resources = t.resources);
            } else
              (this.scheme = null == e ? void 0 : e.scheme),
                (this.domain = e.domain),
                (this.address = e.address),
                (this.statement = null == e ? void 0 : e.statement),
                (this.uri = e.uri),
                (this.version = e.version),
                (this.chainId = e.chainId),
                (this.nonce = e.nonce),
                (this.issuedAt = null == e ? void 0 : e.issuedAt),
                (this.expirationTime = null == e ? void 0 : e.expirationTime),
                (this.notBefore = null == e ? void 0 : e.notBefore),
                (this.requestId = null == e ? void 0 : e.requestId),
                (this.resources = null == e ? void 0 : e.resources),
                "string" == typeof this.chainId &&
                  (this.chainId = (0, l.parseIntegerNumber)(this.chainId));
            (this.nonce = this.nonce || (0, h.generateNonce)()),
              this.validateMessage();
          }
          toMessage() {
            this.validateMessage();
            let e = this.scheme
                ? `${this.scheme}://${this.domain}`
                : this.domain,
              t = `${e} wants you to sign in with your Ethereum account:`,
              n = `URI: ${this.uri}`,
              s = [t, this.address].join("\n"),
              i = `Version: ${this.version}`;
            this.nonce || (this.nonce = (0, h.generateNonce)());
            let a = [n, i, "Chain ID: " + this.chainId, `Nonce: ${this.nonce}`];
            if (
              ((this.issuedAt = this.issuedAt || new Date().toISOString()),
              a.push(`Issued At: ${this.issuedAt}`),
              this.expirationTime)
            ) {
              let e = `Expiration Time: ${this.expirationTime}`;
              a.push(e);
            }
            this.notBefore && a.push(`Not Before: ${this.notBefore}`),
              this.requestId && a.push(`Request ID: ${this.requestId}`),
              this.resources &&
                a.push(
                  ["Resources:", ...this.resources.map((e) => `- ${e}`)].join(
                    "\n"
                  )
                );
            let o = a.join("\n");
            return (
              (s = [s, this.statement].join("\n\n")),
              this.statement && (s += "\n"),
              [s, o].join("\n")
            );
          }
          prepareMessage() {
            let e;
            return this.version, this.toMessage();
          }
          validate(e, t) {
            return o(this, void 0, void 0, function* () {
              return (
                console.warn(
                  "validate() has been deprecated, please update your code to use verify(). validate() may be removed in future versions."
                ),
                this.verify(
                  { signature: e },
                  { provider: t, suppressExceptions: !1 }
                )
                  .then(({ data: e }) => e)
                  .catch(({ error: e }) => {
                    throw e;
                  })
              );
            });
          }
          verify(e, t = { suppressExceptions: !1 }) {
            return o(this, void 0, void 0, function* () {
              return new Promise((n, s) => {
                var i, a, o;
                let l, u;
                let p = (e) => (t.suppressExceptions ? n(e) : s(e)),
                  f = (0, h.checkInvalidKeys)(e, d.VerifyParamsKeys);
                f.length > 0 &&
                  p({
                    success: !1,
                    data: this,
                    error: Error(
                      `${f.join(
                        ", "
                      )} is/are not valid key(s) for VerifyParams.`
                    ),
                  });
                let g = (0, h.checkInvalidKeys)(t, d.VerifyOptsKeys);
                f.length > 0 &&
                  p({
                    success: !1,
                    data: this,
                    error: Error(
                      `${g.join(", ")} is/are not valid key(s) for VerifyOpts.`
                    ),
                  });
                let {
                  signature: m,
                  scheme: y,
                  domain: b,
                  nonce: A,
                  time: w,
                } = e;
                y &&
                  y !== this.scheme &&
                  p({
                    success: !1,
                    data: this,
                    error: new d.SiweError(
                      d.SiweErrorType.SCHEME_MISMATCH,
                      y,
                      this.scheme
                    ),
                  }),
                  b &&
                    b !== this.domain &&
                    p({
                      success: !1,
                      data: this,
                      error: new d.SiweError(
                        d.SiweErrorType.DOMAIN_MISMATCH,
                        b,
                        this.domain
                      ),
                    }),
                  A &&
                    A !== this.nonce &&
                    p({
                      success: !1,
                      data: this,
                      error: new d.SiweError(
                        d.SiweErrorType.NONCE_MISMATCH,
                        A,
                        this.nonce
                      ),
                    });
                let v = new Date(w || new Date());
                if (this.expirationTime) {
                  let e = new Date(this.expirationTime);
                  v.getTime() >= e.getTime() &&
                    p({
                      success: !1,
                      data: this,
                      error: new d.SiweError(
                        d.SiweErrorType.EXPIRED_MESSAGE,
                        `${v.toISOString()} < ${e.toISOString()}`,
                        `${v.toISOString()} >= ${e.toISOString()}`
                      ),
                    });
                }
                if (this.notBefore) {
                  let e = new Date(this.notBefore);
                  v.getTime() < e.getTime() &&
                    p({
                      success: !1,
                      data: this,
                      error: new d.SiweError(
                        d.SiweErrorType.NOT_YET_VALID_MESSAGE,
                        `${v.toISOString()} >= ${e.toISOString()}`,
                        `${v.toISOString()} < ${e.toISOString()}`
                      ),
                    });
                }
                try {
                  l = this.prepareMessage();
                } catch (e) {
                  p({ success: !1, data: this, error: e });
                }
                try {
                  u = (0, c.verifyMessage)(l, m);
                } catch (e) {
                  console.error(e);
                }
                if (u === this.address) return n({ success: !0, data: this });
                {
                  let s = (0, h.checkContractWalletSignature)(
                    this,
                    m,
                    t.provider
                  )
                    .then((e) =>
                      e
                        ? { success: !0, data: this }
                        : {
                            success: !1,
                            data: this,
                            error: new d.SiweError(
                              d.SiweErrorType.INVALID_SIGNATURE,
                              u,
                              `Resolved address to be ${this.address}`
                            ),
                          }
                    )
                    .catch((e) => ({ success: !1, data: this, error: e }));
                  Promise.all([
                    s,
                    null ===
                      (o =
                        null ===
                          (a =
                            null ===
                              (i =
                                null == t ? void 0 : t.verificationFallback) ||
                            void 0 === i
                              ? void 0
                              : i.call(t, e, t, this, s)) || void 0 === a
                          ? void 0
                          : a.then((e) => e)) || void 0 === o
                      ? void 0
                      : o.catch((e) => e),
                  ]).then(([e, t]) => {
                    if (t) {
                      if (t.success) return n(t);
                      p(t);
                    } else {
                      if (e.success) return n(e);
                      p(e);
                    }
                  });
                }
              });
            });
          }
          validateMessage(...e) {
            var t;
            if (e.length > 0)
              throw new d.SiweError(
                d.SiweErrorType.UNABLE_TO_PARSE,
                "Unexpected argument in the validateMessage function."
              );
            if (
              !this.domain ||
              0 === this.domain.length ||
              !/[^#?]*/.test(this.domain)
            )
              throw new d.SiweError(
                d.SiweErrorType.INVALID_DOMAIN,
                `${this.domain} to be a valid domain.`
              );
            if (!(0, l.isEIP55Address)(this.address))
              throw new d.SiweError(
                d.SiweErrorType.INVALID_ADDRESS,
                (0, c.getAddress)(this.address),
                this.address
              );
            if (!u.isUri(this.uri))
              throw new d.SiweError(
                d.SiweErrorType.INVALID_URI,
                `${this.uri} to be a valid uri.`
              );
            if ("1" !== this.version)
              throw new d.SiweError(
                d.SiweErrorType.INVALID_MESSAGE_VERSION,
                "1",
                this.version
              );
            let n =
              null ===
                (t = this === null || void 0 === this ? void 0 : this.nonce) ||
              void 0 === t
                ? void 0
                : t.match(/[a-zA-Z0-9]{8,}/);
            if (!n || this.nonce.length < 8 || n[0] !== this.nonce)
              throw new d.SiweError(
                d.SiweErrorType.INVALID_NONCE,
                `Length > 8 (${n.length}). Alphanumeric.`,
                this.nonce
              );
            if (
              (this.issuedAt && !(0, h.isValidISO8601Date)(this.issuedAt)) ||
              (this.expirationTime &&
                !(0, h.isValidISO8601Date)(this.expirationTime)) ||
              (this.notBefore && !(0, h.isValidISO8601Date)(this.notBefore))
            )
              throw Error(d.SiweErrorType.INVALID_TIME_FORMAT);
          }
        }
        t.SiweMessage = p;
      },
      31422: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getAddress = t.hashMessage = t.verifyMessage = void 0);
        let s = n(59237),
          i = null,
          a = null,
          o = null;
        try {
          (i = s.ethers.utils.verifyMessage),
            (a = s.ethers.utils.hashMessage),
            (o = s.ethers.utils.getAddress);
        } catch (e) {
          (i = s.ethers.verifyMessage),
            (a = s.ethers.hashMessage),
            (o = s.ethers.getAddress);
        }
        (t.verifyMessage = i), (t.hashMessage = a), (t.getAddress = o);
      },
      97544: function (e, t, n) {
        "use strict";
        var s =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, n, s) {
                  void 0 === s && (s = n);
                  var i = Object.getOwnPropertyDescriptor(t, n);
                  (!i ||
                    ("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) &&
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[n];
                      },
                    }),
                    Object.defineProperty(e, s, i);
                }
              : function (e, t, n, s) {
                  void 0 === s && (s = n), (e[s] = t[n]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var n in e)
                "default" === n ||
                  Object.prototype.hasOwnProperty.call(t, n) ||
                  s(t, e, n);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          i(n(67956), t),
          i(n(5734), t),
          i(n(56564), t);
      },
      5734: function (e, t) {
        "use strict";
        var n;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SiweErrorType =
            t.SiweError =
            t.VerifyOptsKeys =
            t.VerifyParamsKeys =
              void 0),
          (t.VerifyParamsKeys = [
            "signature",
            "scheme",
            "domain",
            "nonce",
            "time",
          ]),
          (t.VerifyOptsKeys = [
            "provider",
            "suppressExceptions",
            "verificationFallback",
          ]);
        class s {
          constructor(e, t, n) {
            (this.type = e), (this.expected = t), (this.received = n);
          }
        }
        (t.SiweError = s),
          ((n = t.SiweErrorType || (t.SiweErrorType = {})).EXPIRED_MESSAGE =
            "Expired message."),
          (n.INVALID_DOMAIN = "Invalid domain."),
          (n.SCHEME_MISMATCH =
            "Scheme does not match provided scheme for verification."),
          (n.DOMAIN_MISMATCH =
            "Domain does not match provided domain for verification."),
          (n.NONCE_MISMATCH =
            "Nonce does not match provided nonce for verification."),
          (n.INVALID_ADDRESS = "Invalid address."),
          (n.INVALID_URI = "URI does not conform to RFC 3986."),
          (n.INVALID_NONCE =
            "Nonce size smaller then 8 characters or is not alphanumeric."),
          (n.NOT_YET_VALID_MESSAGE = "Message is not valid yet."),
          (n.INVALID_SIGNATURE =
            "Signature does not match address of the message."),
          (n.INVALID_TIME_FORMAT = "Invalid time format."),
          (n.INVALID_MESSAGE_VERSION = "Invalid message version."),
          (n.UNABLE_TO_PARSE = "Unable to parse the message.");
      },
      56564: function (e, t, n) {
        "use strict";
        var s =
          (this && this.__awaiter) ||
          function (e, t, n, s) {
            return new (n || (n = Promise))(function (i, a) {
              function o(e) {
                try {
                  u(s.next(e));
                } catch (e) {
                  a(e);
                }
              }
              function l(e) {
                try {
                  u(s.throw(e));
                } catch (e) {
                  a(e);
                }
              }
              function u(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value) instanceof n
                      ? t
                      : new n(function (e) {
                          e(t);
                        })
                    ).then(o, l);
              }
              u((s = s.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.checkInvalidKeys =
            t.isValidISO8601Date =
            t.generateNonce =
            t.checkContractWalletSignature =
              void 0);
        let i = n(31416),
          a = n(59237),
          o = n(31422),
          l = [
            "function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)",
          ],
          u =
            /^(?<date>[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(.[0-9]+)?(([Zz])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
        (t.checkContractWalletSignature = (e, t, n) =>
          s(void 0, void 0, void 0, function* () {
            if (!n) return !1;
            let s = new a.Contract(e.address, l, n),
              i = (0, o.hashMessage)(e.prepareMessage());
            return (yield s.isValidSignature(i, t)) === "0x1626ba7e";
          })),
          (t.generateNonce = () => {
            let e = (0, i.randomStringForEntropy)(96);
            if (!e || e.length < 8) throw Error("Error during nonce creation.");
            return e;
          }),
          (t.isValidISO8601Date = (e) => {
            let t = u.exec(e);
            if (!e) return !1;
            let n = new Date(t.groups.date).toISOString(),
              s = u.exec(n);
            return t.groups.date === s.groups.date;
          }),
          (t.checkInvalidKeys = (e, t) => {
            let n = [];
            return (
              Object.keys(e).forEach((e) => {
                t.includes(e) || n.push(e);
              }),
              n
            );
          });
      },
      80481: function (e, t, n) {
        !(function (e) {
          "use strict";
          (e.exports.is_uri = n),
            (e.exports.is_http_uri = s),
            (e.exports.is_https_uri = i),
            (e.exports.is_web_uri = a),
            (e.exports.isUri = n),
            (e.exports.isHttpUri = s),
            (e.exports.isHttpsUri = i),
            (e.exports.isWebUri = a);
          var t = function (e) {
            return e.match(
              /(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/
            );
          };
          function n(e) {
            if (
              !(
                !e ||
                /[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(
                  e
                ) ||
                /%[^0-9a-f]/i.test(e) ||
                /%[0-9a-f](:?[^0-9a-f]|$)/i.test(e)
              )
            ) {
              var n = [],
                s = "",
                i = "",
                a = "",
                o = "",
                l = "",
                u = "";
              if (
                ((s = (n = t(e))[1]),
                (i = n[2]),
                (a = n[3]),
                (o = n[4]),
                (l = n[5]),
                s && s.length && a.length >= 0)
              ) {
                if (i && i.length) {
                  if (!(0 === a.length || /^\//.test(a))) return;
                } else if (/^\/\//.test(a)) return;
                if (/^[a-z][a-z0-9\+\-\.]*$/.test(s.toLowerCase()))
                  return (
                    (u += s + ":"),
                    i && i.length && (u += "//" + i),
                    (u += a),
                    o && o.length && (u += "?" + o),
                    l && l.length && (u += "#" + l),
                    u
                  );
              }
            }
          }
          function s(e, s) {
            if (n(e)) {
              var i = [],
                a = "",
                o = "",
                l = "",
                u = "",
                c = "",
                d = "",
                h = "";
              if (
                ((a = (i = t(e))[1]),
                (o = i[2]),
                (l = i[3]),
                (c = i[4]),
                (d = i[5]),
                a)
              ) {
                if (s) {
                  if ("https" != a.toLowerCase()) return;
                } else if ("http" != a.toLowerCase()) return;
                if (!o) return;
                return (
                  /:(\d+)$/.test(o) &&
                    ((u = o.match(/:(\d+)$/)[0]), (o = o.replace(/:\d+$/, ""))),
                  (h += a + "://" + o),
                  u && (h += u),
                  (h += l),
                  c && c.length && (h += "?" + c),
                  d && d.length && (h += "#" + d),
                  h
                );
              }
            }
          }
          function i(e) {
            return s(e, !0);
          }
          function a(e) {
            return s(e) || i(e);
          }
        })((e = n.nmd(e)));
      },
      40030: function (e, t) {
        "use strict";
        let n, s, i, a, o, l, u, c, d, h, p, f, g, m, y, b;
        let A = new Map([
          [8217, "apostrophe"],
          [8260, "fraction slash"],
          [12539, "middle dot"],
        ]);
        function w(e) {
          var t;
          let n;
          return (
            (t = (function (e) {
              let t = 0;
              function n() {
                return (e[t++] << 8) | e[t++];
              }
              let s = n(),
                i = 1,
                a = [0, 1];
              for (let e = 1; e < s; e++) a.push((i += n()));
              let o = n(),
                l = t;
              t += o;
              let u = 0,
                c = 0;
              function d() {
                return (
                  0 == u && ((c = (c << 8) | e[t++]), (u = 8)), (c >> --u) & 1
                );
              }
              let h = 2147483648 - 1,
                p = 0;
              for (let e = 0; e < 31; e++) p = (p << 1) | d();
              let f = [],
                g = 0,
                m = 2147483648;
              for (;;) {
                let e = Math.floor(((p - g + 1) * i - 1) / m),
                  t = 0,
                  n = s;
                for (; n - t > 1; ) {
                  let s = (t + n) >>> 1;
                  e < a[s] ? (n = s) : (t = s);
                }
                if (0 == t) break;
                f.push(t);
                let o = g + Math.floor((m * a[t]) / i),
                  l = g + Math.floor((m * a[t + 1]) / i) - 1;
                for (; ((o ^ l) & 1073741824) == 0; )
                  (p = ((p << 1) & h) | d()),
                    (o = (o << 1) & h),
                    (l = ((l << 1) & h) | 1);
                for (; o & ~l & 536870912; )
                  (p = (1073741824 & p) | ((p << 1) & (h >>> 1)) | d()),
                    (o = (o << 1) ^ 1073741824),
                    (l = ((1073741824 ^ l) << 1) | 1073741825);
                (g = o), (m = 1 + l - o);
              }
              let y = s - 4;
              return f.map((t) => {
                switch (t - y) {
                  case 3:
                    return (
                      y + 65792 + ((e[l++] << 16) | (e[l++] << 8) | e[l++])
                    );
                  case 2:
                    return y + 256 + ((e[l++] << 8) | e[l++]);
                  case 1:
                    return y + e[l++];
                  default:
                    return t - 1;
                }
              });
            })(
              (function (e) {
                let t = [];
                [
                  ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                ].forEach((e, n) => (t[e.charCodeAt(0)] = n));
                let n = e.length,
                  s = new Uint8Array((6 * n) >> 3);
                for (let i = 0, a = 0, o = 0, l = 0; i < n; i++)
                  (l = (l << 6) | t[e.charCodeAt(i)]),
                    (o += 6) >= 8 && (s[a++] = l >> (o -= 8));
                return s;
              })(e)
            )),
            (n = 0),
            () => t[n++]
          );
        }
        function v(e, t = 0) {
          let n = [];
          for (;;) {
            let s = e(),
              i = e();
            if (!i) break;
            t += s;
            for (let e = 0; e < i; e++) n.push(t + e);
            t += i + 1;
          }
          return n;
        }
        function E(e) {
          return k(() => {
            let t = v(e);
            if (t.length) return t;
          });
        }
        function P(e) {
          let t = [];
          for (;;) {
            let n = e();
            if (0 == n) break;
            t.push(
              (function (e, t) {
                let n = 1 + t(),
                  s = t(),
                  i = k(t);
                return T(i.length, 1 + e, t).flatMap((e, t) => {
                  let [a, ...o] = e;
                  return Array(i[t])
                    .fill()
                    .map((e, t) => {
                      let i = t * s;
                      return [a + t * n, o.map((e) => e + i)];
                    });
                });
              })(n, e)
            );
          }
          for (;;) {
            let n = e() - 1;
            if (n < 0) break;
            t.push(T(1 + e(), 1 + n, e).map((e) => [e[0], e.slice(1)]));
          }
          return t.flat();
        }
        function k(e) {
          let t = [];
          for (;;) {
            let n = e(t.length);
            if (!n) break;
            t.push(n);
          }
          return t;
        }
        function T(e, t, n) {
          let s = Array(e)
            .fill()
            .map(() => []);
          for (let i = 0; i < t; i++)
            (function (e, t) {
              let n = Array(e);
              for (let i = 0, a = 0; i < e; i++) {
                var s;
                n[i] = a += 1 & (s = t()) ? ~s >> 1 : s >> 1;
              }
              return n;
            })(e, n).forEach((e, t) => s[t].push(e));
          return s;
        }
        function x(e) {
          return `{${e.toString(16).toUpperCase().padStart(2, "0")}}`;
        }
        function O(e) {
          let t = [];
          for (let n = 0, s = e.length; n < s; ) {
            let s = e.codePointAt(n);
            (n += s < 65536 ? 1 : 2), t.push(s);
          }
          return t;
        }
        function S(e) {
          let t = e.length;
          if (t < 4096) return String.fromCodePoint(...e);
          let n = [];
          for (let s = 0; s < t; )
            n.push(String.fromCodePoint(...e.slice(s, (s += 4096))));
          return n.join("");
        }
        function C(e, t) {
          let n = e.length,
            s = n - t.length;
          for (let i = 0; 0 == s && i < n; i++) s = e[i] - t[i];
          return s;
        }
        function B(e) {
          return (e >> 24) & 255;
        }
        function N(e) {
          return 16777215 & e;
        }
        function R(e) {
          return e >= 44032 && e < 55204;
        }
        function I(e) {
          n ||
            (function () {
              let e = w(
                "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g"
              );
              for (let [t, o] of ((n = new Map(
                E(e).flatMap((e, t) => e.map((e) => [e, (t + 1) << 24]))
              )),
              (s = new Set(v(e))),
              (i = new Map()),
              (a = new Map()),
              P(e))) {
                if (!s.has(t) && 2 == o.length) {
                  let [e, n] = o,
                    s = a.get(e);
                  s || ((s = new Map()), a.set(e, s)), s.set(n, t);
                }
                i.set(t, o.reverse());
              }
            })();
          let t = [],
            o = [],
            l = !1;
          function u(e) {
            let s = n.get(e);
            s && ((l = !0), (e |= s)), t.push(e);
          }
          for (let n of e)
            for (;;) {
              if (n < 128) t.push(n);
              else if (R(n)) {
                let e = n - 44032,
                  t = (e / 588) | 0,
                  s = ((e % 588) / 28) | 0,
                  i = e % 28;
                u(4352 + t), u(4449 + s), i > 0 && u(4519 + i);
              } else {
                let e = i.get(n);
                e ? o.push(...e) : u(n);
              }
              if (!o.length) break;
              n = o.pop();
            }
          if (l && t.length > 1) {
            let e = B(t[0]);
            for (let n = 1; n < t.length; n++) {
              let s = B(t[n]);
              if (0 == s || e <= s) {
                e = s;
                continue;
              }
              let i = n - 1;
              for (;;) {
                let n = t[i + 1];
                if (((t[i + 1] = t[i]), (t[i] = n), !i || (e = B(t[--i])) <= s))
                  break;
              }
              e = B(t[n]);
            }
          }
          return t;
        }
        function M(e) {
          return I(e).map(N);
        }
        function L(e) {
          return (function (e) {
            let t = [],
              n = [],
              s = -1,
              i = 0;
            for (let o of e) {
              let e = B(o),
                l = N(o);
              if (-1 == s) 0 == e ? (s = l) : t.push(l);
              else if (i > 0 && i >= e)
                0 == e ? (t.push(s, ...n), (n.length = 0), (s = l)) : n.push(l),
                  (i = e);
              else {
                let o = (function (e, t) {
                  if (e >= 4352 && e < 4371 && t >= 4449 && t < 4470)
                    return 44032 + (e - 4352) * 588 + (t - 4449) * 28;
                  if (R(e) && t > 4519 && t < 4547 && (e - 44032) % 28 == 0)
                    return e + (t - 4519);
                  {
                    let n = a.get(e);
                    return n && (n = n.get(t)) ? n : -1;
                  }
                })(s, l);
                o >= 0
                  ? (s = o)
                  : 0 == i && 0 == e
                  ? (t.push(s), (s = l))
                  : (n.push(l), (i = e));
              }
            }
            return s >= 0 && t.push(s, ...n), t;
          })(I(e));
        }
        let _ = (e) => Array.from(e);
        function F(e, t) {
          return e.P.has(t) || e.Q.has(t);
        }
        class D extends Array {
          get is_emoji() {
            return !0;
          }
        }
        function U() {
          let e, t;
          if (o) return;
          let n = w(
              "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI"
            ),
            s = () => v(n),
            i = () => new Set(s()),
            a = (e, t) => t.forEach((t) => e.add(t));
          (o = new Map(P(n))),
            (l = i()),
            (u = s()),
            (c = new Set(s().map((e) => u[e]))),
            (u = new Set(u)),
            (d = i()),
            (h = i());
          let A = E(n),
            T = n(),
            x = () => {
              let e = new Set();
              return s().forEach((t) => a(e, A[t])), a(e, s()), e;
            };
          (p = k((e) => {
            let t = k(n).map((e) => e + 96);
            if (t.length) {
              let s = e >= T;
              return (
                (t[0] -= 32),
                (t = S(t)),
                s && (t = `Restricted[${t}]`),
                { N: t, P: x(), Q: x(), M: !n(), R: s }
              );
            }
          })),
            (f = i()),
            (g = new Map());
          let O = s()
            .concat(_(f))
            .sort((e, t) => e - t);
          for (let { V: e, M: t } of (O.forEach((e, t) => {
            let s = n(),
              i = (O[t] = s ? O[t - s] : { V: [], M: new Map() });
            i.V.push(e), f.has(e) || g.set(e, i);
          }),
          new Set(g.values()))) {
            let n = [];
            for (let t of e) {
              let e = p.filter((e) => F(e, t)),
                s = n.find(({ G: t }) => e.some((e) => t.has(e)));
              s || ((s = { G: new Set(), V: [] }), n.push(s)),
                s.V.push(t),
                a(s.G, e);
            }
            let s = n.flatMap((e) => _(e.G));
            for (let { G: e, V: i } of n) {
              let n = new Set(s.filter((t) => !e.has(t)));
              for (let e of i) t.set(e, n);
            }
          }
          m = new Set();
          let B = new Set(),
            N = (e) => (m.has(e) ? B.add(e) : m.add(e));
          for (let e of p) {
            for (let t of e.P) N(t);
            for (let t of e.Q) N(t);
          }
          for (let e of m) g.has(e) || B.has(e) || g.set(e, 1);
          for (let s of (a(m, M(m)),
          (y = ((e = []),
          (t = v(n)),
          (function t({ S: n, B: s }, i, a) {
            if (!(4 & n) || a !== i[i.length - 1])
              for (let o of (2 & n && (a = i[i.length - 1]),
              1 & n && e.push(i),
              s))
                for (let e of o.Q) t(o, [...i, e], a);
          })(
            (function e(s) {
              return {
                S: n(),
                B: k(() => {
                  let s = v(n).map((e) => t[e]);
                  if (s.length) return e(s);
                }),
                Q: s,
              };
            })([]),
            []
          ),
          e)
            .map((e) => D.from(e))
            .sort(C)),
          (b = new Map()),
          y)) {
            let e = [b];
            for (let t of s) {
              let n = e.map((e) => {
                let n = e.get(t);
                return n || ((n = new Map()), e.set(t, n)), n;
              });
              65039 === t ? e.push(...n) : (e = n);
            }
            for (let t of e) t.V = s;
          }
        }
        function j(e) {
          return (K(e) ? "" : `${H($([e]))} `) + x(e);
        }
        function H(e) {
          return `"${e}"\u200E`;
        }
        function $(e, t = 1 / 0, n = x) {
          let s = [];
          G(e[0]) && s.push("◌"),
            e.length > t &&
              ((t >>= 1), (e = [...e.slice(0, t), 8230, ...e.slice(-t)]));
          let i = 0,
            a = e.length;
          for (let t = 0; t < a; t++) {
            let a = e[t];
            K(a) && (s.push(S(e.slice(i, t))), s.push(n(a)), (i = t + 1));
          }
          return s.push(S(e.slice(i, a))), s.join("");
        }
        function G(e) {
          return U(), u.has(e);
        }
        function K(e) {
          return U(), d.has(e);
        }
        function V(e, t, n) {
          if (!e) return [];
          U();
          let s = 0;
          return e.split(".").map((e) => {
            let i = O(e),
              a = { input: i, offset: s };
            s += i.length + 1;
            try {
              let e,
                s = (a.tokens = W(i, t, n)),
                o = s.length;
              if (!o) throw Error("empty label");
              let l = (a.output = s.flat());
              if (
                ((function (e) {
                  for (let t = e.lastIndexOf(95); t > 0; )
                    if (95 !== e[--t])
                      throw Error("underscore allowed only at start");
                })(l),
                !(a.emoji = o > 1 || s[0].is_emoji) && l.every((e) => e < 128))
              )
                (function (e) {
                  if (e.length >= 4 && 45 == e[2] && 45 == e[3])
                    throw Error(
                      `invalid label extension: "${S(e.slice(0, 4))}"`
                    );
                })(l),
                  (e = "ASCII");
              else {
                let t = s.flatMap((e) => (e.is_emoji ? [] : e));
                if (t.length) {
                  if (u.has(l[0])) throw q("leading combining mark");
                  for (let e = 1; e < o; e++) {
                    let t = s[e];
                    if (!t.is_emoji && u.has(t[0]))
                      throw q(
                        `emoji + combining mark: "${S(s[e - 1])} + ${$([
                          t[0],
                        ])}"`
                      );
                  }
                  !(function (e) {
                    let t = e[0],
                      n = A.get(t);
                    if (n) throw q(`leading ${n}`);
                    let s = e.length,
                      i = -1;
                    for (let a = 1; a < s; a++) {
                      t = e[a];
                      let s = A.get(t);
                      if (s) {
                        if (i == a) throw q(`${n} + ${s}`);
                        (i = a + 1), (n = s);
                      }
                    }
                    if (i == s) throw q(`trailing ${n}`);
                  })(l);
                  let n = _(new Set(t)),
                    [i] = (function (e) {
                      let t = p;
                      for (let n of e) {
                        let e = t.filter((e) => F(e, n));
                        if (!e.length) {
                          if (p.some((e) => F(e, n))) throw Q(t[0], n);
                          throw J(n);
                        }
                        if (((t = e), 1 == e.length)) break;
                      }
                      return t;
                    })(n);
                  (function (e, t) {
                    for (let n of t) if (!F(e, n)) throw Q(e, n);
                    if (e.M) {
                      let e = M(t);
                      for (let t = 1, n = e.length; t < n; t++)
                        if (c.has(e[t])) {
                          let s = t + 1;
                          for (let i; s < n && c.has((i = e[s])); s++)
                            for (let n = t; n < s; n++)
                              if (e[n] == i)
                                throw Error(
                                  `duplicate non-spacing marks: ${j(i)}`
                                );
                          if (s - t > 4)
                            throw Error(
                              `excessive non-spacing marks: ${H(
                                $(e.slice(t - 1, s))
                              )} (${s - t}/4)`
                            );
                          t = s;
                        }
                    }
                  })(i, t),
                    (function (e, t) {
                      let n;
                      let s = [];
                      for (let e of t) {
                        let t = g.get(e);
                        if (1 === t) return;
                        if (t) {
                          let s = t.M.get(e);
                          if (
                            !(n = n ? n.filter((e) => s.has(e)) : _(s)).length
                          )
                            return;
                        } else s.push(e);
                      }
                      if (n) {
                        for (let t of n)
                          if (s.every((e) => F(t, e)))
                            throw Error(
                              `whole-script confusable: ${e.N}/${t.N}`
                            );
                      }
                    })(i, n),
                    (e = i.N);
                } else e = "Emoji";
              }
              a.type = e;
            } catch (e) {
              a.error = e;
            }
            return a;
          });
        }
        function z(e) {
          return e
            .map(({ input: t, error: n, output: s }) => {
              if (n) {
                let s = n.message;
                throw Error(
                  1 == e.length ? s : `Invalid label ${H($(t, 63))}: ${s}`
                );
              }
              return S(s);
            })
            .join(".");
        }
        function J(e) {
          return Error(`disallowed character: ${j(e)}`);
        }
        function Q(e, t) {
          let n = j(t),
            s = p.find((e) => e.P.has(t));
          return (
            s && (n = `${s.N} ${n}`), Error(`illegal mixture: ${e.N} + ${n}`)
          );
        }
        function q(e) {
          return Error(`illegal placement: ${e}`);
        }
        function W(e, t, n) {
          let s = [],
            i = [];
          for (e = e.slice().reverse(); e.length; ) {
            let a = Z(e);
            if (a) i.length && (s.push(t(i)), (i = [])), s.push(n(a));
            else {
              let t = e.pop();
              if (m.has(t)) i.push(t);
              else {
                let e = o.get(t);
                if (e) i.push(...e);
                else if (!l.has(t)) throw J(t);
              }
            }
          }
          return i.length && s.push(t(i)), s;
        }
        function Y(e) {
          return e.filter((e) => 65039 != e);
        }
        function Z(e, t) {
          let n,
            s = b,
            i = e.length;
          for (; i && (s = s.get(e[--i])); ) {
            let { V: a } = s;
            a &&
              ((n = a), t && t.push(...e.slice(i).reverse()), (e.length = i));
          }
          return n;
        }
        let X = "valid",
          ee = "mapped",
          et = "ignored";
        function er(e) {
          return e == X || e == ee;
        }
        function en(e) {
          return e.some((e) => h.has(e));
        }
        function es(e) {
          for (let t = 0; t < e.length; t++)
            if (e[t].type == X) {
              let n = t + 1;
              for (; n < e.length && e[n].type == X; ) n++;
              e.splice(t, n - t, {
                type: X,
                cps: e.slice(t, n).flatMap((e) => e.cps),
              });
            }
          return e;
        }
        (t.ens_beautify = function (e) {
          let t = V(e, L, (e) => e);
          for (let { type: e, output: n, error: s } of t) {
            if (s) break;
            "Greek" !== e &&
              (function (e, t, n) {
                let s = 0;
                for (;;) {
                  let t = e.indexOf(958, s);
                  if (t < 0) break;
                  (e[t] = 926), (s = t + 1);
                }
              })(n, 0, 0);
          }
          return z(t);
        }),
          (t.ens_emoji = function () {
            return U(), y.map((e) => e.slice());
          }),
          (t.ens_normalize = function (e) {
            return z(V(e, L, Y));
          }),
          (t.ens_normalize_fragment = function (e, t) {
            U();
            let n = t ? M : L;
            return e
              .split(".")
              .map((e) => S(W(O(e), n, Y).flat()))
              .join(".");
          }),
          (t.ens_split = function (e, t) {
            return V(e, L, t ? (e) => e.slice() : Y);
          }),
          (t.ens_tokenize = function e(t, { nf: n = !0 } = {}) {
            U();
            let s = O(t).reverse(),
              i = [],
              a = [];
            for (; s.length; ) {
              let e = Z(s, i);
              if (e)
                a.push({
                  type: "emoji",
                  emoji: e.slice(),
                  input: i,
                  cps: Y(e),
                }),
                  (i = []);
              else {
                let e = s.pop();
                if (46 == e) a.push({ type: "stop", cp: e });
                else if (m.has(e)) a.push({ type: X, cps: [e] });
                else if (l.has(e)) a.push({ type: et, cp: e });
                else {
                  let t = o.get(e);
                  t
                    ? a.push({ type: ee, cp: e, cps: t.slice() })
                    : a.push({ type: "disallowed", cp: e });
                }
              }
            }
            if (n)
              for (let t = 0, n = -1; t < a.length; t++) {
                let s = a[t];
                if (er(s.type)) {
                  if (en(s.cps)) {
                    let s = t + 1;
                    for (let e = s; e < a.length; e++) {
                      let { type: t, cps: n } = a[e];
                      if (er(t)) {
                        if (!en(n)) break;
                        s = e + 1;
                      } else if (t !== et) break;
                    }
                    n < 0 && (n = t);
                    let i = a.slice(n, s),
                      o = i.flatMap((e) => (er(e.type) ? e.cps : [])),
                      l = L(o);
                    C(l, o)
                      ? (a.splice(n, s - n, {
                          type: "nfc",
                          input: o,
                          cps: l,
                          tokens0: es(i),
                          tokens: e(S(l), { nf: !1 }),
                        }),
                        (t = n))
                      : (t = s - 1),
                      (n = -1);
                  } else n = t;
                } else s.type !== et && (n = -1);
              }
            return es(a);
          }),
          (t.is_combining_mark = G),
          (t.nfc = L),
          (t.nfd = M),
          (t.safe_str_from_cps = $),
          (t.should_escape = K);
      },
      40517: function (e, t) {
        "use strict";
        var n,
          s,
          i,
          a =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, n, s) {
              if ("a" === n && !s)
                throw TypeError(
                  "Private accessor was defined without a getter"
                );
              if ("function" == typeof t ? e !== t || !s : !t.has(e))
                throw TypeError(
                  "Cannot read private member from an object whose class did not declare it"
                );
              return "m" === n
                ? s
                : "a" === n
                ? s.call(e)
                : s
                ? s.value
                : t.get(e);
            },
          o =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, n, s, i) {
              if ("m" === s) throw TypeError("Private method is not writable");
              if ("a" === s && !i)
                throw TypeError(
                  "Private accessor was defined without a setter"
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw TypeError(
                  "Cannot write private member to an object whose class did not declare it"
                );
              return (
                "a" === s ? i.call(e, n) : i ? (i.value = n) : t.set(e, n), n
              );
            };
        Object.defineProperty(t, "__esModule", { value: !0 }), (t.AES = void 0);
        let l = { 16: 10, 24: 12, 32: 14 },
          u = [
            1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94,
            188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145,
          ],
          c = [
            99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215,
            171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175,
            156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165,
            229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18,
            128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82,
            59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91,
            106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51,
            133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157,
            56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95,
            151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220,
            34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58,
            10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200,
            55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8,
            186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189,
            139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134,
            193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135,
            233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65,
            153, 45, 15, 176, 84, 187, 22,
          ],
          d = [
            82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215,
            251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196,
            222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11,
            66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162,
            73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212,
            164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185,
            218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188,
            211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202,
            63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79,
            103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172,
            116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110,
            71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190,
            27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120,
            205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89,
            39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122,
            159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200,
            235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38,
            225, 105, 20, 99, 85, 33, 12, 125,
          ],
          h = [
            3328402341, 4168907908, 4000806809, 4135287693, 4294111757,
            3597364157, 3731845041, 2445657428, 1613770832, 33620227,
            3462883241, 1445669757, 3892248089, 3050821474, 1303096294,
            3967186586, 2412431941, 528646813, 2311702848, 4202528135,
            4026202645, 2992200171, 2387036105, 4226871307, 1101901292,
            3017069671, 1604494077, 1169141738, 597466303, 1403299063,
            3832705686, 2613100635, 1974974402, 3791519004, 1033081774,
            1277568618, 1815492186, 2118074177, 4126668546, 2211236943,
            1748251740, 1369810420, 3521504564, 4193382664, 3799085459,
            2883115123, 1647391059, 706024767, 134480908, 2512897874,
            1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301,
            235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841,
            2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870,
            907746093, 3698224818, 3025820398, 1537253627, 2756858614,
            1983593293, 3084310113, 2108928974, 1378429307, 3722699582,
            1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436,
            1075847264, 3825007647, 2041688520, 3059440621, 3563743934,
            2378943302, 1740553945, 1916352843, 2487896798, 2555137236,
            2958579944, 2244988746, 3151024235, 3320835882, 1336584933,
            3992714006, 2252555205, 2588757463, 1714631509, 293963156,
            2319795663, 3925473552, 67240454, 4269768577, 2689618160,
            2017213508, 631218106, 1269344483, 2723238387, 1571005438,
            2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100,
            1673313503, 2008463041, 2950355573, 1109467491, 537923632,
            3858759450, 4260623118, 3218264685, 2177748300, 403442708,
            638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209,
            2479146071, 1437050866, 4236148354, 2050833735, 3362022572,
            3126681063, 840505643, 3866325909, 3227541664, 427917720,
            2655997905, 2749160575, 1143087718, 1412049534, 999329963,
            193497219, 2353415882, 3354324521, 1807268051, 672404540,
            2816401017, 3160301282, 369822493, 2916866934, 3688947771,
            1681011286, 1949973070, 336202270, 2454276571, 201721354,
            1210328172, 3093060836, 2680341085, 3184776046, 1135389935,
            3294782118, 965841320, 831886756, 3554993207, 4068047243,
            3588745010, 2345191491, 1849112409, 3664604599, 26054028,
            2983581028, 2622377682, 1235855840, 3630984372, 2891339514,
            4092916743, 3488279077, 3395642799, 4101667470, 1202630377,
            268961816, 1874508501, 4034427016, 1243948399, 1546530418,
            941366308, 1470539505, 1941222599, 2546386513, 3421038627,
            2715671932, 3899946140, 1042226977, 2521517021, 1639824860,
            227249030, 260737669, 3765465232, 2084453954, 1907733956,
            3429263018, 2420656344, 100860677, 4160157185, 470683154,
            3261161891, 1781871967, 2924959737, 1773779408, 394692241,
            2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851,
            571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662,
            1008606754, 361203602, 3387549984, 2278477385, 2857719295,
            1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935,
            1707065306, 3622233649, 2218934982, 3496503480, 2185314755,
            697932208, 1512910199, 504303377, 2075177163, 2824099068,
            1841019862, 739644986,
          ],
          p = [
            2781242211, 2230877308, 2582542199, 2381740923, 234877682,
            3184946027, 2984144751, 1418839493, 1348481072, 50462977,
            2848876391, 2102799147, 434634494, 1656084439, 3863849899,
            2599188086, 1167051466, 2636087938, 1082771913, 2281340285,
            368048890, 3954334041, 3381544775, 201060592, 3963727277,
            1739838676, 4250903202, 3930435503, 3206782108, 4149453988,
            2531553906, 1536934080, 3262494647, 484572669, 2923271059,
            1783375398, 1517041206, 1098792767, 49674231, 1334037708,
            1550332980, 4098991525, 886171109, 150598129, 2481090929,
            1940642008, 1398944049, 1059722517, 201851908, 1385547719,
            1699095331, 1587397571, 674240536, 2704774806, 252314885,
            3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483,
            1766729511, 3447698098, 2682942837, 454166793, 2652734339,
            1951935532, 775166490, 758520603, 3000790638, 4004797018,
            4217086112, 4137964114, 1299594043, 1639438038, 3464344499,
            2068982057, 1054729187, 1901997871, 2534638724, 4121318227,
            1757008337, 0, 750906861, 1614815264, 535035132, 3363418545,
            3988151131, 3201591914, 1183697867, 3647454910, 1265776953,
            3734260298, 3566750796, 3903871064, 1250283471, 1807470800,
            717615087, 3847203498, 384695291, 3313910595, 3617213773,
            1432761139, 2484176261, 3481945413, 283769337, 100925954,
            2180939647, 4037038160, 1148730428, 3123027871, 3813386408,
            4087501137, 4267549603, 3229630528, 2315620239, 2906624658,
            3156319645, 1215313976, 82966005, 3747855548, 3245848246,
            1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890,
            1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207,
            3431482436, 959321879, 1469301956, 4065699751, 2197585534,
            1199193405, 2898814052, 3887750493, 724703513, 2514908019,
            2696962144, 2551808385, 3516813135, 2141445340, 1715741218,
            2119445034, 2872807568, 2198571144, 3398190662, 700968686,
            3547052216, 1009259540, 2041044702, 3803995742, 487983883,
            1991105499, 1004265696, 1449407026, 1316239930, 504629770,
            3683797321, 168560134, 1816667172, 3837287516, 1570751170,
            1857934291, 4014189740, 2797888098, 2822345105, 2754712981,
            936633572, 2347923833, 852879335, 1133234376, 1500395319,
            3084545389, 2348912013, 1689376213, 3533459022, 3762923945,
            3034082412, 4205598294, 133428468, 634383082, 2949277029,
            2398386810, 3913789102, 403703816, 3580869306, 2297460856,
            1867130149, 1918643758, 607656988, 4049053350, 3346248884,
            1368901318, 600565992, 2090982877, 2632479860, 557719327,
            3717614411, 3697393085, 2249034635, 2232388234, 2430627952,
            1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830,
            303828494, 2747425121, 1600795957, 4188952407, 3496589753,
            2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800,
            3005978776, 857870609, 3151128937, 1890179545, 2298973838,
            2805175444, 3056442267, 574365214, 2450884487, 550103529,
            1233637070, 4289353045, 2018519080, 2057691103, 2399374476,
            4166623649, 2148108681, 387583245, 3664101311, 836232934,
            3330556482, 3100665960, 3280093505, 2955516313, 2002398509,
            287182607, 3413881008, 4238890068, 3597515707, 975967766,
          ],
          f = [
            1671808611, 2089089148, 2006576759, 2072901243, 4061003762,
            1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671,
            729634347, 4263110654, 3613570519, 2883997099, 1989864566,
            3393556426, 2191335298, 3376449993, 2106063485, 4195741690,
            1508618841, 1204391495, 4027317232, 2917941677, 3563566036,
            2734514082, 2951366063, 2629772188, 2767672228, 1922491506,
            3227229120, 3082974647, 4246528509, 2477669779, 644500518,
            911895606, 1061256767, 4144166391, 3427763148, 878471220,
            2784252325, 3845444069, 4043897329, 1905517169, 3631459288,
            827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891,
            405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066,
            2157648768, 3795705826, 3945188843, 661212711, 2999812018,
            1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803,
            1857215598, 1525593178, 2700827552, 1391895634, 994932283,
            3596728278, 3016654259, 695947817, 3812548067, 795958831,
            2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784,
            4229948412, 2982705585, 1542305371, 1790891114, 3410398667,
            3201918910, 961245753, 1256100938, 1289001036, 1491644504,
            3477767631, 3496721360, 4012557807, 2867154858, 4212583931,
            1137018435, 1305975373, 861234739, 2241073541, 1171229253,
            4178635257, 33948674, 2139225727, 1357946960, 1011120188,
            2679776671, 2833468328, 1374921297, 2751356323, 1086357568,
            2408187279, 2460827538, 2646352285, 944271416, 4110742005,
            3168756668, 3066132406, 3665145818, 560153121, 271589392,
            4279952895, 4077846003, 3530407890, 3444343245, 202643468,
            322250259, 3962553324, 1608629855, 2543990167, 1154254916,
            389623319, 3294073796, 2817676711, 2122513534, 1028094525,
            1689045092, 1575467613, 422261273, 1939203699, 1621147744,
            2174228865, 1339137615, 3699352540, 577127458, 712922154,
            2427141008, 2290289544, 1187679302, 3995715566, 3100863416,
            339486740, 3732514782, 1591917662, 186455563, 3681988059,
            3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734,
            611076132, 1558493276, 3260915650, 3547250131, 2901361580,
            1655096418, 2443721105, 2510565781, 3828863972, 2039214713,
            3878868455, 3359869896, 928607799, 1840765549, 2374762893,
            3580146133, 1322425422, 2850048425, 1823791212, 1459268694,
            4094161908, 3928346602, 1706019429, 2056189050, 2934523822,
            135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708,
            2800834470, 3032970164, 3327236038, 3894660072, 3715932637,
            1956440180, 522272287, 1272813131, 3185336765, 2340818315,
            2323976074, 1888542832, 1044544574, 3049550261, 1722469478,
            1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557,
            1475980887, 3117443513, 2257655686, 3243809217, 489110045,
            2662934430, 3778599393, 4162055160, 2561878936, 288563729,
            1773916777, 3648039385, 2391345038, 2493985684, 2612407707,
            505560094, 2274497927, 3911240169, 3460925390, 1442818645,
            678973480, 3749357023, 2358182796, 2717407649, 2306869641,
            219617805, 3218761151, 3862026214, 1120306242, 1756942440,
            1103331905, 2578459033, 762796589, 252780047, 2966125488,
            1425844308, 3151392187, 372911126,
          ],
          g = [
            1667474886, 2088535288, 2004326894, 2071694838, 4075949567,
            1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926,
            724270422, 4278065639, 3621216949, 2880169549, 1987484396,
            3402253711, 2189597983, 3385409673, 2105378810, 4210693615,
            1499065266, 1195886990, 4042263547, 2913856577, 3570689971,
            2728590687, 2947541573, 2627518243, 2762274643, 1920112356,
            3233831835, 3082273397, 4261223649, 2475929149, 640051788,
            909531756, 1061110142, 4160160501, 3435941763, 875846760,
            2779116625, 3857003729, 4059105529, 1903268834, 3638064043,
            825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861,
            404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396,
            2155911963, 3806477791, 3958056653, 656894286, 2998062463,
            1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878,
            1852748508, 1515908788, 2694904667, 1381168804, 993742198,
            3604373943, 3014905469, 690584402, 3823320797, 791638366,
            2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704,
            4244381667, 2981218425, 1532751286, 1785380564, 3419096717,
            3200178535, 960056178, 1246420628, 1280103576, 1482221744,
            3486468741, 3503319995, 4025428677, 2863326543, 4227536621,
            1128514950, 1296947098, 859002214, 2240123921, 1162203018,
            4193849577, 33687044, 2139062782, 1347481760, 1010582648,
            2678045221, 2829640523, 1364325282, 2745433693, 1077985408,
            2408548869, 2459086143, 2644360225, 943212656, 4126475505,
            3166494563, 3065430391, 3671750063, 555836226, 269496352,
            4294908645, 4092792573, 3537006015, 3452783745, 202118168,
            320025894, 3974901699, 1600119230, 2543297077, 1145359496,
            387397934, 3301201811, 2812801621, 2122220284, 1027426170,
            1684319432, 1566435258, 421079858, 1936954854, 1616945344,
            2172753945, 1330631070, 3705438115, 572679748, 707427924,
            2425400123, 2290647819, 1179044492, 4008585671, 3099120491,
            336870440, 3739122087, 1583276732, 185277718, 3688593069,
            3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084,
            606366792, 1549591736, 3267517855, 3553849021, 2897014595,
            1650632388, 2442242105, 2509612081, 3840161747, 2038008818,
            3890688725, 3368567691, 926374254, 1835907034, 2374863873,
            3587531953, 1313788572, 2846482505, 1819063512, 1448540844,
            4109633523, 3941213647, 1701162954, 2054852340, 2930698567,
            134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328,
            2795958615, 3031746419, 3334885783, 3907527627, 3722280097,
            1953799400, 522133822, 1263263126, 3183336545, 2341176845,
            2324333839, 1886425312, 1044267644, 3048588401, 1718004428,
            1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282,
            1465383342, 3115962473, 2256965911, 3250673817, 488449850,
            2661202215, 3789633753, 4177007595, 2560144171, 286339874,
            1768537042, 3654906025, 2391705863, 2492770099, 2610673197,
            505291324, 2273808917, 3924369609, 3469625735, 1431699370,
            673740880, 3755965093, 2358021891, 2711746649, 2307489801,
            218961690, 3217021541, 3873845719, 1111672452, 1751693520,
            1094828930, 2576986153, 757954394, 252645662, 2964376443,
            1414855848, 3149649517, 370555436,
          ],
          m = [
            1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753,
            2902087851, 1273168787, 540080725, 2910219766, 2295101073,
            4110568485, 1340463100, 3307916247, 641025152, 3043140495,
            3736164937, 632953703, 1172967064, 1576976609, 3274667266,
            2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147,
            2505202138, 3569255213, 1484005843, 1239443753, 2395588676,
            1975683434, 4102977912, 2572697195, 666464733, 3202437046,
            4035489047, 3374361702, 2110667444, 1675577880, 3843699074,
            2538681184, 1649639237, 2976151520, 3144396420, 4269907996,
            4178062228, 1883793496, 2403728665, 2497604743, 1383856311,
            2876494627, 1917518562, 3810496343, 1716890410, 3001755655,
            800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362,
            3977675356, 2328828971, 2809771154, 4077384432, 1315562145,
            1708848333, 101039829, 3509871135, 3299278474, 875451293,
            2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582,
            3178106961, 1042385657, 2531067453, 3711829422, 1306967366,
            2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327,
            2302690252, 1742315127, 2968011453, 126454664, 3877198648,
            2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987,
            841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998,
            908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497,
            2472011535, 3035535058, 463180190, 2160117071, 1641816226,
            1517767529, 470948374, 3801332234, 3231722213, 1008918595,
            303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501,
            2943682380, 4003061179, 2743034109, 4144047775, 1551037884,
            1147550661, 1543208500, 2336434550, 3408119516, 3069049960,
            3102011747, 3610369226, 1113818384, 328671808, 2227573024,
            2236228733, 3535486456, 2935566865, 3341394285, 496906059,
            3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682,
            1206477858, 2835123396, 2700099354, 1451044056, 573804783,
            2269728455, 3644379585, 2362090238, 2564033334, 2801107407,
            2776292904, 3669462566, 1068351396, 742039012, 1350078989,
            1784663195, 1417561698, 4136440770, 2430122216, 775550814,
            2193862645, 2673705150, 1775276924, 1876241833, 3475313331,
            3366754619, 270040487, 3902563182, 3678124923, 3441850377,
            1851332852, 3969562369, 2203032232, 3868552805, 2868897406,
            566021896, 4011190502, 3135740889, 1248802510, 3936291284,
            699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047,
            4236429990, 3767586992, 866637845, 4043610186, 1106041591,
            2144161806, 395441711, 1984812685, 1139781709, 3433712980,
            3835036895, 2664543715, 1282050075, 3240894392, 1181045119,
            2640243204, 25965917, 4203181171, 4211818798, 3009879386,
            2463879762, 3910161971, 1842759443, 2597806476, 933301370,
            1509430414, 3943906441, 3467192302, 3076639029, 3776767469,
            2051518780, 2631065433, 1441952575, 404016761, 1942435775,
            1408749034, 1610459739, 3745345300, 2017778566, 3400528769,
            3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627,
            4279080257, 967311729, 135050206, 3635733660, 1683407248,
            2076935265, 3576870512, 1215061108, 3501741890,
          ],
          y = [
            1347548327, 1400783205, 3273267108, 2520393566, 3409685355,
            4045380933, 2880240216, 2471224067, 1428173050, 4138563181,
            2441661558, 636813900, 4233094615, 3620022987, 2149987652,
            2411029155, 1239331162, 1730525723, 2554718734, 3781033664,
            46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972,
            3955191162, 3667219033, 768917123, 3545789473, 692707433,
            1150208456, 1786102409, 2029293177, 1805211710, 3710368113,
            3065962831, 401639597, 1724457132, 3028143674, 409198410,
            2196052529, 1620529459, 1164071807, 3769721975, 2226875310,
            486441376, 2499348523, 1483753576, 428819965, 2274680428,
            3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120,
            53458370, 2592523643, 2782082824, 4063242375, 2988687269,
            3120694122, 1559041666, 730517276, 2460449204, 4042459122,
            2706270690, 3446004468, 3573941694, 533804130, 2328143614,
            2637442643, 2695033685, 839224033, 1973745387, 957055980,
            2856345839, 106852767, 1371368976, 4181598602, 1033297158,
            2933734917, 1179510461, 3046200461, 91341917, 1862534868,
            4284502037, 605657339, 2547432937, 3431546947, 2003294622,
            3182487618, 2282195339, 954669403, 3682191598, 1201765386,
            3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696,
            1315723890, 4227665663, 1443857720, 507358933, 657861945,
            1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535,
            3535072918, 2652609425, 1333838021, 2724322336, 1767536459,
            370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197,
            2918353863, 3106780840, 3356761769, 2237133081, 1286567175,
            3152976349, 4255350624, 2683765030, 3160175349, 3309594171,
            878443390, 1988838185, 3704300486, 1756818940, 1673061617,
            3403100636, 272786309, 1075025698, 545572369, 2105887268,
            4174560061, 296679730, 1841768865, 1260232239, 4091327024,
            3960309330, 3497509347, 1814803222, 2578018489, 4195456072,
            575138148, 3299409036, 446754879, 3629546796, 4011996048,
            3347532110, 3252238545, 4270639778, 915985419, 3483825537,
            681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820,
            1649704518, 3270937875, 3901806776, 1580087799, 4118987695,
            3198115200, 2087309459, 2842678573, 3016697106, 1003007129,
            2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319,
            2827177882, 1709610350, 2125135846, 136428751, 3874428392,
            3652904859, 3460984630, 3572145929, 3593056380, 2939266226,
            824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152,
            355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630,
            1296297904, 1422699085, 3756299780, 3818836405, 457992840,
            3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353,
            1521706781, 1385356242, 870912086, 325965383, 2358957921,
            2050466060, 2388260884, 2313884476, 4006521127, 901210569,
            3990953189, 1014646705, 1503449823, 1062597235, 2031621326,
            3212035895, 3931371469, 1533017514, 350174575, 2256028891,
            2177544179, 1052338372, 741876788, 1606591296, 1914052035,
            213705253, 2334669897, 1107234197, 1899603969, 3725069491,
            2631447780, 2422494913, 1635502980, 1893020342, 1950903388,
            1120974935,
          ],
          b = [
            2807058932, 1699970625, 2764249623, 1586903591, 1808481195,
            1173430173, 1487645946, 59984867, 4199882800, 1844882806,
            1989249228, 1277555970, 3623636965, 3419915562, 1149249077,
            2744104290, 1514790577, 459744698, 244860394, 3235995134,
            1963115311, 4027744588, 2544078150, 4190530515, 1608975247,
            2627016082, 2062270317, 1507497298, 2200818878, 567498868,
            1764313568, 3359936201, 2305455554, 2037970062, 1047239e3,
            1910319033, 1337376481, 2904027272, 2892417312, 984907214,
            1243112415, 830661914, 861968209, 2135253587, 2011214180,
            2927934315, 2686254721, 731183368, 1750626376, 4246310725,
            1820824798, 4172763771, 3542330227, 48394827, 2404901663,
            2871682645, 671593195, 3254988725, 2073724613, 145085239,
            2280796200, 2779915199, 1790575107, 2187128086, 472615631,
            3029510009, 4075877127, 3802222185, 4107101658, 3201631749,
            1646252340, 4270507174, 1402811438, 1436590835, 3778151818,
            3950355702, 3963161475, 4020912224, 2667994737, 273792366,
            2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892,
            3564045318, 369057872, 4213447064, 3919042237, 1137477952,
            2658625497, 1119727848, 2340947849, 1530455833, 4007360968,
            172466556, 266959938, 516552836, 0, 2256734592, 3980931627,
            1890328081, 1917742170, 4294704398, 945164165, 3575528878,
            958871085, 3647212047, 2787207260, 1423022939, 775562294,
            1739656202, 3876557655, 2530391278, 2443058075, 3310321856,
            547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690,
            387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201,
            122466165, 3720081049, 1627235199, 648017665, 4122762354,
            1002783846, 2117360635, 695634755, 3336358691, 4234721005,
            4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898,
            1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670,
            3822090177, 376187827, 3113855344, 1224348052, 1679968233,
            2361698556, 1058709744, 752375421, 2431590963, 1321699145,
            3519142200, 2734591178, 188127444, 2177869557, 3727205754,
            2384911031, 3215212461, 2648976442, 2450346104, 3432737375,
            1180849278, 331544205, 3102249176, 4150144569, 2952102595,
            2159976285, 2474404304, 766078933, 313773861, 2570832044,
            2108100632, 1668212892, 3145456443, 2013908262, 418672217,
            3070356634, 2594734927, 1852171925, 3867060991, 3473416636,
            3907448597, 2614737639, 919489135, 164948639, 2094410160,
            2997825956, 590424639, 2486224549, 1723872674, 3157750862,
            3399941250, 3501252752, 3625268135, 2555048196, 3673637356,
            1343127501, 4130281361, 3599595085, 2957853679, 1297403050,
            81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974,
            895287692, 1953757831, 1093597963, 492483431, 3528626907,
            1446242576, 1192455638, 1636604631, 209336225, 344873464,
            1015671571, 669961897, 3375740769, 3857572124, 2973530695,
            3747192018, 1933530610, 3464042516, 935293895, 3454686199,
            2858115069, 1863638845, 3683022916, 4085369519, 3292445032,
            875313188, 1080017571, 3279033885, 621591778, 1233856572,
            2504130317, 24197544, 3017672716, 3835484340, 3247465558,
            2220981195, 3060847922, 1551124588, 1463996600,
          ],
          A = [
            4104605777, 1097159550, 396673818, 660510266, 2875968315,
            2638606623, 4200115116, 3808662347, 821712160, 1986918061,
            3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325,
            2975484382, 3122358053, 3926825029, 4274053469, 796197571,
            1290801793, 1184342925, 3556361835, 2405426947, 2459735317,
            1836772287, 1381620373, 3196267988, 1948373848, 3764988233,
            3385345166, 3263785589, 2390325492, 1480485785, 3111247143,
            3780097726, 2293045232, 548169417, 3459953789, 3746175075,
            439452389, 1362321559, 1400849762, 1685577905, 1806599355,
            2174754046, 137073913, 1214797936, 1174215055, 3731654548,
            2079897426, 1943217067, 1258480242, 529487843, 1437280870,
            3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299,
            57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110,
            3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170,
            2330014213, 4142626212, 2213296395, 1626319424, 1906247262,
            1846563261, 562755902, 3708173718, 1040559837, 3871163981,
            1418573201, 3294430577, 114585348, 1343618912, 2566595609,
            3186202582, 1078185097, 3651041127, 3896688048, 2307622919,
            425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0,
            2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775,
            2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204,
            174567692, 1474760595, 4002861748, 2610011675, 3234156416,
            3693126241, 2001430874, 303699484, 2478443234, 2687165888,
            585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284,
            4044981591, 1963412655, 2581445614, 2137062819, 19308535,
            1928707164, 1715193156, 4219352155, 1126790795, 600235211,
            3992742070, 3841024952, 836553431, 1669664834, 2535604243,
            3323011204, 1243905413, 3141400786, 4180808110, 698445255,
            2653899549, 2989552604, 2253581325, 3252932727, 3004591147,
            1891211689, 2487810577, 3915653703, 4237083816, 4030667424,
            2100090966, 865136418, 1229899655, 953270745, 3399679628,
            3557504664, 4118925222, 2061379749, 3079546586, 2915017791,
            983426092, 2022837584, 1607244650, 2118541908, 2366882550,
            3635996816, 972512814, 3283088770, 1568718495, 3499326569,
            3576539503, 621982671, 2895723464, 410887952, 2623762152,
            1002142683, 645401037, 1494807662, 2595684844, 1335535747,
            2507040230, 4293295786, 3167684641, 367585007, 3885750714,
            1865862730, 2668221674, 2960971305, 2763173681, 1059270954,
            2777952454, 2724642869, 1320957812, 2194319100, 2429595872,
            2815956275, 77089521, 3973773121, 3444575871, 2448830231,
            1305906550, 4021308739, 2857194700, 2516901860, 3518358430,
            1787304780, 740276417, 1699839814, 1592394909, 2352307457,
            2272556026, 188821243, 1729977011, 3687994002, 274084841,
            3594982253, 3613494426, 2701949495, 4162096729, 322734571,
            2837966542, 1640576439, 484830689, 1202797690, 3537852828,
            4067639125, 349075736, 3342319475, 4157467219, 4255800159,
            1030690015, 1155237496, 2951971274, 1757691577, 607398968,
            2738905026, 499347990, 3794078908, 1011452712, 227885567,
            2818666809, 213114376, 3034881240, 1455525988, 3414450555,
            850817237, 1817998408, 3092726480,
          ],
          w = [
            0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554,
            708780849, 1883793496, 2118214995, 1817866830, 1649639237,
            1215061108, 1181045119, 1417561698, 1517767529, 3767586992,
            4003061179, 4236429990, 4069246893, 3635733660, 3602770327,
            3299278474, 3400528769, 2430122216, 2664543715, 2362090238,
            2193862645, 2835123396, 2801107407, 3035535058, 3135740889,
            3678124923, 3576870512, 3341394285, 3374361702, 3810496343,
            3977675356, 4279080257, 4043610186, 2876494627, 2776292904,
            3076639029, 3110650942, 2472011535, 2640243204, 2403728665,
            2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847,
            226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501,
            1509430414, 1942435775, 2110667444, 1876241833, 1641816226,
            2910219766, 2743034109, 2976151520, 3211623147, 2505202138,
            2606453969, 2302690252, 2269728455, 3711829422, 3543599269,
            3240894392, 3475313331, 3843699074, 3943906441, 4178062228,
            4144047775, 1306967366, 1139781709, 1374988112, 1610459739,
            1975683434, 2076935265, 1775276924, 1742315127, 1034867998,
            866637845, 566021896, 800440835, 92987698, 193195065, 429456164,
            395441711, 1984812685, 2017778566, 1784663195, 1683407248,
            1315562145, 1080094634, 1383856311, 1551037884, 101039829,
            135050206, 437757123, 337553864, 1042385657, 807962610, 573804783,
            742039012, 2531067453, 2564033334, 2328828971, 2227573024,
            2935566865, 2700099354, 3001755655, 3168937228, 3868552805,
            3902563182, 4203181171, 4102977912, 3736164937, 3501741890,
            3265478751, 3433712980, 1106041591, 1340463100, 1576976609,
            1408749034, 2043211483, 2009195472, 1708848333, 1809054150,
            832877231, 1068351396, 766945465, 599762354, 159417987, 126454664,
            361929877, 463180190, 2709260871, 2943682380, 3178106961,
            3009879386, 2572697195, 2538681184, 2236228733, 2336434550,
            3509871135, 3745345300, 3441850377, 3274667266, 3910161971,
            3877198648, 4110568485, 4211818798, 2597806476, 2497604743,
            2261089178, 2295101073, 2733856160, 2902087851, 3202437046,
            2968011453, 3936291284, 3835036895, 4136440770, 4169408201,
            3535486456, 3702665459, 3467192302, 3231722213, 2051518780,
            1951317047, 1716890410, 1750902305, 1113818384, 1282050075,
            1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761,
            841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234,
            4035489047, 4269907996, 3569255213, 3669462566, 3366754619,
            3332740144, 2631065433, 2463879762, 2160117071, 2395588676,
            2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362,
            270040487, 504459436, 875451293, 975658646, 675039627, 641025152,
            2084704233, 1917518562, 1615861247, 1851332852, 1147550661,
            1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972,
            632953703, 260388950, 25965917, 328671808, 496906059, 1206477858,
            1239443753, 1543208500, 1441952575, 2144161806, 1908694277,
            1675577880, 1842759443, 3610369226, 3644379585, 3408119516,
            3307916247, 4011190502, 3776767469, 4077384432, 4245618683,
            2809771154, 2842737049, 3144396420, 3043140495, 2673705150,
            2438237621, 2203032232, 2370213795,
          ],
          v = [
            0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694,
            824852259, 1483753576, 1400783205, 1315723890, 1164071807,
            1950903388, 2135319889, 1649704518, 1767536459, 2967507152,
            3152976349, 2801566410, 2918353863, 2631447780, 2547432937,
            2328143614, 2177544179, 3901806776, 3818836405, 4270639778,
            4118987695, 3299409036, 3483825537, 3535072918, 3652904859,
            2077965243, 1893020342, 1841768865, 1724457132, 1474502543,
            1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569,
            1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355,
            3224740454, 3710368113, 3593056380, 3875770207, 3960309330,
            4045380933, 4195456072, 2471224067, 2554718734, 2237133081,
            2388260884, 3212035895, 3028143674, 2842678573, 2724322336,
            4138563181, 4255350624, 3769721975, 3955191162, 3667219033,
            3516619604, 3431546947, 3347532110, 2933734917, 2782082824,
            3099667487, 3016697106, 2196052529, 2313884476, 2499348523,
            2683765030, 1179510461, 1296297904, 1347548327, 1533017514,
            1786102409, 1635502980, 2087309459, 2003294622, 507358933,
            355706840, 136428751, 53458370, 839224033, 957055980, 605657339,
            790073846, 2373340630, 2256028891, 2607439820, 2422494913,
            2706270690, 2856345839, 3075636216, 3160175349, 3573941694,
            3725069491, 3273267108, 3356761769, 4181598602, 4063242375,
            4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369,
            296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147,
            1945798516, 2029293177, 1239331162, 1120974935, 1606591296,
            1422699085, 4148292826, 4233094615, 3781033664, 3931371469,
            3682191598, 3497509347, 3446004468, 3328955385, 2939266226,
            2755636671, 3106780840, 2988687269, 2198438022, 2282195339,
            2501218972, 2652609425, 1201765386, 1286567175, 1371368976,
            1521706781, 1805211710, 1620529459, 2105887268, 1988838185,
            533804130, 350174575, 164439672, 46346101, 870912086, 954669403,
            636813900, 788204353, 2358957921, 2274680428, 2592523643,
            2441661558, 2695033685, 2880240216, 3065962831, 3182487618,
            3572145929, 3756299780, 3270937875, 3388507166, 4174560061,
            4091327024, 4006521127, 3854606378, 1014646705, 930369212,
            711349675, 560487590, 272786309, 457992840, 106852767, 223377554,
            1678381017, 1862534868, 1914052035, 2031621326, 1211247597,
            1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597,
            486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823,
            1385356242, 1333838021, 1150208456, 1973745387, 2125135846,
            1673061617, 1756818940, 2970356327, 3120694122, 2802849917,
            2887651696, 2637442643, 2520393566, 2334669897, 2149987652,
            3917234703, 3799141122, 4284502037, 4100872472, 3309594171,
            3460984630, 3545789473, 3629546796, 2050466060, 1899603969,
            1814803222, 1730525723, 1443857720, 1560382517, 1075025698,
            1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656,
            91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486,
            3620022987, 3874428392, 3990953189, 4042459122, 4227665663,
            2460449204, 2578018489, 2226875310, 2411029155, 3198115200,
            3046200461, 2827177882, 2743944855,
          ],
          E = [
            0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294,
            590424639, 1750626376, 1699970625, 1917742170, 2135253587,
            1551124588, 1367295589, 1180849278, 1265195639, 3501252752,
            3720081049, 3399941250, 3350065803, 3835484340, 3919042237,
            4270507174, 4085369519, 3102249176, 3051593425, 2734591178,
            2952102595, 2361698556, 2177869557, 2530391278, 2614737639,
            3145456443, 3060847922, 2708326185, 2892417312, 2404901663,
            2187128086, 2504130317, 2555048196, 3542330227, 3727205754,
            3375740769, 3292445032, 3876557655, 3926170974, 4246310725,
            4027744588, 1808481195, 1723872674, 1910319033, 2094410160,
            1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394,
            428169201, 344873464, 935293895, 984907214, 766078933, 547512796,
            1844882806, 1627235199, 2011214180, 2062270317, 1507497298,
            1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772,
            313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286,
            2957853679, 2807058932, 2858115069, 2305455554, 2220981195,
            2474404304, 2658625497, 3575528878, 3625268135, 3473416636,
            3254988725, 3778151818, 3963161475, 4213447064, 4130281361,
            3599595085, 3683022916, 3432737375, 3247465558, 3802222185,
            4020912224, 4172763771, 4122762354, 3201631749, 3017672716,
            2764249623, 2848461854, 2331590177, 2280796200, 2431590963,
            2648976442, 104699613, 188127444, 472615631, 287343814, 840019705,
            1058709744, 671593195, 621591778, 1852171925, 1668212892,
            1953757831, 2037970062, 1514790577, 1463996600, 1080017571,
            1297403050, 3673637356, 3623636965, 3235995134, 3454686199,
            4007360968, 3822090177, 4107101658, 4190530515, 2997825956,
            3215212461, 2830708150, 2779915199, 2256734592, 2340947849,
            2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431,
            1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845,
            2013908262, 1963115311, 1446242576, 1530455833, 1277555970,
            1093597963, 1636604631, 1820824798, 2073724613, 1989249228,
            1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910,
            331544205, 516552836, 1039717051, 821288114, 669961897, 719700128,
            2973530695, 3157750862, 2871682645, 2787207260, 2232435299,
            2283490410, 2667994737, 2450346104, 3647212047, 3564045318,
            3279033885, 3464042516, 3980931627, 3762502690, 4150144569,
            4199882800, 3070356634, 3121275539, 2904027272, 2686254721,
            2200818878, 2384911031, 2570832044, 2486224549, 3747192018,
            3528626907, 3310321856, 3359936201, 3950355702, 3867060991,
            4049844452, 4234721005, 1739656202, 1790575107, 2108100632,
            1890328081, 1402811438, 1586903591, 1233856572, 1149249077,
            266959938, 48394827, 369057872, 418672217, 1002783846, 919489135,
            567498868, 752375421, 209336225, 24197544, 376187827, 459744698,
            945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568,
            2117360635, 1933530610, 1343127501, 1560637892, 1243112415,
            1192455638, 3704280881, 3519142200, 3336358691, 3419915562,
            3907448597, 3857572124, 4075877127, 4294704398, 3029510009,
            3113855344, 2927934315, 2744104290, 2159976285, 2377486676,
            2594734927, 2544078150,
          ],
          P = [
            0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204,
            1059270954, 1214797936, 1097159550, 1517440620, 1400849762,
            1817998408, 1699839814, 2118541908, 2001430874, 2429595872,
            2581445614, 2194319100, 2345119218, 3034881240, 3186202582,
            2801699524, 2951971274, 3635996816, 3518358430, 3399679628,
            3283088770, 4237083816, 4118925222, 4002861748, 3885750714,
            1002142683, 850817237, 698445255, 548169417, 529487843, 377642221,
            227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577,
            1474760595, 1592394909, 1174215055, 1290801793, 2875968315,
            2724642869, 3111247143, 2960971305, 2405426947, 2253581325,
            2638606623, 2487810577, 3808662347, 3926825029, 4044981591,
            4162096729, 3342319475, 3459953789, 3576539503, 3693126241,
            1986918061, 2137062819, 1685577905, 1836772287, 1381620373,
            1532285339, 1078185097, 1229899655, 1040559837, 923313619,
            740276417, 621982671, 439452389, 322734571, 137073913, 19308535,
            3871163981, 4021308739, 4104605777, 4255800159, 3263785589,
            3414450555, 3499326569, 3651041127, 2933202493, 2815956275,
            3167684641, 3049390895, 2330014213, 2213296395, 2566595609,
            2448830231, 1305906550, 1155237496, 1607244650, 1455525988,
            1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376,
            396673818, 514443284, 562755902, 679998e3, 865136418, 983426092,
            3708173718, 3557504664, 3474729866, 3323011204, 4180808110,
            4030667424, 3945269170, 3794078908, 2507040230, 2623762152,
            2272556026, 2390325492, 2975484382, 3092726480, 2738905026,
            2857194700, 3973773121, 3856137295, 4274053469, 4157467219,
            3371096953, 3252932727, 3673476453, 3556361835, 2763173681,
            2915017791, 3064510765, 3215307299, 2156299017, 2307622919,
            2459735317, 2610011675, 2081048481, 1963412655, 1846563261,
            1729977011, 1480485785, 1362321559, 1243905413, 1126790795,
            878845905, 1030690015, 645401037, 796197571, 274084841, 425408743,
            38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568,
            4082475170, 4200115116, 3780097726, 3896688048, 2668221674,
            2516901860, 2366882550, 2216610296, 3141400786, 2989552604,
            2837966542, 2687165888, 1202797690, 1320957812, 1437280870,
            1554391400, 1669664834, 1787304780, 1906247262, 2022837584,
            265905162, 114585348, 499347990, 349075736, 736970802, 585122620,
            972512814, 821712160, 2595684844, 2478443234, 2293045232,
            2174754046, 3196267988, 3079546586, 2895723464, 2777952454,
            3537852828, 3687994002, 3234156416, 3385345166, 4142626212,
            4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952,
            292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068,
            1258480242, 1343618912, 1494807662, 1715193156, 1865862730,
            1948373848, 2100090966, 2701949495, 2818666809, 3004591147,
            3122358053, 2235061775, 2352307457, 2535604243, 2653899549,
            3915653703, 3764988233, 4219352155, 4067639125, 3444575871,
            3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211,
            718002117, 367585007, 484830689, 133361907, 251657213, 2041877159,
            1891211689, 1806599355, 1654886325, 1568718495, 1418573201,
            1335535747, 1184342925,
          ];
        function k(e) {
          let t = [];
          for (let n = 0; n < e.length; n += 4)
            t.push(
              (e[n] << 24) | (e[n + 1] << 16) | (e[n + 2] << 8) | e[n + 3]
            );
          return t;
        }
        class T {
          get key() {
            return a(this, n, "f").slice();
          }
          constructor(e) {
            let t;
            if (
              (n.set(this, void 0),
              s.set(this, void 0),
              i.set(this, void 0),
              !(this instanceof T))
            )
              throw Error("AES must be instanitated with `new`");
            o(this, n, new Uint8Array(e), "f");
            let d = l[this.key.length];
            if (null == d)
              throw TypeError("invalid key size (must be 16, 24 or 32 bytes)");
            o(this, i, [], "f"), o(this, s, [], "f");
            for (let e = 0; e <= d; e++)
              a(this, i, "f").push([0, 0, 0, 0]),
                a(this, s, "f").push([0, 0, 0, 0]);
            let h = (d + 1) * 4,
              p = this.key.length / 4,
              f = k(this.key);
            for (let e = 0; e < p; e++)
              (t = e >> 2),
                (a(this, i, "f")[t][e % 4] = f[e]),
                (a(this, s, "f")[d - t][e % 4] = f[e]);
            let g = 0,
              m = p,
              y;
            for (; m < h; ) {
              if (
                ((y = f[p - 1]),
                (f[0] ^=
                  (c[(y >> 16) & 255] << 24) ^
                  (c[(y >> 8) & 255] << 16) ^
                  (c[255 & y] << 8) ^
                  c[(y >> 24) & 255] ^
                  (u[g] << 24)),
                (g += 1),
                8 != p)
              )
                for (let e = 1; e < p; e++) f[e] ^= f[e - 1];
              else {
                for (let e = 1; e < p / 2; e++) f[e] ^= f[e - 1];
                (y = f[p / 2 - 1]),
                  (f[p / 2] ^=
                    c[255 & y] ^
                    (c[(y >> 8) & 255] << 8) ^
                    (c[(y >> 16) & 255] << 16) ^
                    (c[(y >> 24) & 255] << 24));
                for (let e = p / 2 + 1; e < p; e++) f[e] ^= f[e - 1];
              }
              let e = 0,
                t,
                n;
              for (; e < p && m < h; )
                (t = m >> 2),
                  (n = m % 4),
                  (a(this, i, "f")[t][n] = f[e]),
                  (a(this, s, "f")[d - t][n] = f[e++]),
                  m++;
            }
            for (let e = 1; e < d; e++)
              for (let t = 0; t < 4; t++)
                (y = a(this, s, "f")[e][t]),
                  (a(this, s, "f")[e][t] =
                    w[(y >> 24) & 255] ^
                    v[(y >> 16) & 255] ^
                    E[(y >> 8) & 255] ^
                    P[255 & y]);
          }
          encrypt(e) {
            if (16 != e.length)
              throw TypeError("invalid plaintext size (must be 16 bytes)");
            let t = a(this, i, "f").length - 1,
              n = [0, 0, 0, 0],
              s = k(e);
            for (let e = 0; e < 4; e++) s[e] ^= a(this, i, "f")[0][e];
            for (let e = 1; e < t; e++) {
              for (let t = 0; t < 4; t++)
                n[t] =
                  h[(s[t] >> 24) & 255] ^
                  p[(s[(t + 1) % 4] >> 16) & 255] ^
                  f[(s[(t + 2) % 4] >> 8) & 255] ^
                  g[255 & s[(t + 3) % 4]] ^
                  a(this, i, "f")[e][t];
              s = n.slice();
            }
            let o = new Uint8Array(16),
              l = 0;
            for (let e = 0; e < 4; e++)
              (l = a(this, i, "f")[t][e]),
                (o[4 * e] = (c[(s[e] >> 24) & 255] ^ (l >> 24)) & 255),
                (o[4 * e + 1] =
                  (c[(s[(e + 1) % 4] >> 16) & 255] ^ (l >> 16)) & 255),
                (o[4 * e + 2] =
                  (c[(s[(e + 2) % 4] >> 8) & 255] ^ (l >> 8)) & 255),
                (o[4 * e + 3] = (c[255 & s[(e + 3) % 4]] ^ l) & 255);
            return o;
          }
          decrypt(e) {
            if (16 != e.length)
              throw TypeError("invalid ciphertext size (must be 16 bytes)");
            let t = a(this, s, "f").length - 1,
              n = [0, 0, 0, 0],
              i = k(e);
            for (let e = 0; e < 4; e++) i[e] ^= a(this, s, "f")[0][e];
            for (let e = 1; e < t; e++) {
              for (let t = 0; t < 4; t++)
                n[t] =
                  m[(i[t] >> 24) & 255] ^
                  y[(i[(t + 3) % 4] >> 16) & 255] ^
                  b[(i[(t + 2) % 4] >> 8) & 255] ^
                  A[255 & i[(t + 1) % 4]] ^
                  a(this, s, "f")[e][t];
              i = n.slice();
            }
            let o = new Uint8Array(16),
              l = 0;
            for (let e = 0; e < 4; e++)
              (l = a(this, s, "f")[t][e]),
                (o[4 * e] = (d[(i[e] >> 24) & 255] ^ (l >> 24)) & 255),
                (o[4 * e + 1] =
                  (d[(i[(e + 3) % 4] >> 16) & 255] ^ (l >> 16)) & 255),
                (o[4 * e + 2] =
                  (d[(i[(e + 2) % 4] >> 8) & 255] ^ (l >> 8)) & 255),
                (o[4 * e + 3] = (d[255 & i[(e + 1) % 4]] ^ l) & 255);
            return o;
          }
        }
        (t.AES = T),
          (n = new WeakMap()),
          (s = new WeakMap()),
          (i = new WeakMap());
      },
      93260: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.pkcs7Strip =
            t.pkcs7Pad =
            t.OFB =
            t.ECB =
            t.CTR =
            t.CFB =
            t.CBC =
            t.ModeOfOperation =
            t.AES =
              void 0);
        var s = n(40517);
        Object.defineProperty(t, "AES", {
          enumerable: !0,
          get: function () {
            return s.AES;
          },
        });
        var i = n(2868);
        Object.defineProperty(t, "ModeOfOperation", {
          enumerable: !0,
          get: function () {
            return i.ModeOfOperation;
          },
        });
        var a = n(52805);
        Object.defineProperty(t, "CBC", {
          enumerable: !0,
          get: function () {
            return a.CBC;
          },
        });
        var o = n(73169);
        Object.defineProperty(t, "CFB", {
          enumerable: !0,
          get: function () {
            return o.CFB;
          },
        });
        var l = n(83310);
        Object.defineProperty(t, "CTR", {
          enumerable: !0,
          get: function () {
            return l.CTR;
          },
        });
        var u = n(89915);
        Object.defineProperty(t, "ECB", {
          enumerable: !0,
          get: function () {
            return u.ECB;
          },
        });
        var c = n(22023);
        Object.defineProperty(t, "OFB", {
          enumerable: !0,
          get: function () {
            return c.OFB;
          },
        });
        var d = n(99533);
        Object.defineProperty(t, "pkcs7Pad", {
          enumerable: !0,
          get: function () {
            return d.pkcs7Pad;
          },
        }),
          Object.defineProperty(t, "pkcs7Strip", {
            enumerable: !0,
            get: function () {
              return d.pkcs7Strip;
            },
          });
      },
      52805: function (e, t, n) {
        "use strict";
        var s,
          i,
          a =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, n, s, i) {
              if ("m" === s) throw TypeError("Private method is not writable");
              if ("a" === s && !i)
                throw TypeError(
                  "Private accessor was defined without a setter"
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw TypeError(
                  "Cannot write private member to an object whose class did not declare it"
                );
              return (
                "a" === s ? i.call(e, n) : i ? (i.value = n) : t.set(e, n), n
              );
            },
          o =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, n, s) {
              if ("a" === n && !s)
                throw TypeError(
                  "Private accessor was defined without a getter"
                );
              if ("function" == typeof t ? e !== t || !s : !t.has(e))
                throw TypeError(
                  "Cannot read private member from an object whose class did not declare it"
                );
              return "m" === n
                ? s
                : "a" === n
                ? s.call(e)
                : s
                ? s.value
                : t.get(e);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }), (t.CBC = void 0);
        let l = n(2868);
        class u extends l.ModeOfOperation {
          constructor(e, t) {
            if (
              (super("ECC", e, u), s.set(this, void 0), i.set(this, void 0), t)
            ) {
              if (t.length % 16)
                throw TypeError("invalid iv size (must be 16 bytes)");
              a(this, s, new Uint8Array(t), "f");
            } else a(this, s, new Uint8Array(16), "f");
            a(this, i, this.iv, "f");
          }
          get iv() {
            return new Uint8Array(o(this, s, "f"));
          }
          encrypt(e) {
            if (e.length % 16)
              throw TypeError(
                "invalid plaintext size (must be multiple of 16 bytes)"
              );
            let t = new Uint8Array(e.length);
            for (let n = 0; n < e.length; n += 16) {
              for (let t = 0; t < 16; t++) o(this, i, "f")[t] ^= e[n + t];
              a(this, i, this.aes.encrypt(o(this, i, "f")), "f"),
                t.set(o(this, i, "f"), n);
            }
            return t;
          }
          decrypt(e) {
            if (e.length % 16)
              throw TypeError(
                "invalid ciphertext size (must be multiple of 16 bytes)"
              );
            let t = new Uint8Array(e.length);
            for (let n = 0; n < e.length; n += 16) {
              let s = this.aes.decrypt(e.subarray(n, n + 16));
              for (let a = 0; a < 16; a++)
                (t[n + a] = s[a] ^ o(this, i, "f")[a]),
                  (o(this, i, "f")[a] = e[n + a]);
            }
            return t;
          }
        }
        (t.CBC = u), (s = new WeakMap()), (i = new WeakMap());
      },
      73169: function (e, t, n) {
        "use strict";
        var s,
          i,
          a,
          o,
          l =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, n, s, i) {
              if ("m" === s) throw TypeError("Private method is not writable");
              if ("a" === s && !i)
                throw TypeError(
                  "Private accessor was defined without a setter"
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw TypeError(
                  "Cannot write private member to an object whose class did not declare it"
                );
              return (
                "a" === s ? i.call(e, n) : i ? (i.value = n) : t.set(e, n), n
              );
            },
          u =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, n, s) {
              if ("a" === n && !s)
                throw TypeError(
                  "Private accessor was defined without a getter"
                );
              if ("function" == typeof t ? e !== t || !s : !t.has(e))
                throw TypeError(
                  "Cannot read private member from an object whose class did not declare it"
                );
              return "m" === n
                ? s
                : "a" === n
                ? s.call(e)
                : s
                ? s.value
                : t.get(e);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }), (t.CFB = void 0);
        let c = n(2868);
        class d extends c.ModeOfOperation {
          constructor(e, t, n = 8) {
            if (
              (super("CFB", e, d),
              s.add(this),
              i.set(this, void 0),
              a.set(this, void 0),
              !Number.isInteger(n) || n % 8)
            )
              throw TypeError("invalid segmentSize");
            if (
              (Object.defineProperties(this, {
                segmentSize: { enumerable: !0, value: n },
              }),
              t)
            ) {
              if (t.length % 16)
                throw TypeError("invalid iv size (must be 16 bytes)");
              l(this, i, new Uint8Array(t), "f");
            } else l(this, i, new Uint8Array(16), "f");
            l(this, a, this.iv, "f");
          }
          get iv() {
            return new Uint8Array(u(this, i, "f"));
          }
          encrypt(e) {
            if ((8 * e.length) % this.segmentSize)
              throw TypeError(
                "invalid plaintext size (must be multiple of segmentSize bytes)"
              );
            let t = this.segmentSize / 8,
              n = new Uint8Array(e);
            for (let e = 0; e < n.length; e += t) {
              let i = this.aes.encrypt(u(this, a, "f"));
              for (let s = 0; s < t; s++) n[e + s] ^= i[s];
              u(this, s, "m", o).call(this, n.subarray(e));
            }
            return n;
          }
          decrypt(e) {
            if ((8 * e.length) % this.segmentSize)
              throw TypeError(
                "invalid ciphertext size (must be multiple of segmentSize bytes)"
              );
            let t = this.segmentSize / 8,
              n = new Uint8Array(e);
            for (let i = 0; i < n.length; i += t) {
              let l = this.aes.encrypt(u(this, a, "f"));
              for (let e = 0; e < t; e++) n[i + e] ^= l[e];
              u(this, s, "m", o).call(this, e.subarray(i));
            }
            return n;
          }
        }
        (t.CFB = d),
          (i = new WeakMap()),
          (a = new WeakMap()),
          (s = new WeakSet()),
          (o = function (e) {
            let t = this.segmentSize / 8;
            u(this, a, "f").set(u(this, a, "f").subarray(t)),
              u(this, a, "f").set(e.subarray(0, t), 16 - t);
          });
      },
      83310: function (e, t, n) {
        "use strict";
        var s,
          i,
          a,
          o =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, n, s, i) {
              if ("m" === s) throw TypeError("Private method is not writable");
              if ("a" === s && !i)
                throw TypeError(
                  "Private accessor was defined without a setter"
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw TypeError(
                  "Cannot write private member to an object whose class did not declare it"
                );
              return (
                "a" === s ? i.call(e, n) : i ? (i.value = n) : t.set(e, n), n
              );
            },
          l =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, n, s) {
              if ("a" === n && !s)
                throw TypeError(
                  "Private accessor was defined without a getter"
                );
              if ("function" == typeof t ? e !== t || !s : !t.has(e))
                throw TypeError(
                  "Cannot read private member from an object whose class did not declare it"
                );
              return "m" === n
                ? s
                : "a" === n
                ? s.call(e)
                : s
                ? s.value
                : t.get(e);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }), (t.CTR = void 0);
        let u = n(2868);
        class c extends u.ModeOfOperation {
          constructor(e, t) {
            super("CTR", e, c),
              s.set(this, void 0),
              i.set(this, void 0),
              a.set(this, void 0),
              o(this, a, new Uint8Array(16), "f"),
              l(this, a, "f").fill(0),
              o(this, s, l(this, a, "f"), "f"),
              o(this, i, 16, "f"),
              null == t && (t = 1),
              "number" == typeof t
                ? this.setCounterValue(t)
                : this.setCounterBytes(t);
          }
          get counter() {
            return new Uint8Array(l(this, a, "f"));
          }
          setCounterValue(e) {
            if (!Number.isInteger(e) || e < 0 || e > Number.MAX_SAFE_INTEGER)
              throw TypeError("invalid counter initial integer value");
            for (let t = 15; t >= 0; --t)
              (l(this, a, "f")[t] = e % 256), (e = Math.floor(e / 256));
          }
          setCounterBytes(e) {
            if (16 !== e.length)
              throw TypeError(
                "invalid counter initial Uint8Array value length"
              );
            l(this, a, "f").set(e);
          }
          increment() {
            for (let e = 15; e >= 0; e--)
              if (255 === l(this, a, "f")[e]) l(this, a, "f")[e] = 0;
              else {
                l(this, a, "f")[e]++;
                break;
              }
          }
          encrypt(e) {
            var t, n;
            let u = new Uint8Array(e);
            for (let e = 0; e < u.length; e++)
              16 === l(this, i, "f") &&
                (o(this, s, this.aes.encrypt(l(this, a, "f")), "f"),
                o(this, i, 0, "f"),
                this.increment()),
                (u[e] ^= l(this, s, "f")[
                  (o(this, i, ((n = l(this, i, "f")), (t = n++), n), "f"), t)
                ]);
            return u;
          }
          decrypt(e) {
            return this.encrypt(e);
          }
        }
        (t.CTR = c),
          (s = new WeakMap()),
          (i = new WeakMap()),
          (a = new WeakMap());
      },
      89915: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }), (t.ECB = void 0);
        let s = n(2868);
        class i extends s.ModeOfOperation {
          constructor(e) {
            super("ECB", e, i);
          }
          encrypt(e) {
            if (e.length % 16)
              throw TypeError(
                "invalid plaintext size (must be multiple of 16 bytes)"
              );
            let t = new Uint8Array(e.length);
            for (let n = 0; n < e.length; n += 16)
              t.set(this.aes.encrypt(e.subarray(n, n + 16)), n);
            return t;
          }
          decrypt(e) {
            if (e.length % 16)
              throw TypeError(
                "invalid ciphertext size (must be multiple of 16 bytes)"
              );
            let t = new Uint8Array(e.length);
            for (let n = 0; n < e.length; n += 16)
              t.set(this.aes.decrypt(e.subarray(n, n + 16)), n);
            return t;
          }
        }
        t.ECB = i;
      },
      22023: function (e, t, n) {
        "use strict";
        var s,
          i,
          a,
          o =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, n, s, i) {
              if ("m" === s) throw TypeError("Private method is not writable");
              if ("a" === s && !i)
                throw TypeError(
                  "Private accessor was defined without a setter"
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw TypeError(
                  "Cannot write private member to an object whose class did not declare it"
                );
              return (
                "a" === s ? i.call(e, n) : i ? (i.value = n) : t.set(e, n), n
              );
            },
          l =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, n, s) {
              if ("a" === n && !s)
                throw TypeError(
                  "Private accessor was defined without a getter"
                );
              if ("function" == typeof t ? e !== t || !s : !t.has(e))
                throw TypeError(
                  "Cannot read private member from an object whose class did not declare it"
                );
              return "m" === n
                ? s
                : "a" === n
                ? s.call(e)
                : s
                ? s.value
                : t.get(e);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }), (t.OFB = void 0);
        let u = n(2868);
        class c extends u.ModeOfOperation {
          constructor(e, t) {
            if (
              (super("OFB", e, c),
              s.set(this, void 0),
              i.set(this, void 0),
              a.set(this, void 0),
              t)
            ) {
              if (t.length % 16)
                throw TypeError("invalid iv size (must be 16 bytes)");
              o(this, s, new Uint8Array(t), "f");
            } else o(this, s, new Uint8Array(16), "f");
            o(this, i, this.iv, "f"), o(this, a, 16, "f");
          }
          get iv() {
            return new Uint8Array(l(this, s, "f"));
          }
          encrypt(e) {
            var t, n;
            if (e.length % 16)
              throw TypeError(
                "invalid plaintext size (must be multiple of 16 bytes)"
              );
            let s = new Uint8Array(e);
            for (let e = 0; e < s.length; e++)
              16 === l(this, a, "f") &&
                (o(this, i, this.aes.encrypt(l(this, i, "f")), "f"),
                o(this, a, 0, "f")),
                (s[e] ^= l(this, i, "f")[
                  (o(this, a, ((n = l(this, a, "f")), (t = n++), n), "f"), t)
                ]);
            return s;
          }
          decrypt(e) {
            if (e.length % 16)
              throw TypeError(
                "invalid ciphertext size (must be multiple of 16 bytes)"
              );
            return this.encrypt(e);
          }
        }
        (t.OFB = c),
          (s = new WeakMap()),
          (i = new WeakMap()),
          (a = new WeakMap());
      },
      2868: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ModeOfOperation = void 0);
        let s = n(40517);
        class i {
          constructor(e, t, n) {
            if (n && !(this instanceof n))
              throw Error(`${e} must be instantiated with "new"`);
            Object.defineProperties(this, {
              aes: { enumerable: !0, value: new s.AES(t) },
              name: { enumerable: !0, value: e },
            });
          }
        }
        t.ModeOfOperation = i;
      },
      99533: function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.pkcs7Strip = t.pkcs7Pad = void 0),
          (t.pkcs7Pad = function (e) {
            let t = 16 - (e.length % 16),
              n = new Uint8Array(e.length + t);
            n.set(e);
            for (let s = e.length; s < n.length; s++) n[s] = t;
            return n;
          }),
          (t.pkcs7Strip = function (e) {
            if (e.length < 16) throw TypeError("PKCS#7 invalid length");
            let t = e[e.length - 1];
            if (t > 16) throw TypeError("PKCS#7 padding byte out of range");
            let n = e.length - t;
            for (let s = 0; s < t; s++)
              if (e[n + s] !== t)
                throw TypeError("PKCS#7 invalid padding byte");
            return new Uint8Array(e.subarray(0, n));
          });
      },
      79406: function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.version = void 0),
          (t.version = "6.13.5");
      },
      54760: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AbiCoder = void 0);
        let s = n(42120),
          i = n(12900),
          a = n(32063),
          o = n(8151),
          l = n(38583),
          u = n(5949),
          c = n(4148),
          d = n(36341),
          h = n(96893),
          p = n(53524),
          f = n(46701),
          g = n(66711),
          m = n(45475),
          y = n(42120),
          b = new Map();
        b.set(0, "GENERIC_PANIC"),
          b.set(1, "ASSERT_FALSE"),
          b.set(17, "OVERFLOW"),
          b.set(18, "DIVIDE_BY_ZERO"),
          b.set(33, "ENUM_RANGE_ERROR"),
          b.set(34, "BAD_STORAGE_DATA"),
          b.set(49, "STACK_UNDERFLOW"),
          b.set(50, "ARRAY_RANGE_ERROR"),
          b.set(65, "OUT_OF_MEMORY"),
          b.set(81, "UNINITIALIZED_FUNCTION_CALL");
        let A = new RegExp(/^bytes([0-9]*)$/),
          w = new RegExp(/^(u?int)([0-9]*)$/),
          v = null,
          E = 1024;
        class P {
          #e(e) {
            if (e.isArray())
              return new o.ArrayCoder(
                this.#e(e.arrayChildren),
                e.arrayLength,
                e.name
              );
            if (e.isTuple())
              return new f.TupleCoder(
                e.components.map((e) => this.#e(e)),
                e.name
              );
            switch (e.baseType) {
              case "address":
                return new a.AddressCoder(e.name);
              case "bool":
                return new l.BooleanCoder(e.name);
              case "string":
                return new p.StringCoder(e.name);
              case "bytes":
                return new u.BytesCoder(e.name);
              case "":
                return new d.NullCoder(e.name);
            }
            let t = e.type.match(w);
            if (t) {
              let n = parseInt(t[2] || "256");
              return (
                (0, s.assertArgument)(
                  0 !== n && n <= 256 && n % 8 == 0,
                  "invalid " + t[1] + " bit length",
                  "param",
                  e
                ),
                new h.NumberCoder(n / 8, "int" === t[1], e.name)
              );
            }
            if ((t = e.type.match(A))) {
              let n = parseInt(t[1]);
              return (
                (0, s.assertArgument)(
                  0 !== n && n <= 32,
                  "invalid bytes length",
                  "param",
                  e
                ),
                new c.FixedBytesCoder(n, e.name)
              );
            }
            (0, s.assertArgument)(!1, "invalid type", "type", e.type);
          }
          getDefaultValue(e) {
            let t = e.map((e) => this.#e(g.ParamType.from(e)));
            return new f.TupleCoder(t, "_").defaultValue();
          }
          encode(e, t) {
            (0, s.assertArgumentCount)(
              t.length,
              e.length,
              "types/values length mismatch"
            );
            let n = e.map((e) => this.#e(g.ParamType.from(e))),
              a = new f.TupleCoder(n, "_"),
              o = new i.Writer();
            return a.encode(o, t), o.data;
          }
          decode(e, t, n) {
            let s = e.map((e) => this.#e(g.ParamType.from(e)));
            return new f.TupleCoder(s, "_").decode(new i.Reader(t, n, E));
          }
          static _setDefaultMaxInflation(e) {
            (0, s.assertArgument)(
              "number" == typeof e && Number.isInteger(e),
              "invalid defaultMaxInflation factor",
              "value",
              e
            ),
              (E = e);
          }
          static defaultAbiCoder() {
            return null == v && (v = new P()), v;
          }
          static getBuiltinCallException(e, t, n) {
            return (function (e, t, n, s) {
              let i = "missing revert data",
                a = null,
                o = null;
              if (n) {
                i = "execution reverted";
                let e = (0, y.getBytes)(n);
                if (((n = (0, y.hexlify)(n)), 0 === e.length))
                  (i += " (no data present; likely require(false) occurred"),
                    (a = "require(false)");
                else if (e.length % 32 != 4)
                  i += " (could not decode reason; invalid data length)";
                else if ("0x08c379a0" === (0, y.hexlify)(e.slice(0, 4)))
                  try {
                    (a = s.decode(["string"], e.slice(4))[0]),
                      (o = {
                        signature: "Error(string)",
                        name: "Error",
                        args: [a],
                      }),
                      (i += `: ${JSON.stringify(a)}`);
                  } catch (e) {
                    i += " (could not decode reason; invalid string data)";
                  }
                else if ("0x4e487b71" === (0, y.hexlify)(e.slice(0, 4)))
                  try {
                    let t = Number(s.decode(["uint256"], e.slice(4))[0]);
                    (o = {
                      signature: "Panic(uint256)",
                      name: "Panic",
                      args: [t],
                    }),
                      (a = `Panic due to ${b.get(t) || "UNKNOWN"}(${t})`),
                      (i += `: ${a}`);
                  } catch (e) {
                    i += " (could not decode panic code)";
                  }
                else i += " (unknown custom error)";
              }
              let l = {
                to: t.to ? (0, m.getAddress)(t.to) : null,
                data: t.data || "0x",
              };
              return (
                t.from && (l.from = (0, m.getAddress)(t.from)),
                (0, y.makeError)(i, "CALL_EXCEPTION", {
                  action: e,
                  data: n,
                  reason: a,
                  transaction: l,
                  invocation: null,
                  revert: o,
                })
              );
            })(e, t, n, P.defaultAbiCoder());
          }
        }
        t.AbiCoder = P;
      },
      12472: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decodeBytes32String = t.encodeBytes32String = void 0);
        let s = n(42120);
        (t.encodeBytes32String = function (e) {
          let t = (0, s.toUtf8Bytes)(e);
          if (t.length > 31)
            throw Error("bytes32 string must be less than 32 bytes");
          return (0, s.zeroPadBytes)(t, 32);
        }),
          (t.decodeBytes32String = function (e) {
            let t = (0, s.getBytes)(e, "bytes");
            if (32 !== t.length)
              throw Error("invalid bytes32 - not 32 bytes long");
            if (0 !== t[31])
              throw Error("invalid bytes32 string - no null terminator");
            let n = 31;
            for (; 0 === t[n - 1]; ) n--;
            return (0, s.toUtf8String)(t.slice(0, n));
          });
      },
      12900: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Reader =
            t.Writer =
            t.Coder =
            t.checkResultErrors =
            t.Result =
            t.WordSize =
              void 0);
        let s = n(42120);
        t.WordSize = 32;
        let i = new Uint8Array(t.WordSize),
          a = ["then"],
          o = {},
          l = new WeakMap();
        function u(e) {
          return l.get(e);
        }
        function c(e, t) {
          let n = Error(
            `deferred error during ABI decoding triggered accessing ${e}`
          );
          throw ((n.error = t), n);
        }
        class d extends Array {
          #t;
          constructor(...e) {
            var t, n;
            let i = e[0],
              d = e[1],
              h = (e[2] || []).slice(),
              p = !0;
            i !== o && ((d = e), (h = []), (p = !1)),
              super(d.length),
              d.forEach((e, t) => {
                this[t] = e;
              });
            let f = h.reduce(
              (e, t) => (
                "string" == typeof t && e.set(t, (e.get(t) || 0) + 1), e
              ),
              new Map()
            );
            if (
              ((t = Object.freeze(
                d.map((e, t) => {
                  let n = h[t];
                  return null != n && 1 === f.get(n) ? n : null;
                })
              )),
              l.set(this, t),
              (this.#t = []),
              null == this.#t && this.#t,
              !p)
            )
              return;
            Object.freeze(this);
            let g = new Proxy(this, {
              get: (e, t, n) => {
                if ("string" == typeof t) {
                  if (t.match(/^[0-9]+$/)) {
                    let n = (0, s.getNumber)(t, "%index");
                    if (n < 0 || n >= this.length)
                      throw RangeError("out of result range");
                    let i = e[n];
                    return i instanceof Error && c(`index ${n}`, i), i;
                  }
                  if (a.indexOf(t) >= 0) return Reflect.get(e, t, n);
                  let i = e[t];
                  if (i instanceof Function)
                    return function (...t) {
                      return i.apply(this === n ? e : this, t);
                    };
                  if (!(t in e))
                    return e.getValue.apply(this === n ? e : this, [t]);
                }
                return Reflect.get(e, t, n);
              },
            });
            return (n = u(this)), l.set(g, n), g;
          }
          toArray(e) {
            let t = [];
            return (
              this.forEach((n, s) => {
                n instanceof Error && c(`index ${s}`, n),
                  e && n instanceof d && (n = n.toArray(e)),
                  t.push(n);
              }),
              t
            );
          }
          toObject(e) {
            let t = u(this);
            return t.reduce(
              (n, i, a) => (
                (0, s.assert)(
                  null != i,
                  `value at index ${a} unnamed`,
                  "UNSUPPORTED_OPERATION",
                  { operation: "toObject()" }
                ),
                (function e(t, n, s) {
                  return t.indexOf(null) >= 0
                    ? n.map((t, n) => (t instanceof d ? e(u(t), t, s) : t))
                    : t.reduce((t, i, a) => {
                        let o = n.getValue(i);
                        return (
                          i in t ||
                            (s && o instanceof d && (o = e(u(o), o, s)),
                            (t[i] = o)),
                          t
                        );
                      }, {});
                })(t, this, e)
              ),
              {}
            );
          }
          slice(e, t) {
            null == e && (e = 0),
              e < 0 && (e += this.length) < 0 && (e = 0),
              null == t && (t = this.length),
              t < 0 && (t += this.length) < 0 && (t = 0),
              t > this.length && (t = this.length);
            let n = u(this),
              s = [],
              i = [];
            for (let a = e; a < t; a++) s.push(this[a]), i.push(n[a]);
            return new d(o, s, i);
          }
          filter(e, t) {
            let n = u(this),
              s = [],
              i = [];
            for (let a = 0; a < this.length; a++) {
              let o = this[a];
              o instanceof Error && c(`index ${a}`, o),
                e.call(t, o, a, this) && (s.push(o), i.push(n[a]));
            }
            return new d(o, s, i);
          }
          map(e, t) {
            let n = [];
            for (let s = 0; s < this.length; s++) {
              let i = this[s];
              i instanceof Error && c(`index ${s}`, i),
                n.push(e.call(t, i, s, this));
            }
            return n;
          }
          getValue(e) {
            let t = u(this).indexOf(e);
            if (-1 === t) return;
            let n = this[t];
            return (
              n instanceof Error && c(`property ${JSON.stringify(e)}`, n.error),
              n
            );
          }
          static fromItems(e, t) {
            return new d(o, e, t);
          }
        }
        function h(e) {
          let n = (0, s.toBeArray)(e);
          return (
            (0, s.assert)(
              n.length <= t.WordSize,
              "value out-of-bounds",
              "BUFFER_OVERRUN",
              { buffer: n, length: t.WordSize, offset: n.length }
            ),
            n.length !== t.WordSize &&
              (n = (0, s.getBytesCopy)(
                (0, s.concat)([i.slice(n.length % t.WordSize), n])
              )),
            n
          );
        }
        (t.Result = d),
          (t.checkResultErrors = function (e) {
            let t = [],
              n = function (e, s) {
                if (Array.isArray(s))
                  for (let i in s) {
                    let a = e.slice();
                    a.push(i);
                    try {
                      n(a, s[i]);
                    } catch (e) {
                      t.push({ path: a, error: e });
                    }
                  }
              };
            return n([], e), t;
          });
        class p {
          name;
          type;
          localName;
          dynamic;
          constructor(e, t, n, i) {
            (0, s.defineProperties)(
              this,
              { name: e, type: t, localName: n, dynamic: i },
              {
                name: "string",
                type: "string",
                localName: "string",
                dynamic: "boolean",
              }
            );
          }
          _throwError(e, t) {
            (0, s.assertArgument)(!1, e, this.localName, t);
          }
        }
        t.Coder = p;
        class f {
          #r;
          #n;
          constructor() {
            (this.#r = []), (this.#n = 0);
          }
          get data() {
            return (0, s.concat)(this.#r);
          }
          get length() {
            return this.#n;
          }
          #s(e) {
            return this.#r.push(e), (this.#n += e.length), e.length;
          }
          appendWriter(e) {
            return this.#s((0, s.getBytesCopy)(e.data));
          }
          writeBytes(e) {
            let n = (0, s.getBytesCopy)(e),
              a = n.length % t.WordSize;
            return (
              a && (n = (0, s.getBytesCopy)((0, s.concat)([n, i.slice(a)]))),
              this.#s(n)
            );
          }
          writeValue(e) {
            return this.#s(h(e));
          }
          writeUpdatableValue() {
            let e = this.#r.length;
            return (
              this.#r.push(i),
              (this.#n += t.WordSize),
              (t) => {
                this.#r[e] = h(t);
              }
            );
          }
        }
        t.Writer = f;
        class g {
          allowLoose;
          #r;
          #i;
          #a;
          #o;
          #l;
          constructor(e, t, n) {
            (0, s.defineProperties)(this, { allowLoose: !!t }),
              (this.#r = (0, s.getBytesCopy)(e)),
              (this.#a = 0),
              (this.#o = null),
              (this.#l = null != n ? n : 1024),
              (this.#i = 0);
          }
          get data() {
            return (0, s.hexlify)(this.#r);
          }
          get dataLength() {
            return this.#r.length;
          }
          get consumed() {
            return this.#i;
          }
          get bytes() {
            return new Uint8Array(this.#r);
          }
          #u(e) {
            if (this.#o) return this.#o.#u(e);
            (this.#a += e),
              (0, s.assert)(
                this.#l < 1 || this.#a <= this.#l * this.dataLength,
                `compressed ABI data exceeds inflation ratio of ${
                  this.#l
                } ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`,
                "BUFFER_OVERRUN",
                {
                  buffer: (0, s.getBytesCopy)(this.#r),
                  offset: this.#i,
                  length: e,
                  info: { bytesRead: this.#a, dataLength: this.dataLength },
                }
              );
          }
          #c(e, n, i) {
            let a = Math.ceil(n / t.WordSize) * t.WordSize;
            return (
              this.#i + a > this.#r.length &&
                (this.allowLoose && i && this.#i + n <= this.#r.length
                  ? (a = n)
                  : (0, s.assert)(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
                      buffer: (0, s.getBytesCopy)(this.#r),
                      length: this.#r.length,
                      offset: this.#i + a,
                    })),
              this.#r.slice(this.#i, this.#i + a)
            );
          }
          subReader(e) {
            let t = new g(this.#r.slice(this.#i + e), this.allowLoose, this.#l);
            return (t.#o = this), t;
          }
          readBytes(e, t) {
            let n = this.#c(0, e, !!t);
            return this.#u(e), (this.#i += n.length), n.slice(0, e);
          }
          readValue() {
            return (0, s.toBigInt)(this.readBytes(t.WordSize));
          }
          readIndex() {
            return (0, s.toNumber)(this.readBytes(t.WordSize));
          }
        }
        t.Reader = g;
      },
      32063: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AddressCoder = void 0);
        let s = n(45475),
          i = n(90358),
          a = n(3762),
          o = n(12900);
        class l extends o.Coder {
          constructor(e) {
            super("address", "address", e, !1);
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000";
          }
          encode(e, t) {
            let n = a.Typed.dereference(t, "string");
            try {
              n = (0, s.getAddress)(n);
            } catch (e) {
              return this._throwError(e.message, t);
            }
            return e.writeValue(n);
          }
          decode(e) {
            return (0, s.getAddress)((0, i.toBeHex)(e.readValue(), 20));
          }
        }
        t.AddressCoder = l;
      },
      56347: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AnonymousCoder = void 0);
        let s = n(12900);
        class i extends s.Coder {
          coder;
          constructor(e) {
            super(e.name, e.type, "_", e.dynamic), (this.coder = e);
          }
          defaultValue() {
            return this.coder.defaultValue();
          }
          encode(e, t) {
            return this.coder.encode(e, t);
          }
          decode(e) {
            return this.coder.decode(e);
          }
        }
        t.AnonymousCoder = i;
      },
      8151: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ArrayCoder = t.unpack = t.pack = void 0);
        let s = n(42120),
          i = n(3762),
          a = n(12900),
          o = n(56347);
        function l(e, t, n) {
          let i = [];
          if (Array.isArray(n)) i = n;
          else if (n && "object" == typeof n) {
            let e = {};
            i = t.map((t) => {
              let i = t.localName;
              return (
                (0, s.assert)(
                  i,
                  "cannot encode object for signature with missing names",
                  "INVALID_ARGUMENT",
                  { argument: "values", info: { coder: t }, value: n }
                ),
                (0, s.assert)(
                  !e[i],
                  "cannot encode object for signature with duplicate names",
                  "INVALID_ARGUMENT",
                  { argument: "values", info: { coder: t }, value: n }
                ),
                (e[i] = !0),
                n[i]
              );
            });
          } else (0, s.assertArgument)(!1, "invalid tuple value", "tuple", n);
          (0, s.assertArgument)(
            t.length === i.length,
            "types/value length mismatch",
            "tuple",
            n
          );
          let o = new a.Writer(),
            l = new a.Writer(),
            u = [];
          return (
            t.forEach((e, t) => {
              let n = i[t];
              if (e.dynamic) {
                let t = l.length;
                e.encode(l, n);
                let s = o.writeUpdatableValue();
                u.push((e) => {
                  s(e + t);
                });
              } else e.encode(o, n);
            }),
            u.forEach((e) => {
              e(o.length);
            }),
            e.appendWriter(o) + e.appendWriter(l)
          );
        }
        function u(e, t) {
          let n = [],
            i = [],
            o = e.subReader(0);
          return (
            t.forEach((t) => {
              let a = null;
              if (t.dynamic) {
                let n = e.readIndex(),
                  i = o.subReader(n);
                try {
                  a = t.decode(i);
                } catch (e) {
                  if ((0, s.isError)(e, "BUFFER_OVERRUN")) throw e;
                  ((a = e).baseType = t.name),
                    (a.name = t.localName),
                    (a.type = t.type);
                }
              } else
                try {
                  a = t.decode(e);
                } catch (e) {
                  if ((0, s.isError)(e, "BUFFER_OVERRUN")) throw e;
                  ((a = e).baseType = t.name),
                    (a.name = t.localName),
                    (a.type = t.type);
                }
              if (void 0 == a) throw Error("investigate");
              n.push(a), i.push(t.localName || null);
            }),
            a.Result.fromItems(n, i)
          );
        }
        (t.pack = l), (t.unpack = u);
        class c extends a.Coder {
          coder;
          length;
          constructor(e, t, n) {
            super(
              "array",
              e.type + "[" + (t >= 0 ? t : "") + "]",
              n,
              -1 === t || e.dynamic
            ),
              (0, s.defineProperties)(this, { coder: e, length: t });
          }
          defaultValue() {
            let e = this.coder.defaultValue(),
              t = [];
            for (let n = 0; n < this.length; n++) t.push(e);
            return t;
          }
          encode(e, t) {
            let n = i.Typed.dereference(t, "array");
            Array.isArray(n) || this._throwError("expected array value", n);
            let a = this.length;
            -1 === a && ((a = n.length), e.writeValue(n.length)),
              (0, s.assertArgumentCount)(
                n.length,
                a,
                "coder array" + (this.localName ? " " + this.localName : "")
              );
            let o = [];
            for (let e = 0; e < n.length; e++) o.push(this.coder);
            return l(e, o, n);
          }
          decode(e) {
            let t = this.length;
            -1 === t &&
              ((t = e.readIndex()),
              (0, s.assert)(
                t * a.WordSize <= e.dataLength,
                "insufficient data length",
                "BUFFER_OVERRUN",
                {
                  buffer: e.bytes,
                  offset: t * a.WordSize,
                  length: e.dataLength,
                }
              ));
            let n = [];
            for (let e = 0; e < t; e++)
              n.push(new o.AnonymousCoder(this.coder));
            return u(e, n);
          }
        }
        t.ArrayCoder = c;
      },
      38583: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BooleanCoder = void 0);
        let s = n(3762),
          i = n(12900);
        class a extends i.Coder {
          constructor(e) {
            super("bool", "bool", e, !1);
          }
          defaultValue() {
            return !1;
          }
          encode(e, t) {
            let n = s.Typed.dereference(t, "bool");
            return e.writeValue(n ? 1 : 0);
          }
          decode(e) {
            return !!e.readValue();
          }
        }
        t.BooleanCoder = a;
      },
      5949: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BytesCoder = t.DynamicBytesCoder = void 0);
        let s = n(42120),
          i = n(12900);
        class a extends i.Coder {
          constructor(e, t) {
            super(e, e, t, !0);
          }
          defaultValue() {
            return "0x";
          }
          encode(e, t) {
            return (
              (t = (0, s.getBytesCopy)(t)),
              e.writeValue(t.length) + e.writeBytes(t)
            );
          }
          decode(e) {
            return e.readBytes(e.readIndex(), !0);
          }
        }
        t.DynamicBytesCoder = a;
        class o extends a {
          constructor(e) {
            super("bytes", e);
          }
          decode(e) {
            return (0, s.hexlify)(super.decode(e));
          }
        }
        t.BytesCoder = o;
      },
      4148: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FixedBytesCoder = void 0);
        let s = n(42120),
          i = n(3762),
          a = n(12900);
        class o extends a.Coder {
          size;
          constructor(e, t) {
            let n = "bytes" + String(e);
            super(n, n, t, !1),
              (0, s.defineProperties)(this, { size: e }, { size: "number" });
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
              0,
              2 + 2 * this.size
            );
          }
          encode(e, t) {
            let n = (0, s.getBytesCopy)(i.Typed.dereference(t, this.type));
            return (
              n.length !== this.size &&
                this._throwError("incorrect data length", t),
              e.writeBytes(n)
            );
          }
          decode(e) {
            return (0, s.hexlify)(e.readBytes(this.size));
          }
        }
        t.FixedBytesCoder = o;
      },
      36341: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NullCoder = void 0);
        let s = n(12900),
          i = new Uint8Array([]);
        class a extends s.Coder {
          constructor(e) {
            super("null", "", e, !1);
          }
          defaultValue() {
            return null;
          }
          encode(e, t) {
            return (
              null != t && this._throwError("not null", t), e.writeBytes(i)
            );
          }
          decode(e) {
            return e.readBytes(0), null;
          }
        }
        t.NullCoder = a;
      },
      96893: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NumberCoder = void 0);
        let s = n(42120),
          i = n(3762),
          a = n(12900),
          o = BigInt(0),
          l = BigInt(1),
          u = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          );
        class c extends a.Coder {
          size;
          signed;
          constructor(e, t, n) {
            let i = (t ? "int" : "uint") + 8 * e;
            super(i, i, n, !1),
              (0, s.defineProperties)(
                this,
                { size: e, signed: t },
                { size: "number", signed: "boolean" }
              );
          }
          defaultValue() {
            return 0;
          }
          encode(e, t) {
            let n = (0, s.getBigInt)(i.Typed.dereference(t, this.type)),
              c = (0, s.mask)(u, 8 * a.WordSize);
            if (this.signed) {
              let e = (0, s.mask)(c, 8 * this.size - 1);
              (n > e || n < -(e + l)) &&
                this._throwError("value out-of-bounds", t),
                (n = (0, s.toTwos)(n, 8 * a.WordSize));
            } else
              (n < o || n > (0, s.mask)(c, 8 * this.size)) &&
                this._throwError("value out-of-bounds", t);
            return e.writeValue(n);
          }
          decode(e) {
            let t = (0, s.mask)(e.readValue(), 8 * this.size);
            return this.signed && (t = (0, s.fromTwos)(t, 8 * this.size)), t;
          }
        }
        t.NumberCoder = c;
      },
      53524: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StringCoder = void 0);
        let s = n(82119),
          i = n(3762),
          a = n(5949);
        class o extends a.DynamicBytesCoder {
          constructor(e) {
            super("string", e);
          }
          defaultValue() {
            return "";
          }
          encode(e, t) {
            return super.encode(
              e,
              (0, s.toUtf8Bytes)(i.Typed.dereference(t, "string"))
            );
          }
          decode(e) {
            return (0, s.toUtf8String)(super.decode(e));
          }
        }
        t.StringCoder = o;
      },
      46701: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TupleCoder = void 0);
        let s = n(39290),
          i = n(3762),
          a = n(12900),
          o = n(8151);
        class l extends a.Coder {
          coders;
          constructor(e, t) {
            let n = !1,
              i = [];
            e.forEach((e) => {
              e.dynamic && (n = !0), i.push(e.type);
            }),
              super("tuple", "tuple(" + i.join(",") + ")", t, n),
              (0, s.defineProperties)(this, {
                coders: Object.freeze(e.slice()),
              });
          }
          defaultValue() {
            let e = [];
            this.coders.forEach((t) => {
              e.push(t.defaultValue());
            });
            let t = this.coders.reduce((e, t) => {
              let n = t.localName;
              return n && (e[n] || (e[n] = 0), e[n]++), e;
            }, {});
            return (
              this.coders.forEach((n, s) => {
                let i = n.localName;
                i &&
                  1 === t[i] &&
                  ("length" === i && (i = "_length"),
                  null == e[i] && (e[i] = e[s]));
              }),
              Object.freeze(e)
            );
          }
          encode(e, t) {
            let n = i.Typed.dereference(t, "tuple");
            return (0, o.pack)(e, this.coders, n);
          }
          decode(e) {
            return (0, o.unpack)(e, this.coders);
          }
        }
        t.TupleCoder = l;
      },
      66711: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StructFragment =
            t.FunctionFragment =
            t.FallbackFragment =
            t.ConstructorFragment =
            t.EventFragment =
            t.ErrorFragment =
            t.NamedFragment =
            t.Fragment =
            t.ParamType =
              void 0);
        let s = n(42120),
          i = n(62475);
        function a(e) {
          let t = new Set();
          return e.forEach((e) => t.add(e)), Object.freeze(t);
        }
        let o = a("external public payable override".split(" ")),
          l =
            "constant external internal payable private public pure view override",
          u = a(l.split(" ")),
          c = "constructor error event fallback function receive struct",
          d = a(c.split(" ")),
          h = "calldata memory storage payable indexed",
          p = a(h.split(" ")),
          f = a([c, h, "tuple returns", l].join(" ").split(" ")),
          g = {
            "(": "OPEN_PAREN",
            ")": "CLOSE_PAREN",
            "[": "OPEN_BRACKET",
            "]": "CLOSE_BRACKET",
            ",": "COMMA",
            "@": "AT",
          },
          m = RegExp("^(\\s*)"),
          y = RegExp("^([0-9]+)"),
          b = RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
          A = RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
          w = RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
        class v {
          #i;
          #d;
          get offset() {
            return this.#i;
          }
          get length() {
            return this.#d.length - this.#i;
          }
          constructor(e) {
            (this.#i = 0), (this.#d = e.slice());
          }
          clone() {
            return new v(this.#d);
          }
          reset() {
            this.#i = 0;
          }
          #h(e = 0, t = 0) {
            return new v(
              this.#d
                .slice(e, t)
                .map((t) =>
                  Object.freeze(
                    Object.assign({}, t, {
                      match: t.match - e,
                      linkBack: t.linkBack - e,
                      linkNext: t.linkNext - e,
                    })
                  )
                )
            );
          }
          popKeyword(e) {
            let t = this.peek();
            if ("KEYWORD" !== t.type || !e.has(t.text))
              throw Error(`expected keyword ${t.text}`);
            return this.pop().text;
          }
          popType(e) {
            if (this.peek().type !== e) {
              let t = this.peek();
              throw Error(
                `expected ${e}; got ${t.type} ${JSON.stringify(t.text)}`
              );
            }
            return this.pop().text;
          }
          popParen() {
            let e = this.peek();
            if ("OPEN_PAREN" !== e.type) throw Error("bad start");
            let t = this.#h(this.#i + 1, e.match + 1);
            return (this.#i = e.match + 1), t;
          }
          popParams() {
            let e = this.peek();
            if ("OPEN_PAREN" !== e.type) throw Error("bad start");
            let t = [];
            for (; this.#i < e.match - 1; ) {
              let e = this.peek().linkNext;
              t.push(this.#h(this.#i + 1, e)), (this.#i = e);
            }
            return (this.#i = e.match + 1), t;
          }
          peek() {
            if (this.#i >= this.#d.length) throw Error("out-of-bounds");
            return this.#d[this.#i];
          }
          peekKeyword(e) {
            let t = this.peekType("KEYWORD");
            return null != t && e.has(t) ? t : null;
          }
          peekType(e) {
            if (0 === this.length) return null;
            let t = this.peek();
            return t.type === e ? t.text : null;
          }
          pop() {
            let e = this.peek();
            return this.#i++, e;
          }
          toString() {
            let e = [];
            for (let t = this.#i; t < this.#d.length; t++) {
              let n = this.#d[t];
              e.push(`${n.type}:${n.text}`);
            }
            return `<TokenString ${e.join(" ")}>`;
          }
        }
        function E(e) {
          let t = [],
            n = (t) => {
              let n = o < e.length ? JSON.stringify(e[o]) : "$EOI";
              throw Error(`invalid token ${n} at ${o}: ${t}`);
            },
            i = [],
            a = [],
            o = 0;
          for (; o < e.length; ) {
            let l = e.substring(o),
              u = l.match(m);
            u && ((o += u[1].length), (l = e.substring(o)));
            let c = {
              depth: i.length,
              linkBack: -1,
              linkNext: -1,
              match: -1,
              type: "",
              text: "",
              offset: o,
              value: -1,
            };
            t.push(c);
            let d = g[l[0]] || "";
            if (d) {
              if (((c.type = d), (c.text = l[0]), o++, "OPEN_PAREN" === d))
                i.push(t.length - 1), a.push(t.length - 1);
              else if ("CLOSE_PAREN" == d)
                0 === i.length && n("no matching open bracket"),
                  (c.match = i.pop()),
                  (t[c.match].match = t.length - 1),
                  c.depth--,
                  (c.linkBack = a.pop()),
                  (t[c.linkBack].linkNext = t.length - 1);
              else if ("COMMA" === d)
                (c.linkBack = a.pop()),
                  (t[c.linkBack].linkNext = t.length - 1),
                  a.push(t.length - 1);
              else if ("OPEN_BRACKET" === d) c.type = "BRACKET";
              else if ("CLOSE_BRACKET" === d) {
                let e = t.pop().text;
                if (t.length > 0 && "NUMBER" === t[t.length - 1].type) {
                  let n = t.pop().text;
                  (e = n + e), (t[t.length - 1].value = (0, s.getNumber)(n));
                }
                if (0 === t.length || "BRACKET" !== t[t.length - 1].type)
                  throw Error("missing opening bracket");
                t[t.length - 1].text += e;
              }
              continue;
            }
            if ((u = l.match(b))) {
              if (((c.text = u[1]), (o += c.text.length), f.has(c.text))) {
                c.type = "KEYWORD";
                continue;
              }
              if (c.text.match(w)) {
                c.type = "TYPE";
                continue;
              }
              c.type = "ID";
              continue;
            }
            if ((u = l.match(y))) {
              (c.text = u[1]), (c.type = "NUMBER"), (o += c.text.length);
              continue;
            }
            throw Error(
              `unexpected token ${JSON.stringify(l[0])} at position ${o}`
            );
          }
          return new v(t.map((e) => Object.freeze(e)));
        }
        function P(e, t) {
          let n = [];
          for (let s in t.keys()) e.has(s) && n.push(s);
          if (n.length > 1) throw Error(`conflicting types: ${n.join(", ")}`);
        }
        function k(e, t) {
          if (t.peekKeyword(d)) {
            let n = t.pop().text;
            if (n !== e) throw Error(`expected ${e}, got ${n}`);
          }
          return t.popType("ID");
        }
        function T(e, t) {
          let n = new Set();
          for (;;) {
            let s = e.peekType("KEYWORD");
            if (null == s || (t && !t.has(s))) break;
            if ((e.pop(), n.has(s)))
              throw Error(`duplicate keywords: ${JSON.stringify(s)}`);
            n.add(s);
          }
          return Object.freeze(n);
        }
        function x(e) {
          let t = T(e, u);
          return (P(t, a("constant payable nonpayable".split(" "))),
          P(t, a("pure view payable nonpayable".split(" "))),
          t.has("view"))
            ? "view"
            : t.has("pure")
            ? "pure"
            : t.has("payable")
            ? "payable"
            : t.has("nonpayable")
            ? "nonpayable"
            : t.has("constant")
            ? "view"
            : "nonpayable";
        }
        function O(e, t) {
          return e.popParams().map((e) => H.from(e, t));
        }
        function S(e) {
          if (e.peekType("AT")) {
            if ((e.pop(), e.peekType("NUMBER")))
              return (0, s.getBigInt)(e.pop().text);
            throw Error("invalid gas");
          }
          return null;
        }
        function C(e) {
          if (e.length)
            throw Error(
              `unexpected tokens at offset ${e.offset}: ${e.toString()}`
            );
        }
        let B = new RegExp(/^(.*)\[([0-9]*)\]$/);
        function N(e) {
          let t = e.match(w);
          if (
            ((0, s.assertArgument)(t, "invalid type", "type", e), "uint" === e)
          )
            return "uint256";
          if ("int" === e) return "int256";
          if (t[2]) {
            let n = parseInt(t[2]);
            (0, s.assertArgument)(
              0 !== n && n <= 32,
              "invalid bytes length",
              "type",
              e
            );
          } else if (t[3]) {
            let n = parseInt(t[3]);
            (0, s.assertArgument)(
              0 !== n && n <= 256 && n % 8 == 0,
              "invalid numeric width",
              "type",
              e
            );
          }
          return e;
        }
        let R = {},
          I = Symbol.for("_ethers_internal"),
          M = "_ParamTypeInternal",
          L = "_ErrorInternal",
          _ = "_EventInternal",
          F = "_ConstructorInternal",
          D = "_FallbackInternal",
          U = "_FunctionInternal",
          j = "_StructInternal";
        class H {
          name;
          type;
          baseType;
          indexed;
          components;
          arrayLength;
          arrayChildren;
          constructor(e, t, n, i, a, o, l, u) {
            if (
              ((0, s.assertPrivate)(e, R, "ParamType"),
              Object.defineProperty(this, I, { value: M }),
              o && (o = Object.freeze(o.slice())),
              "array" === i)
            ) {
              if (null == l || null == u) throw Error("");
            } else if (null != l || null != u) throw Error("");
            if ("tuple" === i) {
              if (null == o) throw Error("");
            } else if (null != o) throw Error("");
            (0, s.defineProperties)(this, {
              name: t,
              type: n,
              baseType: i,
              indexed: a,
              components: o,
              arrayLength: l,
              arrayChildren: u,
            });
          }
          format(e) {
            if ((null == e && (e = "sighash"), "json" === e)) {
              let t = this.name || "";
              if (this.isArray()) {
                let e = JSON.parse(this.arrayChildren.format("json"));
                return (
                  (e.name = t),
                  (e.type += `[${
                    this.arrayLength < 0 ? "" : String(this.arrayLength)
                  }]`),
                  JSON.stringify(e)
                );
              }
              let n = {
                type: "tuple" === this.baseType ? "tuple" : this.type,
                name: t,
              };
              return (
                "boolean" == typeof this.indexed && (n.indexed = this.indexed),
                this.isTuple() &&
                  (n.components = this.components.map((t) =>
                    JSON.parse(t.format(e))
                  )),
                JSON.stringify(n)
              );
            }
            let t = "";
            return (
              this.isArray()
                ? (t +=
                    this.arrayChildren.format(e) +
                    `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`)
                : this.isTuple()
                ? (t +=
                    "(" +
                    this.components
                      .map((t) => t.format(e))
                      .join("full" === e ? ", " : ",") +
                    ")")
                : (t += this.type),
              "sighash" !== e &&
                (!0 === this.indexed && (t += " indexed"),
                "full" === e && this.name && (t += " " + this.name)),
              t
            );
          }
          isArray() {
            return "array" === this.baseType;
          }
          isTuple() {
            return "tuple" === this.baseType;
          }
          isIndexable() {
            return null != this.indexed;
          }
          walk(e, t) {
            if (this.isArray()) {
              if (!Array.isArray(e)) throw Error("invalid array value");
              if (-1 !== this.arrayLength && e.length !== this.arrayLength)
                throw Error("array is wrong length");
              let n = this;
              return e.map((e) => n.arrayChildren.walk(e, t));
            }
            if (this.isTuple()) {
              if (!Array.isArray(e)) throw Error("invalid tuple value");
              if (e.length !== this.components.length)
                throw Error("array is wrong length");
              let n = this;
              return e.map((e, s) => n.components[s].walk(e, t));
            }
            return t(this.type, e);
          }
          #p(e, t, n, s) {
            if (this.isArray()) {
              if (!Array.isArray(t)) throw Error("invalid array value");
              if (-1 !== this.arrayLength && t.length !== this.arrayLength)
                throw Error("array is wrong length");
              let i = this.arrayChildren,
                a = t.slice();
              a.forEach((t, s) => {
                i.#p(e, t, n, (e) => {
                  a[s] = e;
                });
              }),
                s(a);
              return;
            }
            if (this.isTuple()) {
              let i;
              let a = this.components;
              if (Array.isArray(t)) i = t.slice();
              else {
                if (null == t || "object" != typeof t)
                  throw Error("invalid tuple value");
                i = a.map((e) => {
                  if (!e.name)
                    throw Error(
                      "cannot use object value with unnamed components"
                    );
                  if (!(e.name in t))
                    throw Error(`missing value for component ${e.name}`);
                  return t[e.name];
                });
              }
              if (i.length !== this.components.length)
                throw Error("array is wrong length");
              i.forEach((t, s) => {
                a[s].#p(e, t, n, (e) => {
                  i[s] = e;
                });
              }),
                s(i);
              return;
            }
            let i = n(this.type, t);
            i.then
              ? e.push(
                  (async function () {
                    s(await i);
                  })()
                )
              : s(i);
          }
          async walkAsync(e, t) {
            let n = [],
              s = [e];
            return (
              this.#p(n, e, t, (e) => {
                s[0] = e;
              }),
              n.length && (await Promise.all(n)),
              s[0]
            );
          }
          static from(e, t) {
            if (H.isParamType(e)) return e;
            if ("string" == typeof e)
              try {
                return H.from(E(e), t);
              } catch (t) {
                (0, s.assertArgument)(!1, "invalid param type", "obj", e);
              }
            else if (e instanceof v) {
              let n = "",
                s = "",
                i = null;
              T(e, a(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN")
                ? ((s = "tuple"),
                  (i = e.popParams().map((e) => H.from(e))),
                  (n = `tuple(${i.map((e) => e.format()).join(",")})`))
                : (s = n = N(e.popType("TYPE")));
              let o = null,
                l = null;
              for (; e.length && e.peekType("BRACKET"); ) {
                let t = e.pop();
                (o = new H(R, "", n, s, null, i, l, o)),
                  (l = t.value),
                  (n += t.text),
                  (s = "array"),
                  (i = null);
              }
              let u = null;
              if (T(e, p).has("indexed")) {
                if (!t) throw Error("");
                u = !0;
              }
              let c = e.peekType("ID") ? e.pop().text : "";
              if (e.length) throw Error("leftover tokens");
              return new H(R, c, n, s, u, i, l, o);
            }
            let n = e.name;
            (0, s.assertArgument)(
              !n || ("string" == typeof n && n.match(A)),
              "invalid name",
              "obj.name",
              n
            );
            let i = e.indexed;
            null != i &&
              ((0, s.assertArgument)(
                t,
                "parameter cannot be indexed",
                "obj.indexed",
                e.indexed
              ),
              (i = !!i));
            let o = e.type,
              l = o.match(B);
            if (l) {
              let t = parseInt(l[2] || "-1"),
                s = H.from({ type: l[1], components: e.components });
              return new H(R, n || "", o, "array", i, null, t, s);
            }
            if ("tuple" === o || o.startsWith("tuple(") || o.startsWith("(")) {
              let t =
                null != e.components
                  ? e.components.map((e) => H.from(e))
                  : null;
              return new H(R, n || "", o, "tuple", i, t, null, null);
            }
            return new H(R, n || "", (o = N(e.type)), o, i, null, null, null);
          }
          static isParamType(e) {
            return e && e[I] === M;
          }
        }
        t.ParamType = H;
        class $ {
          type;
          inputs;
          constructor(e, t, n) {
            (0, s.assertPrivate)(e, R, "Fragment"),
              (n = Object.freeze(n.slice())),
              (0, s.defineProperties)(this, { type: t, inputs: n });
          }
          static from(e) {
            if ("string" == typeof e) {
              try {
                $.from(JSON.parse(e));
              } catch (e) {}
              return $.from(E(e));
            }
            if (e instanceof v)
              switch (e.peekKeyword(d)) {
                case "constructor":
                  return J.from(e);
                case "error":
                  return V.from(e);
                case "event":
                  return z.from(e);
                case "fallback":
                case "receive":
                  return Q.from(e);
                case "function":
                  return q.from(e);
                case "struct":
                  return W.from(e);
              }
            else if ("object" == typeof e) {
              switch (e.type) {
                case "constructor":
                  return J.from(e);
                case "error":
                  return V.from(e);
                case "event":
                  return z.from(e);
                case "fallback":
                case "receive":
                  return Q.from(e);
                case "function":
                  return q.from(e);
                case "struct":
                  return W.from(e);
              }
              (0, s.assert)(
                !1,
                `unsupported type: ${e.type}`,
                "UNSUPPORTED_OPERATION",
                { operation: "Fragment.from" }
              );
            }
            (0, s.assertArgument)(!1, "unsupported frgament object", "obj", e);
          }
          static isConstructor(e) {
            return J.isFragment(e);
          }
          static isError(e) {
            return V.isFragment(e);
          }
          static isEvent(e) {
            return z.isFragment(e);
          }
          static isFunction(e) {
            return q.isFragment(e);
          }
          static isStruct(e) {
            return W.isFragment(e);
          }
        }
        t.Fragment = $;
        class G extends $ {
          name;
          constructor(e, t, n, i) {
            super(e, t, i),
              (0, s.assertArgument)(
                "string" == typeof n && n.match(A),
                "invalid identifier",
                "name",
                n
              ),
              (i = Object.freeze(i.slice())),
              (0, s.defineProperties)(this, { name: n });
          }
        }
        function K(e, t) {
          return (
            "(" +
            t.map((t) => t.format(e)).join("full" === e ? ", " : ",") +
            ")"
          );
        }
        t.NamedFragment = G;
        class V extends G {
          constructor(e, t, n) {
            super(e, "error", t, n),
              Object.defineProperty(this, I, { value: L });
          }
          get selector() {
            return (0, i.id)(this.format("sighash")).substring(0, 10);
          }
          format(e) {
            if ((null == e && (e = "sighash"), "json" === e))
              return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((t) => JSON.parse(t.format(e))),
              });
            let t = [];
            return (
              "sighash" !== e && t.push("error"),
              t.push(this.name + K(e, this.inputs)),
              t.join(" ")
            );
          }
          static from(e) {
            if (V.isFragment(e)) return e;
            if ("string" == typeof e) return V.from(E(e));
            if (e instanceof v) {
              let t = k("error", e),
                n = O(e);
              return C(e), new V(R, t, n);
            }
            return new V(R, e.name, e.inputs ? e.inputs.map(H.from) : []);
          }
          static isFragment(e) {
            return e && e[I] === L;
          }
        }
        t.ErrorFragment = V;
        class z extends G {
          anonymous;
          constructor(e, t, n, i) {
            super(e, "event", t, n),
              Object.defineProperty(this, I, { value: _ }),
              (0, s.defineProperties)(this, { anonymous: i });
          }
          get topicHash() {
            return (0, i.id)(this.format("sighash"));
          }
          format(e) {
            if ((null == e && (e = "sighash"), "json" === e))
              return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((t) => JSON.parse(t.format(e))),
              });
            let t = [];
            return (
              "sighash" !== e && t.push("event"),
              t.push(this.name + K(e, this.inputs)),
              "sighash" !== e && this.anonymous && t.push("anonymous"),
              t.join(" ")
            );
          }
          static getTopicHash(e, t) {
            return new z(R, e, (t = (t || []).map((e) => H.from(e))), !1)
              .topicHash;
          }
          static from(e) {
            if (z.isFragment(e)) return e;
            if ("string" == typeof e)
              try {
                return z.from(E(e));
              } catch (t) {
                (0, s.assertArgument)(!1, "invalid event fragment", "obj", e);
              }
            else if (e instanceof v) {
              let t = k("event", e),
                n = O(e, !0),
                s = !!T(e, a(["anonymous"])).has("anonymous");
              return C(e), new z(R, t, n, s);
            }
            return new z(
              R,
              e.name,
              e.inputs ? e.inputs.map((e) => H.from(e, !0)) : [],
              !!e.anonymous
            );
          }
          static isFragment(e) {
            return e && e[I] === _;
          }
        }
        t.EventFragment = z;
        class J extends $ {
          payable;
          gas;
          constructor(e, t, n, i, a) {
            super(e, t, n),
              Object.defineProperty(this, I, { value: F }),
              (0, s.defineProperties)(this, { payable: i, gas: a });
          }
          format(e) {
            if (
              ((0, s.assert)(
                null != e && "sighash" !== e,
                "cannot format a constructor for sighash",
                "UNSUPPORTED_OPERATION",
                { operation: "format(sighash)" }
              ),
              "json" === e)
            )
              return JSON.stringify({
                type: "constructor",
                stateMutability: this.payable ? "payable" : "undefined",
                payable: this.payable,
                gas: null != this.gas ? this.gas : void 0,
                inputs: this.inputs.map((t) => JSON.parse(t.format(e))),
              });
            let t = [`constructor${K(e, this.inputs)}`];
            return (
              this.payable && t.push("payable"),
              null != this.gas && t.push(`@${this.gas.toString()}`),
              t.join(" ")
            );
          }
          static from(e) {
            if (J.isFragment(e)) return e;
            if ("string" == typeof e)
              try {
                return J.from(E(e));
              } catch (t) {
                (0, s.assertArgument)(
                  !1,
                  "invalid constuctor fragment",
                  "obj",
                  e
                );
              }
            else if (e instanceof v) {
              T(e, a(["constructor"]));
              let t = O(e),
                n = !!T(e, o).has("payable"),
                s = S(e);
              return C(e), new J(R, "constructor", t, n, s);
            }
            return new J(
              R,
              "constructor",
              e.inputs ? e.inputs.map(H.from) : [],
              !!e.payable,
              null != e.gas ? e.gas : null
            );
          }
          static isFragment(e) {
            return e && e[I] === F;
          }
        }
        t.ConstructorFragment = J;
        class Q extends $ {
          payable;
          constructor(e, t, n) {
            super(e, "fallback", t),
              Object.defineProperty(this, I, { value: D }),
              (0, s.defineProperties)(this, { payable: n });
          }
          format(e) {
            let t = 0 === this.inputs.length ? "receive" : "fallback";
            return "json" === e
              ? JSON.stringify({
                  type: t,
                  stateMutability: this.payable ? "payable" : "nonpayable",
                })
              : `${t}()${this.payable ? " payable" : ""}`;
          }
          static from(e) {
            if (Q.isFragment(e)) return e;
            if ("string" == typeof e)
              try {
                return Q.from(E(e));
              } catch (t) {
                (0, s.assertArgument)(
                  !1,
                  "invalid fallback fragment",
                  "obj",
                  e
                );
              }
            else if (e instanceof v) {
              let t = e.toString(),
                n = e.peekKeyword(a(["fallback", "receive"]));
              if (
                ((0, s.assertArgument)(
                  n,
                  "type must be fallback or receive",
                  "obj",
                  t
                ),
                "receive" === e.popKeyword(a(["fallback", "receive"])))
              ) {
                let t = O(e);
                return (
                  (0, s.assertArgument)(
                    0 === t.length,
                    "receive cannot have arguments",
                    "obj.inputs",
                    t
                  ),
                  T(e, a(["payable"])),
                  C(e),
                  new Q(R, [], !0)
                );
              }
              let i = O(e);
              i.length
                ? (0, s.assertArgument)(
                    1 === i.length && "bytes" === i[0].type,
                    "invalid fallback inputs",
                    "obj.inputs",
                    i.map((e) => e.format("minimal")).join(", ")
                  )
                : (i = [H.from("bytes")]);
              let o = x(e);
              if (
                ((0, s.assertArgument)(
                  "nonpayable" === o || "payable" === o,
                  "fallback cannot be constants",
                  "obj.stateMutability",
                  o
                ),
                T(e, a(["returns"])).has("returns"))
              ) {
                let t = O(e);
                (0, s.assertArgument)(
                  1 === t.length && "bytes" === t[0].type,
                  "invalid fallback outputs",
                  "obj.outputs",
                  t.map((e) => e.format("minimal")).join(", ")
                );
              }
              return C(e), new Q(R, i, "payable" === o);
            }
            return "receive" === e.type
              ? new Q(R, [], !0)
              : "fallback" === e.type
              ? new Q(R, [H.from("bytes")], "payable" === e.stateMutability)
              : void (0, s.assertArgument)(
                  !1,
                  "invalid fallback description",
                  "obj",
                  e
                );
          }
          static isFragment(e) {
            return e && e[I] === D;
          }
        }
        t.FallbackFragment = Q;
        class q extends G {
          constant;
          outputs;
          stateMutability;
          payable;
          gas;
          constructor(e, t, n, i, a, o) {
            super(e, "function", t, i),
              Object.defineProperty(this, I, { value: U }),
              (a = Object.freeze(a.slice())),
              (0, s.defineProperties)(this, {
                constant: "view" === n || "pure" === n,
                gas: o,
                outputs: a,
                payable: "payable" === n,
                stateMutability: n,
              });
          }
          get selector() {
            return (0, i.id)(this.format("sighash")).substring(0, 10);
          }
          format(e) {
            if ((null == e && (e = "sighash"), "json" === e))
              return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability:
                  "nonpayable" !== this.stateMutability
                    ? this.stateMutability
                    : void 0,
                payable: this.payable,
                gas: null != this.gas ? this.gas : void 0,
                inputs: this.inputs.map((t) => JSON.parse(t.format(e))),
                outputs: this.outputs.map((t) => JSON.parse(t.format(e))),
              });
            let t = [];
            return (
              "sighash" !== e && t.push("function"),
              t.push(this.name + K(e, this.inputs)),
              "sighash" !== e &&
                ("nonpayable" !== this.stateMutability &&
                  t.push(this.stateMutability),
                this.outputs &&
                  this.outputs.length &&
                  (t.push("returns"), t.push(K(e, this.outputs))),
                null != this.gas && t.push(`@${this.gas.toString()}`)),
              t.join(" ")
            );
          }
          static getSelector(e, t) {
            return new q(
              R,
              e,
              "view",
              (t = (t || []).map((e) => H.from(e))),
              [],
              null
            ).selector;
          }
          static from(e) {
            if (q.isFragment(e)) return e;
            if ("string" == typeof e)
              try {
                return q.from(E(e));
              } catch (t) {
                (0, s.assertArgument)(
                  !1,
                  "invalid function fragment",
                  "obj",
                  e
                );
              }
            else if (e instanceof v) {
              let t = k("function", e),
                n = O(e),
                s = x(e),
                i = [];
              T(e, a(["returns"])).has("returns") && (i = O(e));
              let o = S(e);
              return C(e), new q(R, t, s, n, i, o);
            }
            let t = e.stateMutability;
            return (
              null != t ||
                ((t = "payable"),
                "boolean" == typeof e.constant
                  ? ((t = "view"),
                    e.constant ||
                      ((t = "payable"),
                      "boolean" != typeof e.payable ||
                        e.payable ||
                        (t = "nonpayable")))
                  : "boolean" != typeof e.payable ||
                    e.payable ||
                    (t = "nonpayable")),
              new q(
                R,
                e.name,
                t,
                e.inputs ? e.inputs.map(H.from) : [],
                e.outputs ? e.outputs.map(H.from) : [],
                null != e.gas ? e.gas : null
              )
            );
          }
          static isFragment(e) {
            return e && e[I] === U;
          }
        }
        t.FunctionFragment = q;
        class W extends G {
          constructor(e, t, n) {
            super(e, "struct", t, n),
              Object.defineProperty(this, I, { value: j });
          }
          format() {
            throw Error("@TODO");
          }
          static from(e) {
            if ("string" == typeof e)
              try {
                return W.from(E(e));
              } catch (t) {
                (0, s.assertArgument)(!1, "invalid struct fragment", "obj", e);
              }
            else if (e instanceof v) {
              let t = k("struct", e),
                n = O(e);
              return C(e), new W(R, t, n);
            }
            return new W(R, e.name, e.inputs ? e.inputs.map(H.from) : []);
          }
          static isFragment(e) {
            return e && e[I] === j;
          }
        }
        t.StructFragment = W;
      },
      93707: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Typed =
            t.Result =
            t.TransactionDescription =
            t.LogDescription =
            t.ErrorDescription =
            t.Interface =
            t.Indexed =
            t.checkResultErrors =
            t.StructFragment =
            t.ParamType =
            t.NamedFragment =
            t.FunctionFragment =
            t.Fragment =
            t.FallbackFragment =
            t.EventFragment =
            t.ErrorFragment =
            t.ConstructorFragment =
            t.encodeBytes32String =
            t.decodeBytes32String =
            t.AbiCoder =
              void 0);
        var s = n(54760);
        Object.defineProperty(t, "AbiCoder", {
          enumerable: !0,
          get: function () {
            return s.AbiCoder;
          },
        });
        var i = n(12472);
        Object.defineProperty(t, "decodeBytes32String", {
          enumerable: !0,
          get: function () {
            return i.decodeBytes32String;
          },
        }),
          Object.defineProperty(t, "encodeBytes32String", {
            enumerable: !0,
            get: function () {
              return i.encodeBytes32String;
            },
          });
        var a = n(66711);
        Object.defineProperty(t, "ConstructorFragment", {
          enumerable: !0,
          get: function () {
            return a.ConstructorFragment;
          },
        }),
          Object.defineProperty(t, "ErrorFragment", {
            enumerable: !0,
            get: function () {
              return a.ErrorFragment;
            },
          }),
          Object.defineProperty(t, "EventFragment", {
            enumerable: !0,
            get: function () {
              return a.EventFragment;
            },
          }),
          Object.defineProperty(t, "FallbackFragment", {
            enumerable: !0,
            get: function () {
              return a.FallbackFragment;
            },
          }),
          Object.defineProperty(t, "Fragment", {
            enumerable: !0,
            get: function () {
              return a.Fragment;
            },
          }),
          Object.defineProperty(t, "FunctionFragment", {
            enumerable: !0,
            get: function () {
              return a.FunctionFragment;
            },
          }),
          Object.defineProperty(t, "NamedFragment", {
            enumerable: !0,
            get: function () {
              return a.NamedFragment;
            },
          }),
          Object.defineProperty(t, "ParamType", {
            enumerable: !0,
            get: function () {
              return a.ParamType;
            },
          }),
          Object.defineProperty(t, "StructFragment", {
            enumerable: !0,
            get: function () {
              return a.StructFragment;
            },
          });
        var o = n(16401);
        Object.defineProperty(t, "checkResultErrors", {
          enumerable: !0,
          get: function () {
            return o.checkResultErrors;
          },
        }),
          Object.defineProperty(t, "Indexed", {
            enumerable: !0,
            get: function () {
              return o.Indexed;
            },
          }),
          Object.defineProperty(t, "Interface", {
            enumerable: !0,
            get: function () {
              return o.Interface;
            },
          }),
          Object.defineProperty(t, "ErrorDescription", {
            enumerable: !0,
            get: function () {
              return o.ErrorDescription;
            },
          }),
          Object.defineProperty(t, "LogDescription", {
            enumerable: !0,
            get: function () {
              return o.LogDescription;
            },
          }),
          Object.defineProperty(t, "TransactionDescription", {
            enumerable: !0,
            get: function () {
              return o.TransactionDescription;
            },
          }),
          Object.defineProperty(t, "Result", {
            enumerable: !0,
            get: function () {
              return o.Result;
            },
          });
        var l = n(3762);
        Object.defineProperty(t, "Typed", {
          enumerable: !0,
          get: function () {
            return l.Typed;
          },
        });
      },
      16401: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Interface =
            t.Indexed =
            t.ErrorDescription =
            t.TransactionDescription =
            t.LogDescription =
            t.Result =
            t.checkResultErrors =
              void 0);
        let s = n(96965),
          i = n(62475),
          a = n(42120),
          o = n(54760),
          l = n(12900);
        Object.defineProperty(t, "checkResultErrors", {
          enumerable: !0,
          get: function () {
            return l.checkResultErrors;
          },
        }),
          Object.defineProperty(t, "Result", {
            enumerable: !0,
            get: function () {
              return l.Result;
            },
          });
        let u = n(66711),
          c = n(3762);
        class d {
          fragment;
          name;
          signature;
          topic;
          args;
          constructor(e, t, n) {
            let s = e.name,
              i = e.format();
            (0, a.defineProperties)(this, {
              fragment: e,
              name: s,
              signature: i,
              topic: t,
              args: n,
            });
          }
        }
        t.LogDescription = d;
        class h {
          fragment;
          name;
          args;
          signature;
          selector;
          value;
          constructor(e, t, n, s) {
            let i = e.name,
              o = e.format();
            (0, a.defineProperties)(this, {
              fragment: e,
              name: i,
              args: n,
              signature: o,
              selector: t,
              value: s,
            });
          }
        }
        t.TransactionDescription = h;
        class p {
          fragment;
          name;
          args;
          signature;
          selector;
          constructor(e, t, n) {
            let s = e.name,
              i = e.format();
            (0, a.defineProperties)(this, {
              fragment: e,
              name: s,
              args: n,
              signature: i,
              selector: t,
            });
          }
        }
        t.ErrorDescription = p;
        class f {
          hash;
          _isIndexed;
          static isIndexed(e) {
            return !!(e && e._isIndexed);
          }
          constructor(e) {
            (0, a.defineProperties)(this, { hash: e, _isIndexed: !0 });
          }
        }
        t.Indexed = f;
        let g = {
            0: "generic panic",
            1: "assert(false)",
            17: "arithmetic overflow",
            18: "division or modulo by zero",
            33: "enum overflow",
            34: "invalid encoded storage byte array accessed",
            49: "out-of-bounds array access; popping on an empty array",
            50: "out-of-bounds access of an array or bytesN",
            65: "out of memory",
            81: "uninitialized function",
          },
          m = {
            "0x08c379a0": {
              signature: "Error(string)",
              name: "Error",
              inputs: ["string"],
              reason: (e) => `reverted with reason string ${JSON.stringify(e)}`,
            },
            "0x4e487b71": {
              signature: "Panic(uint256)",
              name: "Panic",
              inputs: ["uint256"],
              reason: (e) => {
                let t = "unknown panic code";
                return (
                  e >= 0 &&
                    e <= 255 &&
                    g[e.toString()] &&
                    (t = g[e.toString()]),
                  `reverted with panic code 0x${e.toString(16)} (${t})`
                );
              },
            },
          };
        class y {
          fragments;
          deploy;
          fallback;
          receive;
          #f;
          #g;
          #m;
          #y;
          constructor(e) {
            let t = [];
            (t = "string" == typeof e ? JSON.parse(e) : e),
              (this.#m = new Map()),
              (this.#f = new Map()),
              (this.#g = new Map());
            let n = [];
            for (let e of t)
              try {
                n.push(u.Fragment.from(e));
              } catch (t) {
                console.log(
                  `[Warning] Invalid Fragment ${JSON.stringify(e)}:`,
                  t.message
                );
              }
            (0, a.defineProperties)(this, { fragments: Object.freeze(n) });
            let s = null,
              i = !1;
            (this.#y = this.getAbiCoder()),
              this.fragments.forEach((e, t) => {
                let n;
                switch (e.type) {
                  case "constructor":
                    if (this.deploy) {
                      console.log("duplicate definition - constructor");
                      return;
                    }
                    (0, a.defineProperties)(this, { deploy: e });
                    return;
                  case "fallback":
                    0 === e.inputs.length
                      ? (i = !0)
                      : ((0, a.assertArgument)(
                          !s || e.payable !== s.payable,
                          "conflicting fallback fragments",
                          `fragments[${t}]`,
                          e
                        ),
                        (i = (s = e).payable));
                    return;
                  case "function":
                    n = this.#m;
                    break;
                  case "event":
                    n = this.#g;
                    break;
                  case "error":
                    n = this.#f;
                    break;
                  default:
                    return;
                }
                let o = e.format();
                n.has(o) || n.set(o, e);
              }),
              this.deploy ||
                (0, a.defineProperties)(this, {
                  deploy: u.ConstructorFragment.from("constructor()"),
                }),
              (0, a.defineProperties)(this, { fallback: s, receive: i });
          }
          format(e) {
            let t = e ? "minimal" : "full";
            return this.fragments.map((e) => e.format(t));
          }
          formatJson() {
            return JSON.stringify(
              this.fragments
                .map((e) => e.format("json"))
                .map((e) => JSON.parse(e))
            );
          }
          getAbiCoder() {
            return o.AbiCoder.defaultAbiCoder();
          }
          #b(e, t, n) {
            if ((0, a.isHexString)(e)) {
              let t = e.toLowerCase();
              for (let e of this.#m.values()) if (t === e.selector) return e;
              return null;
            }
            if (-1 === e.indexOf("(")) {
              let s = [];
              for (let [t, n] of this.#m) t.split("(")[0] === e && s.push(n);
              if (t) {
                let e = t.length > 0 ? t[t.length - 1] : null,
                  n = t.length,
                  i = !0;
                c.Typed.isTyped(e) && "overrides" === e.type && ((i = !1), n--);
                for (let e = s.length - 1; e >= 0; e--) {
                  let t = s[e].inputs.length;
                  t === n || (i && t === n - 1) || s.splice(e, 1);
                }
                for (let e = s.length - 1; e >= 0; e--) {
                  let n = s[e].inputs;
                  for (let i = 0; i < t.length; i++)
                    if (c.Typed.isTyped(t[i])) {
                      if (i >= n.length) {
                        if ("overrides" === t[i].type) continue;
                        s.splice(e, 1);
                        break;
                      }
                      if (t[i].type !== n[i].baseType) {
                        s.splice(e, 1);
                        break;
                      }
                    }
                }
              }
              if (1 === s.length && t && t.length !== s[0].inputs.length) {
                let e = t[t.length - 1];
                (null == e || Array.isArray(e) || "object" != typeof e) &&
                  s.splice(0, 1);
              }
              if (0 === s.length) return null;
              if (s.length > 1 && n) {
                let t = s.map((e) => JSON.stringify(e.format())).join(", ");
                (0, a.assertArgument)(
                  !1,
                  `ambiguous function description (i.e. matches ${t})`,
                  "key",
                  e
                );
              }
              return s[0];
            }
            return this.#m.get(u.FunctionFragment.from(e).format()) || null;
          }
          getFunctionName(e) {
            let t = this.#b(e, null, !1);
            return (
              (0, a.assertArgument)(t, "no matching function", "key", e), t.name
            );
          }
          hasFunction(e) {
            return !!this.#b(e, null, !1);
          }
          getFunction(e, t) {
            return this.#b(e, t || null, !0);
          }
          forEachFunction(e) {
            let t = Array.from(this.#m.keys());
            t.sort((e, t) => e.localeCompare(t));
            for (let n = 0; n < t.length; n++) {
              let s = t[n];
              e(this.#m.get(s), n);
            }
          }
          #A(e, t, n) {
            if ((0, a.isHexString)(e)) {
              let t = e.toLowerCase();
              for (let e of this.#g.values()) if (t === e.topicHash) return e;
              return null;
            }
            if (-1 === e.indexOf("(")) {
              let s = [];
              for (let [t, n] of this.#g) t.split("(")[0] === e && s.push(n);
              if (t) {
                for (let e = s.length - 1; e >= 0; e--)
                  s[e].inputs.length < t.length && s.splice(e, 1);
                for (let e = s.length - 1; e >= 0; e--) {
                  let n = s[e].inputs;
                  for (let i = 0; i < t.length; i++)
                    if (c.Typed.isTyped(t[i]) && t[i].type !== n[i].baseType) {
                      s.splice(e, 1);
                      break;
                    }
                }
              }
              if (0 === s.length) return null;
              if (s.length > 1 && n) {
                let t = s.map((e) => JSON.stringify(e.format())).join(", ");
                (0, a.assertArgument)(
                  !1,
                  `ambiguous event description (i.e. matches ${t})`,
                  "key",
                  e
                );
              }
              return s[0];
            }
            return this.#g.get(u.EventFragment.from(e).format()) || null;
          }
          getEventName(e) {
            let t = this.#A(e, null, !1);
            return (
              (0, a.assertArgument)(t, "no matching event", "key", e), t.name
            );
          }
          hasEvent(e) {
            return !!this.#A(e, null, !1);
          }
          getEvent(e, t) {
            return this.#A(e, t || null, !0);
          }
          forEachEvent(e) {
            let t = Array.from(this.#g.keys());
            t.sort((e, t) => e.localeCompare(t));
            for (let n = 0; n < t.length; n++) {
              let s = t[n];
              e(this.#g.get(s), n);
            }
          }
          getError(e, t) {
            if ((0, a.isHexString)(e)) {
              let t = e.toLowerCase();
              if (m[t]) return u.ErrorFragment.from(m[t].signature);
              for (let e of this.#f.values()) if (t === e.selector) return e;
              return null;
            }
            if (-1 === e.indexOf("(")) {
              let t = [];
              for (let [n, s] of this.#f) n.split("(")[0] === e && t.push(s);
              if (0 === t.length)
                return "Error" === e
                  ? u.ErrorFragment.from("error Error(string)")
                  : "Panic" === e
                  ? u.ErrorFragment.from("error Panic(uint256)")
                  : null;
              if (t.length > 1) {
                let n = t.map((e) => JSON.stringify(e.format())).join(", ");
                (0, a.assertArgument)(
                  !1,
                  `ambiguous error description (i.e. ${n})`,
                  "name",
                  e
                );
              }
              return t[0];
            }
            return "Error(string)" === (e = u.ErrorFragment.from(e).format())
              ? u.ErrorFragment.from("error Error(string)")
              : "Panic(uint256)" === e
              ? u.ErrorFragment.from("error Panic(uint256)")
              : this.#f.get(e) || null;
          }
          forEachError(e) {
            let t = Array.from(this.#f.keys());
            t.sort((e, t) => e.localeCompare(t));
            for (let n = 0; n < t.length; n++) {
              let s = t[n];
              e(this.#f.get(s), n);
            }
          }
          _decodeParams(e, t) {
            return this.#y.decode(e, t);
          }
          _encodeParams(e, t) {
            return this.#y.encode(e, t);
          }
          encodeDeploy(e) {
            return this._encodeParams(this.deploy.inputs, e || []);
          }
          decodeErrorResult(e, t) {
            if ("string" == typeof e) {
              let t = this.getError(e);
              (0, a.assertArgument)(t, "unknown error", "fragment", e), (e = t);
            }
            return (
              (0, a.assertArgument)(
                (0, a.dataSlice)(t, 0, 4) === e.selector,
                `data signature does not match error ${e.name}.`,
                "data",
                t
              ),
              this._decodeParams(e.inputs, (0, a.dataSlice)(t, 4))
            );
          }
          encodeErrorResult(e, t) {
            if ("string" == typeof e) {
              let t = this.getError(e);
              (0, a.assertArgument)(t, "unknown error", "fragment", e), (e = t);
            }
            return (0, a.concat)([
              e.selector,
              this._encodeParams(e.inputs, t || []),
            ]);
          }
          decodeFunctionData(e, t) {
            if ("string" == typeof e) {
              let t = this.getFunction(e);
              (0, a.assertArgument)(t, "unknown function", "fragment", e),
                (e = t);
            }
            return (
              (0, a.assertArgument)(
                (0, a.dataSlice)(t, 0, 4) === e.selector,
                `data signature does not match function ${e.name}.`,
                "data",
                t
              ),
              this._decodeParams(e.inputs, (0, a.dataSlice)(t, 4))
            );
          }
          encodeFunctionData(e, t) {
            if ("string" == typeof e) {
              let t = this.getFunction(e);
              (0, a.assertArgument)(t, "unknown function", "fragment", e),
                (e = t);
            }
            return (0, a.concat)([
              e.selector,
              this._encodeParams(e.inputs, t || []),
            ]);
          }
          decodeFunctionResult(e, t) {
            if ("string" == typeof e) {
              let t = this.getFunction(e);
              (0, a.assertArgument)(t, "unknown function", "fragment", e),
                (e = t);
            }
            let n = "invalid length for result data",
              s = (0, a.getBytesCopy)(t);
            if (s.length % 32 == 0)
              try {
                return this.#y.decode(e.outputs, s);
              } catch (e) {
                n = "could not decode result data";
              }
            (0, a.assert)(!1, n, "BAD_DATA", {
              value: (0, a.hexlify)(s),
              info: { method: e.name, signature: e.format() },
            });
          }
          makeError(e, t) {
            let n = (0, a.getBytes)(e, "data"),
              s = o.AbiCoder.getBuiltinCallException("call", t, n);
            if (
              s.message.startsWith("execution reverted (unknown custom error)")
            ) {
              let e = (0, a.hexlify)(n.slice(0, 4)),
                t = this.getError(e);
              if (t)
                try {
                  let e = this.#y.decode(t.inputs, n.slice(4));
                  (s.revert = { name: t.name, signature: t.format(), args: e }),
                    (s.reason = s.revert.signature),
                    (s.message = `execution reverted: ${s.reason}`);
                } catch (e) {
                  s.message =
                    "execution reverted (coult not decode custom error)";
                }
            }
            let i = this.parseTransaction(t);
            return (
              i &&
                (s.invocation = {
                  method: i.name,
                  signature: i.signature,
                  args: i.args,
                }),
              s
            );
          }
          encodeFunctionResult(e, t) {
            if ("string" == typeof e) {
              let t = this.getFunction(e);
              (0, a.assertArgument)(t, "unknown function", "fragment", e),
                (e = t);
            }
            return (0, a.hexlify)(this.#y.encode(e.outputs, t || []));
          }
          encodeFilterTopics(e, t) {
            if ("string" == typeof e) {
              let t = this.getEvent(e);
              (0, a.assertArgument)(t, "unknown event", "eventFragment", e),
                (e = t);
            }
            (0, a.assert)(
              t.length <= e.inputs.length,
              `too many arguments for ${e.format()}`,
              "UNEXPECTED_ARGUMENT",
              { count: t.length, expectedCount: e.inputs.length }
            );
            let n = [];
            e.anonymous || n.push(e.topicHash);
            let o = (e, t) =>
              "string" === e.type
                ? (0, i.id)(t)
                : "bytes" === e.type
                ? (0, s.keccak256)((0, a.hexlify)(t))
                : ("bool" === e.type && "boolean" == typeof t
                    ? (t = t ? "0x01" : "0x00")
                    : e.type.match(/^u?int/)
                    ? (t = (0, a.toBeHex)(t))
                    : e.type.match(/^bytes/)
                    ? (t = (0, a.zeroPadBytes)(t, 32))
                    : "address" === e.type && this.#y.encode(["address"], [t]),
                  (0, a.zeroPadValue)((0, a.hexlify)(t), 32));
            for (
              t.forEach((t, s) => {
                let i = e.inputs[s];
                if (!i.indexed) {
                  (0, a.assertArgument)(
                    null == t,
                    "cannot filter non-indexed parameters; must be null",
                    "contract." + i.name,
                    t
                  );
                  return;
                }
                null == t
                  ? n.push(null)
                  : "array" === i.baseType || "tuple" === i.baseType
                  ? (0, a.assertArgument)(
                      !1,
                      "filtering with tuples or arrays not supported",
                      "contract." + i.name,
                      t
                    )
                  : Array.isArray(t)
                  ? n.push(t.map((e) => o(i, e)))
                  : n.push(o(i, t));
              });
              n.length && null === n[n.length - 1];

            )
              n.pop();
            return n;
          }
          encodeEventLog(e, t) {
            if ("string" == typeof e) {
              let t = this.getEvent(e);
              (0, a.assertArgument)(t, "unknown event", "eventFragment", e),
                (e = t);
            }
            let n = [],
              o = [],
              l = [];
            return (
              e.anonymous || n.push(e.topicHash),
              (0, a.assertArgument)(
                t.length === e.inputs.length,
                "event arguments/values mismatch",
                "values",
                t
              ),
              e.inputs.forEach((e, a) => {
                let u = t[a];
                if (e.indexed) {
                  if ("string" === e.type) n.push((0, i.id)(u));
                  else if ("bytes" === e.type) n.push((0, s.keccak256)(u));
                  else if ("tuple" === e.baseType || "array" === e.baseType)
                    throw Error("not implemented");
                  else n.push(this.#y.encode([e.type], [u]));
                } else o.push(e), l.push(u);
              }),
              { data: this.#y.encode(o, l), topics: n }
            );
          }
          decodeEventLog(e, t, n) {
            if ("string" == typeof e) {
              let t = this.getEvent(e);
              (0, a.assertArgument)(t, "unknown event", "eventFragment", e),
                (e = t);
            }
            if (null != n && !e.anonymous) {
              let t = e.topicHash;
              (0, a.assertArgument)(
                (0, a.isHexString)(n[0], 32) && n[0].toLowerCase() === t,
                "fragment/topic mismatch",
                "topics[0]",
                n[0]
              ),
                (n = n.slice(1));
            }
            let s = [],
              i = [],
              o = [];
            e.inputs.forEach((e, t) => {
              e.indexed
                ? "string" === e.type ||
                  "bytes" === e.type ||
                  "tuple" === e.baseType ||
                  "array" === e.baseType
                  ? (s.push(
                      u.ParamType.from({ type: "bytes32", name: e.name })
                    ),
                    o.push(!0))
                  : (s.push(e), o.push(!1))
                : (i.push(e), o.push(!1));
            });
            let c = null != n ? this.#y.decode(s, (0, a.concat)(n)) : null,
              d = this.#y.decode(i, t, !0),
              h = [],
              p = [],
              g = 0,
              m = 0;
            return (
              e.inputs.forEach((e, t) => {
                let n = null;
                if (e.indexed) {
                  if (null == c) n = new f(null);
                  else if (o[t]) n = new f(c[m++]);
                  else
                    try {
                      n = c[m++];
                    } catch (e) {
                      n = e;
                    }
                } else
                  try {
                    n = d[g++];
                  } catch (e) {
                    n = e;
                  }
                h.push(n), p.push(e.name || null);
              }),
              l.Result.fromItems(h, p)
            );
          }
          parseTransaction(e) {
            let t = (0, a.getBytes)(e.data, "tx.data"),
              n = (0, a.getBigInt)(null != e.value ? e.value : 0, "tx.value"),
              s = this.getFunction((0, a.hexlify)(t.slice(0, 4)));
            if (!s) return null;
            let i = this.#y.decode(s.inputs, t.slice(4));
            return new h(s, s.selector, i, n);
          }
          parseCallResult(e) {
            throw Error("@TODO");
          }
          parseLog(e) {
            let t = this.getEvent(e.topics[0]);
            return !t || t.anonymous
              ? null
              : new d(t, t.topicHash, this.decodeEventLog(t, e.data, e.topics));
          }
          parseError(e) {
            let t = (0, a.hexlify)(e),
              n = this.getError((0, a.dataSlice)(t, 0, 4));
            if (!n) return null;
            let s = this.#y.decode(n.inputs, (0, a.dataSlice)(t, 4));
            return new p(n, n.selector, s);
          }
          static from(e) {
            return e instanceof y
              ? e
              : new y(
                  "string" == typeof e
                    ? JSON.parse(e)
                    : "function" == typeof e.formatJson
                    ? e.formatJson()
                    : "function" == typeof e.format
                    ? e.format("json")
                    : e
                );
          }
        }
        t.Interface = y;
      },
      3762: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Typed = void 0);
        let s = n(42120),
          i = {};
        function a(e, t) {
          let n = !1;
          return (
            t < 0 && ((n = !0), (t *= -1)),
            new u(i, `${n ? "" : "u"}int${t}`, e, { signed: n, width: t })
          );
        }
        function o(e, t) {
          return new u(i, `bytes${t || ""}`, e, { size: t });
        }
        let l = Symbol.for("_ethers_typed");
        class u {
          type;
          value;
          #w;
          _typedSymbol;
          constructor(e, t, n, a) {
            null == a && (a = null),
              (0, s.assertPrivate)(i, e, "Typed"),
              (0, s.defineProperties)(this, {
                _typedSymbol: l,
                type: t,
                value: n,
              }),
              (this.#w = a),
              this.format();
          }
          format() {
            if ("array" === this.type || "dynamicArray" === this.type)
              throw Error("");
            return "tuple" === this.type
              ? `tuple(${this.value.map((e) => e.format()).join(",")})`
              : this.type;
          }
          defaultValue() {
            return 0;
          }
          minValue() {
            return 0;
          }
          maxValue() {
            return 0;
          }
          isBigInt() {
            return !!this.type.match(/^u?int[0-9]+$/);
          }
          isData() {
            return this.type.startsWith("bytes");
          }
          isString() {
            return "string" === this.type;
          }
          get tupleName() {
            if ("tuple" !== this.type) throw TypeError("not a tuple");
            return this.#w;
          }
          get arrayLength() {
            if ("array" !== this.type) throw TypeError("not an array");
            return !0 === this.#w
              ? -1
              : !1 === this.#w
              ? this.value.length
              : null;
          }
          static from(e, t) {
            return new u(i, e, t);
          }
          static uint8(e) {
            return a(e, 8);
          }
          static uint16(e) {
            return a(e, 16);
          }
          static uint24(e) {
            return a(e, 24);
          }
          static uint32(e) {
            return a(e, 32);
          }
          static uint40(e) {
            return a(e, 40);
          }
          static uint48(e) {
            return a(e, 48);
          }
          static uint56(e) {
            return a(e, 56);
          }
          static uint64(e) {
            return a(e, 64);
          }
          static uint72(e) {
            return a(e, 72);
          }
          static uint80(e) {
            return a(e, 80);
          }
          static uint88(e) {
            return a(e, 88);
          }
          static uint96(e) {
            return a(e, 96);
          }
          static uint104(e) {
            return a(e, 104);
          }
          static uint112(e) {
            return a(e, 112);
          }
          static uint120(e) {
            return a(e, 120);
          }
          static uint128(e) {
            return a(e, 128);
          }
          static uint136(e) {
            return a(e, 136);
          }
          static uint144(e) {
            return a(e, 144);
          }
          static uint152(e) {
            return a(e, 152);
          }
          static uint160(e) {
            return a(e, 160);
          }
          static uint168(e) {
            return a(e, 168);
          }
          static uint176(e) {
            return a(e, 176);
          }
          static uint184(e) {
            return a(e, 184);
          }
          static uint192(e) {
            return a(e, 192);
          }
          static uint200(e) {
            return a(e, 200);
          }
          static uint208(e) {
            return a(e, 208);
          }
          static uint216(e) {
            return a(e, 216);
          }
          static uint224(e) {
            return a(e, 224);
          }
          static uint232(e) {
            return a(e, 232);
          }
          static uint240(e) {
            return a(e, 240);
          }
          static uint248(e) {
            return a(e, 248);
          }
          static uint256(e) {
            return a(e, 256);
          }
          static uint(e) {
            return a(e, 256);
          }
          static int8(e) {
            return a(e, -8);
          }
          static int16(e) {
            return a(e, -16);
          }
          static int24(e) {
            return a(e, -24);
          }
          static int32(e) {
            return a(e, -32);
          }
          static int40(e) {
            return a(e, -40);
          }
          static int48(e) {
            return a(e, -48);
          }
          static int56(e) {
            return a(e, -56);
          }
          static int64(e) {
            return a(e, -64);
          }
          static int72(e) {
            return a(e, -72);
          }
          static int80(e) {
            return a(e, -80);
          }
          static int88(e) {
            return a(e, -88);
          }
          static int96(e) {
            return a(e, -96);
          }
          static int104(e) {
            return a(e, -104);
          }
          static int112(e) {
            return a(e, -112);
          }
          static int120(e) {
            return a(e, -120);
          }
          static int128(e) {
            return a(e, -128);
          }
          static int136(e) {
            return a(e, -136);
          }
          static int144(e) {
            return a(e, -144);
          }
          static int152(e) {
            return a(e, -152);
          }
          static int160(e) {
            return a(e, -160);
          }
          static int168(e) {
            return a(e, -168);
          }
          static int176(e) {
            return a(e, -176);
          }
          static int184(e) {
            return a(e, -184);
          }
          static int192(e) {
            return a(e, -192);
          }
          static int200(e) {
            return a(e, -200);
          }
          static int208(e) {
            return a(e, -208);
          }
          static int216(e) {
            return a(e, -216);
          }
          static int224(e) {
            return a(e, -224);
          }
          static int232(e) {
            return a(e, -232);
          }
          static int240(e) {
            return a(e, -240);
          }
          static int248(e) {
            return a(e, -248);
          }
          static int256(e) {
            return a(e, -256);
          }
          static int(e) {
            return a(e, -256);
          }
          static bytes1(e) {
            return o(e, 1);
          }
          static bytes2(e) {
            return o(e, 2);
          }
          static bytes3(e) {
            return o(e, 3);
          }
          static bytes4(e) {
            return o(e, 4);
          }
          static bytes5(e) {
            return o(e, 5);
          }
          static bytes6(e) {
            return o(e, 6);
          }
          static bytes7(e) {
            return o(e, 7);
          }
          static bytes8(e) {
            return o(e, 8);
          }
          static bytes9(e) {
            return o(e, 9);
          }
          static bytes10(e) {
            return o(e, 10);
          }
          static bytes11(e) {
            return o(e, 11);
          }
          static bytes12(e) {
            return o(e, 12);
          }
          static bytes13(e) {
            return o(e, 13);
          }
          static bytes14(e) {
            return o(e, 14);
          }
          static bytes15(e) {
            return o(e, 15);
          }
          static bytes16(e) {
            return o(e, 16);
          }
          static bytes17(e) {
            return o(e, 17);
          }
          static bytes18(e) {
            return o(e, 18);
          }
          static bytes19(e) {
            return o(e, 19);
          }
          static bytes20(e) {
            return o(e, 20);
          }
          static bytes21(e) {
            return o(e, 21);
          }
          static bytes22(e) {
            return o(e, 22);
          }
          static bytes23(e) {
            return o(e, 23);
          }
          static bytes24(e) {
            return o(e, 24);
          }
          static bytes25(e) {
            return o(e, 25);
          }
          static bytes26(e) {
            return o(e, 26);
          }
          static bytes27(e) {
            return o(e, 27);
          }
          static bytes28(e) {
            return o(e, 28);
          }
          static bytes29(e) {
            return o(e, 29);
          }
          static bytes30(e) {
            return o(e, 30);
          }
          static bytes31(e) {
            return o(e, 31);
          }
          static bytes32(e) {
            return o(e, 32);
          }
          static address(e) {
            return new u(i, "address", e);
          }
          static bool(e) {
            return new u(i, "bool", !!e);
          }
          static bytes(e) {
            return new u(i, "bytes", e);
          }
          static string(e) {
            return new u(i, "string", e);
          }
          static array(e, t) {
            throw Error("not implemented yet");
          }
          static tuple(e, t) {
            throw Error("not implemented yet");
          }
          static overrides(e) {
            return new u(i, "overrides", Object.assign({}, e));
          }
          static isTyped(e) {
            return (
              e &&
              "object" == typeof e &&
              "_typedSymbol" in e &&
              e._typedSymbol === l
            );
          }
          static dereference(e, t) {
            if (u.isTyped(e)) {
              if (e.type !== t)
                throw Error(`invalid type: expecetd ${t}, got ${e.type}`);
              return e.value;
            }
            return e;
          }
        }
        t.Typed = u;
      },
      40805: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getIcapAddress = t.getAddress = void 0);
        let s = n(96965),
          i = n(42120),
          a = BigInt(0),
          o = BigInt(36);
        function l(e) {
          let t = (e = e.toLowerCase()).substring(2).split(""),
            n = new Uint8Array(40);
          for (let e = 0; e < 40; e++) n[e] = t[e].charCodeAt(0);
          let a = (0, i.getBytes)((0, s.keccak256)(n));
          for (let e = 0; e < 40; e += 2)
            a[e >> 1] >> 4 >= 8 && (t[e] = t[e].toUpperCase()),
              (15 & a[e >> 1]) >= 8 && (t[e + 1] = t[e + 1].toUpperCase());
          return "0x" + t.join("");
        }
        let u = {};
        for (let e = 0; e < 10; e++) u[String(e)] = String(e);
        for (let e = 0; e < 26; e++)
          u[String.fromCharCode(65 + e)] = String(10 + e);
        function c(e) {
          let t = (e =
            (e = e.toUpperCase()).substring(4) + e.substring(0, 2) + "00")
            .split("")
            .map((e) => u[e])
            .join("");
          for (; t.length >= 15; ) {
            let e = t.substring(0, 15);
            t = (parseInt(e, 10) % 97) + t.substring(e.length);
          }
          let n = String(98 - (parseInt(t, 10) % 97));
          for (; n.length < 2; ) n = "0" + n;
          return n;
        }
        let d = (function () {
          let e = {};
          for (let t = 0; t < 36; t++)
            e["0123456789abcdefghijklmnopqrstuvwxyz"[t]] = BigInt(t);
          return e;
        })();
        function h(e) {
          if (
            ((0, i.assertArgument)(
              "string" == typeof e,
              "invalid address",
              "address",
              e
            ),
            e.match(/^(0x)?[0-9a-fA-F]{40}$/))
          ) {
            e.startsWith("0x") || (e = "0x" + e);
            let t = l(e);
            return (
              (0, i.assertArgument)(
                !e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || t === e,
                "bad address checksum",
                "address",
                e
              ),
              t
            );
          }
          if (e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
            (0, i.assertArgument)(
              e.substring(2, 4) === c(e),
              "bad icap checksum",
              "address",
              e
            );
            let t = (function (e) {
              e = e.toLowerCase();
              let t = a;
              for (let n = 0; n < e.length; n++) t = t * o + d[e[n]];
              return t;
            })(e.substring(4)).toString(16);
            for (; t.length < 40; ) t = "0" + t;
            return l("0x" + t);
          }
          (0, i.assertArgument)(!1, "invalid address", "address", e);
        }
        (t.getAddress = h),
          (t.getIcapAddress = function (e) {
            let t = BigInt(h(e)).toString(36).toUpperCase();
            for (; t.length < 30; ) t = "0" + t;
            return "XE" + c("XE00" + t) + t;
          });
      },
      93442: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.resolveAddress = t.isAddress = t.isAddressable = void 0);
        let s = n(42120),
          i = n(40805);
        function a(e) {
          return e && "function" == typeof e.getAddress;
        }
        async function o(e, t) {
          let n = await t;
          return (
            (null == n || "0x0000000000000000000000000000000000000000" === n) &&
              ((0, s.assert)(
                "string" != typeof e,
                "unconfigured name",
                "UNCONFIGURED_NAME",
                { value: e }
              ),
              (0, s.assertArgument)(
                !1,
                "invalid AddressLike value; did not resolve to a value address",
                "target",
                e
              )),
            (0, i.getAddress)(n)
          );
        }
        (t.isAddressable = a),
          (t.isAddress = function (e) {
            try {
              return (0, i.getAddress)(e), !0;
            } catch (e) {}
            return !1;
          }),
          (t.resolveAddress = function (e, t) {
            return "string" == typeof e
              ? e.match(/^0x[0-9a-f]{40}$/i)
                ? (0, i.getAddress)(e)
                : ((0, s.assert)(
                    null != t,
                    "ENS resolution requires a provider",
                    "UNSUPPORTED_OPERATION",
                    { operation: "resolveName" }
                  ),
                  o(e, t.resolveName(e)))
              : a(e)
              ? o(e, e.getAddress())
              : e && "function" == typeof e.then
              ? o(e, e)
              : void (0, s.assertArgument)(
                  !1,
                  "unsupported addressable value",
                  "target",
                  e
                );
          });
      },
      96067: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getCreate2Address = t.getCreateAddress = void 0);
        let s = n(96965),
          i = n(42120),
          a = n(40805);
        (t.getCreateAddress = function (e) {
          let t = (0, a.getAddress)(e.from),
            n = (0, i.getBigInt)(e.nonce, "tx.nonce").toString(16);
          return (
            (n = "0" === n ? "0x" : n.length % 2 ? "0x0" + n : "0x" + n),
            (0, a.getAddress)(
              (0, i.dataSlice)((0, s.keccak256)((0, i.encodeRlp)([t, n])), 12)
            )
          );
        }),
          (t.getCreate2Address = function (e, t, n) {
            let o = (0, a.getAddress)(e),
              l = (0, i.getBytes)(t, "salt"),
              u = (0, i.getBytes)(n, "initCodeHash");
            return (
              (0, i.assertArgument)(
                32 === l.length,
                "salt must be 32 bytes",
                "salt",
                t
              ),
              (0, i.assertArgument)(
                32 === u.length,
                "initCodeHash must be 32 bytes",
                "initCodeHash",
                n
              ),
              (0, a.getAddress)(
                (0, i.dataSlice)(
                  (0, s.keccak256)((0, i.concat)(["0xff", o, l, u])),
                  12
                )
              )
            );
          });
      },
      45475: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.resolveAddress =
            t.isAddress =
            t.isAddressable =
            t.getCreate2Address =
            t.getCreateAddress =
            t.getIcapAddress =
            t.getAddress =
              void 0);
        var s = n(40805);
        Object.defineProperty(t, "getAddress", {
          enumerable: !0,
          get: function () {
            return s.getAddress;
          },
        }),
          Object.defineProperty(t, "getIcapAddress", {
            enumerable: !0,
            get: function () {
              return s.getIcapAddress;
            },
          });
        var i = n(96067);
        Object.defineProperty(t, "getCreateAddress", {
          enumerable: !0,
          get: function () {
            return i.getCreateAddress;
          },
        }),
          Object.defineProperty(t, "getCreate2Address", {
            enumerable: !0,
            get: function () {
              return i.getCreate2Address;
            },
          });
        var a = n(93442);
        Object.defineProperty(t, "isAddressable", {
          enumerable: !0,
          get: function () {
            return a.isAddressable;
          },
        }),
          Object.defineProperty(t, "isAddress", {
            enumerable: !0,
            get: function () {
              return a.isAddress;
            },
          }),
          Object.defineProperty(t, "resolveAddress", {
            enumerable: !0,
            get: function () {
              return a.resolveAddress;
            },
          });
      },
      23223: function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ZeroAddress = void 0),
          (t.ZeroAddress = "0x0000000000000000000000000000000000000000");
      },
      90688: function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ZeroHash = void 0),
          (t.ZeroHash =
            "0x0000000000000000000000000000000000000000000000000000000000000000");
      },
      61428: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.MessagePrefix =
            t.EtherSymbol =
            t.MaxInt256 =
            t.MinInt256 =
            t.MaxUint256 =
            t.WeiPerEther =
            t.N =
            t.ZeroHash =
            t.ZeroAddress =
              void 0);
        var s = n(23223);
        Object.defineProperty(t, "ZeroAddress", {
          enumerable: !0,
          get: function () {
            return s.ZeroAddress;
          },
        });
        var i = n(90688);
        Object.defineProperty(t, "ZeroHash", {
          enumerable: !0,
          get: function () {
            return i.ZeroHash;
          },
        });
        var a = n(24456);
        Object.defineProperty(t, "N", {
          enumerable: !0,
          get: function () {
            return a.N;
          },
        }),
          Object.defineProperty(t, "WeiPerEther", {
            enumerable: !0,
            get: function () {
              return a.WeiPerEther;
            },
          }),
          Object.defineProperty(t, "MaxUint256", {
            enumerable: !0,
            get: function () {
              return a.MaxUint256;
            },
          }),
          Object.defineProperty(t, "MinInt256", {
            enumerable: !0,
            get: function () {
              return a.MinInt256;
            },
          }),
          Object.defineProperty(t, "MaxInt256", {
            enumerable: !0,
            get: function () {
              return a.MaxInt256;
            },
          });
        var o = n(82359);
        Object.defineProperty(t, "EtherSymbol", {
          enumerable: !0,
          get: function () {
            return o.EtherSymbol;
          },
        }),
          Object.defineProperty(t, "MessagePrefix", {
            enumerable: !0,
            get: function () {
              return o.MessagePrefix;
            },
          });
      },
      24456: function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.MaxInt256 =
            t.MinInt256 =
            t.MaxUint256 =
            t.WeiPerEther =
            t.N =
              void 0),
          (t.N = BigInt(
            "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
          )),
          (t.WeiPerEther = BigInt("1000000000000000000")),
          (t.MaxUint256 = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          )),
          (t.MinInt256 =
            BigInt(
              "0x8000000000000000000000000000000000000000000000000000000000000000"
            ) * BigInt(-1)),
          (t.MaxInt256 = BigInt(
            "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          ));
      },
      82359: function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.MessagePrefix = t.EtherSymbol = void 0),
          (t.EtherSymbol = "Ξ"),
          (t.MessagePrefix = "\x19Ethereum Signed Message:\n");
      },
      44350: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Contract =
            t.BaseContract =
            t.resolveArgs =
            t.copyOverrides =
              void 0);
        let s = n(93707),
          i = n(45475),
          a = n(37143),
          o = n(42120),
          l = n(97151),
          u = BigInt(0);
        function c(e) {
          return e && "function" == typeof e.call;
        }
        function d(e) {
          return e && "function" == typeof e.estimateGas;
        }
        function h(e) {
          return e && "function" == typeof e.resolveName;
        }
        function p(e) {
          return e && "function" == typeof e.sendTransaction;
        }
        function f(e) {
          if (null != e) {
            if (h(e)) return e;
            if (e.provider) return e.provider;
          }
        }
        class g {
          #v;
          fragment;
          constructor(e, t, n) {
            if (
              ((0, o.defineProperties)(this, { fragment: t }),
              t.inputs.length < n.length)
            )
              throw Error("too many arguments");
            let s = m(e.runner, "resolveName"),
              a = h(s) ? s : null;
            this.#v = (async function () {
              let s = await Promise.all(
                t.inputs.map((e, t) =>
                  null == n[t]
                    ? null
                    : e.walkAsync(n[t], (e, t) =>
                        "address" === e
                          ? Array.isArray(t)
                            ? Promise.all(
                                t.map((e) => (0, i.resolveAddress)(e, a))
                              )
                            : (0, i.resolveAddress)(t, a)
                          : t
                      )
                )
              );
              return e.interface.encodeFilterTopics(t, s);
            })();
          }
          getTopicFilter() {
            return this.#v;
          }
        }
        function m(e, t) {
          return null == e
            ? null
            : "function" == typeof e[t]
            ? e
            : e.provider && "function" == typeof e.provider[t]
            ? e.provider
            : null;
        }
        function y(e) {
          return null == e ? null : e.provider || null;
        }
        async function b(e, t) {
          let n = s.Typed.dereference(e, "overrides");
          (0, o.assertArgument)(
            "object" == typeof n,
            "invalid overrides parameter",
            "overrides",
            e
          );
          let i = (0, a.copyRequest)(n);
          return (
            (0, o.assertArgument)(
              null == i.to || (t || []).indexOf("to") >= 0,
              "cannot override to",
              "overrides.to",
              i.to
            ),
            (0, o.assertArgument)(
              null == i.data || (t || []).indexOf("data") >= 0,
              "cannot override data",
              "overrides.data",
              i.data
            ),
            i.from && (i.from = i.from),
            i
          );
        }
        async function A(e, t, n) {
          let a = m(e, "resolveName"),
            o = h(a) ? a : null;
          return await Promise.all(
            t.map((e, t) =>
              e.walkAsync(n[t], (e, t) =>
                ((t = s.Typed.dereference(t, e)), "address" === e)
                  ? (0, i.resolveAddress)(t, o)
                  : t
              )
            )
          );
        }
        (t.copyOverrides = b), (t.resolveArgs = A);
        let w = Symbol.for("_ethersInternal_contract"),
          v = new WeakMap();
        function E(e) {
          return v.get(e[w]);
        }
        async function P(e, t) {
          let n;
          let s = null;
          if (Array.isArray(t)) {
            let s = function (t) {
              if ((0, o.isHexString)(t, 32)) return t;
              let n = e.interface.getEvent(t);
              return (
                (0, o.assertArgument)(n, "unknown fragment", "name", t),
                n.topicHash
              );
            };
            n = t.map((e) =>
              null == e ? null : Array.isArray(e) ? e.map(s) : s(e)
            );
          } else
            "*" === t
              ? (n = [null])
              : "string" == typeof t
              ? (0, o.isHexString)(t, 32)
                ? (n = [t])
                : ((s = e.interface.getEvent(t)),
                  (0, o.assertArgument)(s, "unknown fragment", "event", t),
                  (n = [s.topicHash]))
              : t &&
                "object" == typeof t &&
                "getTopicFilter" in t &&
                "function" == typeof t.getTopicFilter &&
                t.fragment
              ? (n = await t.getTopicFilter())
              : "fragment" in t
              ? (n = [(s = t.fragment).topicHash])
              : (0, o.assertArgument)(!1, "unknown event name", "event", t);
          return {
            fragment: s,
            tag: (n = n.map((e) => {
              if (null == e) return null;
              if (Array.isArray(e)) {
                let t = Array.from(
                  new Set(e.map((e) => e.toLowerCase())).values()
                );
                return 1 === t.length ? t[0] : (t.sort(), t);
              }
              return e.toLowerCase();
            }))
              .map((e) =>
                null == e ? "null" : Array.isArray(e) ? e.join("|") : e
              )
              .join("&"),
            topics: n,
          };
        }
        async function k(e, t) {
          let { subs: n } = E(e);
          return n.get((await P(e, t)).tag) || null;
        }
        async function T(e, t, n) {
          let s = y(e.runner);
          (0, o.assert)(
            s,
            "contract runner does not support subscribing",
            "UNSUPPORTED_OPERATION",
            { operation: t }
          );
          let { fragment: i, tag: a, topics: u } = await P(e, n),
            { addr: c, subs: d } = E(e),
            h = d.get(a);
          if (!h) {
            let t = { address: c || e, topics: u },
              o = (t) => {
                let s = i;
                if (null == s)
                  try {
                    s = e.interface.getEvent(t.topics[0]);
                  } catch (e) {}
                if (s) {
                  let a = s,
                    o = i
                      ? e.interface.decodeEventLog(i, t.data, t.topics)
                      : [];
                  S(e, n, o, (s) => new l.ContractEventPayload(e, s, n, a, t));
                } else
                  S(
                    e,
                    n,
                    [],
                    (s) => new l.ContractUnknownEventPayload(e, s, n, t)
                  );
              },
              p = [];
            (h = {
              tag: a,
              listeners: [],
              start: () => {
                p.length || p.push(s.on(t, o));
              },
              stop: async () => {
                if (0 == p.length) return;
                let e = p;
                (p = []), await Promise.all(e), s.off(t, o);
              },
            }),
              d.set(a, h);
          }
          return h;
        }
        let x = Promise.resolve();
        async function O(e, t, n, s) {
          await x;
          let i = await k(e, t);
          if (!i) return !1;
          let a = i.listeners.length;
          return (
            (i.listeners = i.listeners.filter(({ listener: t, once: i }) => {
              let a = Array.from(n);
              s && a.push(s(i ? null : t));
              try {
                t.call(e, ...a);
              } catch (e) {}
              return !i;
            })),
            0 === i.listeners.length && (i.stop(), E(e).subs.delete(i.tag)),
            a > 0
          );
        }
        async function S(e, t, n, s) {
          try {
            await x;
          } catch (e) {}
          let i = O(e, t, n, s);
          return (x = i), await i;
        }
        let C = ["then"];
        class B {
          target;
          interface;
          runner;
          filters;
          [w];
          fallback;
          constructor(e, t, n, a) {
            var g;
            let A;
            (0, o.assertArgument)(
              "string" == typeof e || (0, i.isAddressable)(e),
              "invalid value for Contract target",
              "target",
              e
            ),
              null == n && (n = null);
            let P = s.Interface.from(t);
            (0, o.defineProperties)(this, {
              target: e,
              runner: n,
              interface: P,
            }),
              Object.defineProperty(this, w, { value: {} });
            let k = null,
              T = null;
            if (a) {
              let e = y(n);
              T = new l.ContractTransactionResponse(this.interface, e, a);
            }
            let x = new Map();
            if ("string" == typeof e) {
              if ((0, o.isHexString)(e)) (k = e), (A = Promise.resolve(e));
              else {
                let t = m(n, "resolveName");
                if (!h(t))
                  throw (0, o.makeError)(
                    "contract runner does not support name resolution",
                    "UNSUPPORTED_OPERATION",
                    { operation: "resolveName" }
                  );
                A = t.resolveName(e).then((t) => {
                  if (null == t)
                    throw (0, o.makeError)(
                      "an ENS name used for a contract target must be correctly configured",
                      "UNCONFIGURED_NAME",
                      { value: e }
                    );
                  return (E(this).addr = t), t;
                });
              }
            } else
              A = e.getAddress().then((e) => {
                if (null == e) throw Error("TODO");
                return (E(this).addr = e), e;
              });
            (g = { addrPromise: A, addr: k, deployTx: T, subs: x }),
              v.set(this[w], g);
            let O = new Proxy(
              {},
              {
                get: (e, t, n) => {
                  if ("symbol" == typeof t || C.indexOf(t) >= 0)
                    return Reflect.get(e, t, n);
                  try {
                    return this.getEvent(t);
                  } catch (e) {
                    if (
                      !(0, o.isError)(e, "INVALID_ARGUMENT") ||
                      "key" !== e.argument
                    )
                      throw e;
                  }
                },
                has: (e, t) =>
                  C.indexOf(t) >= 0
                    ? Reflect.has(e, t)
                    : Reflect.has(e, t) || this.interface.hasEvent(String(t)),
              }
            );
            return (
              (0, o.defineProperties)(this, { filters: O }),
              (0, o.defineProperties)(this, {
                fallback:
                  P.receive || P.fallback
                    ? (function (e) {
                        let t = async function (t) {
                            let n = await b(t, ["data"]);
                            (n.to = await e.getAddress()),
                              n.from &&
                                (n.from = await (0, i.resolveAddress)(
                                  n.from,
                                  f(e.runner)
                                ));
                            let s = e.interface,
                              a =
                                (0, o.getBigInt)(
                                  n.value || u,
                                  "overrides.value"
                                ) === u,
                              l = "0x" === (n.data || "0x");
                            !s.fallback ||
                              s.fallback.payable ||
                              !s.receive ||
                              l ||
                              a ||
                              (0, o.assertArgument)(
                                !1,
                                "cannot send data to receive or send value to non-payable fallback",
                                "overrides",
                                t
                              ),
                              (0, o.assertArgument)(
                                s.fallback || l,
                                "cannot send data to receive-only contract",
                                "overrides.data",
                                n.data
                              );
                            let c =
                              s.receive || (s.fallback && s.fallback.payable);
                            return (
                              (0, o.assertArgument)(
                                c || a,
                                "cannot send value to non-payable fallback",
                                "overrides.value",
                                n.value
                              ),
                              (0, o.assertArgument)(
                                s.fallback || l,
                                "cannot send data to receive-only contract",
                                "overrides.data",
                                n.data
                              ),
                              n
                            );
                          },
                          n = async function (n) {
                            let s = m(e.runner, "call");
                            (0, o.assert)(
                              c(s),
                              "contract runner does not support calling",
                              "UNSUPPORTED_OPERATION",
                              { operation: "call" }
                            );
                            let i = await t(n);
                            try {
                              return await s.call(i);
                            } catch (t) {
                              if ((0, o.isCallException)(t) && t.data)
                                throw e.interface.makeError(t.data, i);
                              throw t;
                            }
                          },
                          s = async function (n) {
                            let s = e.runner;
                            (0, o.assert)(
                              p(s),
                              "contract runner does not support sending transactions",
                              "UNSUPPORTED_OPERATION",
                              { operation: "sendTransaction" }
                            );
                            let i = await s.sendTransaction(await t(n)),
                              a = y(e.runner);
                            return new l.ContractTransactionResponse(
                              e.interface,
                              a,
                              i
                            );
                          },
                          a = async function (n) {
                            let s = m(e.runner, "estimateGas");
                            return (
                              (0, o.assert)(
                                d(s),
                                "contract runner does not support gas estimation",
                                "UNSUPPORTED_OPERATION",
                                { operation: "estimateGas" }
                              ),
                              await s.estimateGas(await t(n))
                            );
                          },
                          h = async (e) => await s(e);
                        return (
                          (0, o.defineProperties)(h, {
                            _contract: e,
                            estimateGas: a,
                            populateTransaction: t,
                            send: s,
                            staticCall: n,
                          }),
                          h
                        );
                      })(this)
                    : null,
              }),
              new Proxy(this, {
                get: (e, t, n) => {
                  if ("symbol" == typeof t || t in e || C.indexOf(t) >= 0)
                    return Reflect.get(e, t, n);
                  try {
                    return e.getFunction(t);
                  } catch (e) {
                    if (
                      !(0, o.isError)(e, "INVALID_ARGUMENT") ||
                      "key" !== e.argument
                    )
                      throw e;
                  }
                },
                has: (e, t) =>
                  "symbol" == typeof t || t in e || C.indexOf(t) >= 0
                    ? Reflect.has(e, t)
                    : e.interface.hasFunction(t),
              })
            );
          }
          connect(e) {
            return new B(this.target, this.interface, e);
          }
          attach(e) {
            return new B(e, this.interface, this.runner);
          }
          async getAddress() {
            return await E(this).addrPromise;
          }
          async getDeployedCode() {
            let e = y(this.runner);
            (0, o.assert)(
              e,
              "runner does not support .provider",
              "UNSUPPORTED_OPERATION",
              { operation: "getDeployedCode" }
            );
            let t = await e.getCode(await this.getAddress());
            return "0x" === t ? null : t;
          }
          async waitForDeployment() {
            let e = this.deploymentTransaction();
            if (e) return await e.wait(), this;
            if (null != (await this.getDeployedCode())) return this;
            let t = y(this.runner);
            return (
              (0, o.assert)(
                null != t,
                "contract runner does not support .provider",
                "UNSUPPORTED_OPERATION",
                { operation: "waitForDeployment" }
              ),
              new Promise((e, n) => {
                let s = async () => {
                  try {
                    let n = await this.getDeployedCode();
                    if (null != n) return e(this);
                    t.once("block", s);
                  } catch (e) {
                    n(e);
                  }
                };
                s();
              })
            );
          }
          deploymentTransaction() {
            return E(this).deployTx;
          }
          getFunction(e) {
            return (
              "string" != typeof e && (e = e.format()),
              (function (e, t) {
                let n = function (...n) {
                    let s = e.interface.getFunction(t, n);
                    return (
                      (0, o.assert)(
                        s,
                        "no matching fragment",
                        "UNSUPPORTED_OPERATION",
                        { operation: "fragment", info: { key: t, args: n } }
                      ),
                      s
                    );
                  },
                  s = async function (...t) {
                    let s = n(...t),
                      a = {};
                    if (
                      (s.inputs.length + 1 === t.length &&
                        (a = await b(t.pop())).from &&
                        (a.from = await (0, i.resolveAddress)(
                          a.from,
                          f(e.runner)
                        )),
                      s.inputs.length !== t.length)
                    )
                      throw Error(
                        "internal error: fragment inputs doesn't match arguments; should not happen"
                      );
                    let l = await A(e.runner, s.inputs, t);
                    return Object.assign(
                      {},
                      a,
                      await (0, o.resolveProperties)({
                        to: e.getAddress(),
                        data: e.interface.encodeFunctionData(s, l),
                      })
                    );
                  },
                  a = async function (...e) {
                    let t = await g(...e);
                    return 1 === t.length ? t[0] : t;
                  },
                  u = async function (...t) {
                    let n = e.runner;
                    (0, o.assert)(
                      p(n),
                      "contract runner does not support sending transactions",
                      "UNSUPPORTED_OPERATION",
                      { operation: "sendTransaction" }
                    );
                    let i = await n.sendTransaction(await s(...t)),
                      a = y(e.runner);
                    return new l.ContractTransactionResponse(e.interface, a, i);
                  },
                  h = async function (...t) {
                    let n = m(e.runner, "estimateGas");
                    return (
                      (0, o.assert)(
                        d(n),
                        "contract runner does not support gas estimation",
                        "UNSUPPORTED_OPERATION",
                        { operation: "estimateGas" }
                      ),
                      await n.estimateGas(await s(...t))
                    );
                  },
                  g = async function (...t) {
                    let i = m(e.runner, "call");
                    (0, o.assert)(
                      c(i),
                      "contract runner does not support calling",
                      "UNSUPPORTED_OPERATION",
                      { operation: "call" }
                    );
                    let a = await s(...t),
                      l = "0x";
                    try {
                      l = await i.call(a);
                    } catch (t) {
                      if ((0, o.isCallException)(t) && t.data)
                        throw e.interface.makeError(t.data, a);
                      throw t;
                    }
                    let u = n(...t);
                    return e.interface.decodeFunctionResult(u, l);
                  },
                  w = async (...e) =>
                    n(...e).constant ? await a(...e) : await u(...e);
                return (
                  (0, o.defineProperties)(w, {
                    name: e.interface.getFunctionName(t),
                    _contract: e,
                    _key: t,
                    getFragment: n,
                    estimateGas: h,
                    populateTransaction: s,
                    send: u,
                    staticCall: a,
                    staticCallResult: g,
                  }),
                  Object.defineProperty(w, "fragment", {
                    configurable: !1,
                    enumerable: !0,
                    get: () => {
                      let n = e.interface.getFunction(t);
                      return (
                        (0, o.assert)(
                          n,
                          "no matching fragment",
                          "UNSUPPORTED_OPERATION",
                          { operation: "fragment", info: { key: t } }
                        ),
                        n
                      );
                    },
                  }),
                  w
                );
              })(this, e)
            );
          }
          getEvent(e) {
            return (
              "string" != typeof e && (e = e.format()),
              (function (e, t) {
                let n = function (...n) {
                    let s = e.interface.getEvent(t, n);
                    return (
                      (0, o.assert)(
                        s,
                        "no matching fragment",
                        "UNSUPPORTED_OPERATION",
                        { operation: "fragment", info: { key: t, args: n } }
                      ),
                      s
                    );
                  },
                  s = function (...t) {
                    return new g(e, n(...t), t);
                  };
                return (
                  (0, o.defineProperties)(s, {
                    name: e.interface.getEventName(t),
                    _contract: e,
                    _key: t,
                    getFragment: n,
                  }),
                  Object.defineProperty(s, "fragment", {
                    configurable: !1,
                    enumerable: !0,
                    get: () => {
                      let n = e.interface.getEvent(t);
                      return (
                        (0, o.assert)(
                          n,
                          "no matching fragment",
                          "UNSUPPORTED_OPERATION",
                          { operation: "fragment", info: { key: t } }
                        ),
                        n
                      );
                    },
                  }),
                  s
                );
              })(this, e)
            );
          }
          async queryTransaction(e) {
            throw Error("@TODO");
          }
          async queryFilter(e, t, n) {
            null == t && (t = 0), null == n && (n = "latest");
            let { addr: s, addrPromise: i } = E(this),
              u = s || (await i),
              { fragment: c, topics: d } = await P(this, e),
              h = { address: u, topics: d, fromBlock: t, toBlock: n },
              p = y(this.runner);
            return (
              (0, o.assert)(
                p,
                "contract runner does not have a provider",
                "UNSUPPORTED_OPERATION",
                { operation: "queryFilter" }
              ),
              (await p.getLogs(h)).map((e) => {
                let t = c;
                if (null == t)
                  try {
                    t = this.interface.getEvent(e.topics[0]);
                  } catch (e) {}
                if (t)
                  try {
                    return new l.EventLog(e, this.interface, t);
                  } catch (t) {
                    return new l.UndecodedEventLog(e, t);
                  }
                return new a.Log(e, p);
              })
            );
          }
          async on(e, t) {
            let n = await T(this, "on", e);
            return n.listeners.push({ listener: t, once: !1 }), n.start(), this;
          }
          async once(e, t) {
            let n = await T(this, "once", e);
            return n.listeners.push({ listener: t, once: !0 }), n.start(), this;
          }
          async emit(e, ...t) {
            return await S(this, e, t, null);
          }
          async listenerCount(e) {
            if (e) {
              let t = await k(this, e);
              return t ? t.listeners.length : 0;
            }
            let { subs: t } = E(this),
              n = 0;
            for (let { listeners: e } of t.values()) n += e.length;
            return n;
          }
          async listeners(e) {
            if (e) {
              let t = await k(this, e);
              return t ? t.listeners.map(({ listener: e }) => e) : [];
            }
            let { subs: t } = E(this),
              n = [];
            for (let { listeners: e } of t.values())
              n = n.concat(e.map(({ listener: e }) => e));
            return n;
          }
          async off(e, t) {
            let n = await k(this, e);
            if (!n) return this;
            if (t) {
              let e = n.listeners.map(({ listener: e }) => e).indexOf(t);
              e >= 0 && n.listeners.splice(e, 1);
            }
            return (
              (null == t || 0 === n.listeners.length) &&
                (n.stop(), E(this).subs.delete(n.tag)),
              this
            );
          }
          async removeAllListeners(e) {
            if (e) {
              let t = await k(this, e);
              if (!t) return this;
              t.stop(), E(this).subs.delete(t.tag);
            } else {
              let { subs: e } = E(this);
              for (let { tag: t, stop: n } of e.values()) n(), e.delete(t);
            }
            return this;
          }
          async addListener(e, t) {
            return await this.on(e, t);
          }
          async removeListener(e, t) {
            return await this.off(e, t);
          }
          static buildClass(e) {
            class t extends B {
              constructor(t, n = null) {
                super(t, e, n);
              }
            }
            return t;
          }
          static from(e, t, n) {
            return null == n && (n = null), new this(e, t, n);
          }
        }
        function N() {
          return B;
        }
        t.BaseContract = B;
        class R extends N() {}
        t.Contract = R;
      },
      31018: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ContractFactory = void 0);
        let s = n(93707),
          i = n(45475),
          a = n(42120),
          o = n(44350);
        class l {
          interface;
          bytecode;
          runner;
          constructor(e, t, n) {
            let i = s.Interface.from(e);
            t instanceof Uint8Array ||
              ("object" == typeof t && (t = t.object),
              t.startsWith("0x") || (t = "0x" + t)),
              (t = (0, a.hexlify)((0, a.getBytes)(t))),
              (0, a.defineProperties)(this, {
                bytecode: t,
                interface: i,
                runner: n || null,
              });
          }
          attach(e) {
            return new o.BaseContract(e, this.interface, this.runner);
          }
          async getDeployTransaction(...e) {
            let t = {},
              n = this.interface.deploy;
            if (
              (n.inputs.length + 1 === e.length &&
                (t = await (0, o.copyOverrides)(e.pop())),
              n.inputs.length !== e.length)
            )
              throw Error("incorrect number of arguments to constructor");
            let s = await (0, o.resolveArgs)(this.runner, n.inputs, e);
            return Object.assign({}, t, {
              data: (0, a.concat)([
                this.bytecode,
                this.interface.encodeDeploy(s),
              ]),
            });
          }
          async deploy(...e) {
            let t = await this.getDeployTransaction(...e);
            (0, a.assert)(
              this.runner && "function" == typeof this.runner.sendTransaction,
              "factory runner does not support sending transactions",
              "UNSUPPORTED_OPERATION",
              { operation: "sendTransaction" }
            );
            let n = await this.runner.sendTransaction(t),
              s = (0, i.getCreateAddress)(n);
            return new o.BaseContract(s, this.interface, this.runner, n);
          }
          connect(e) {
            return new l(this.interface, this.bytecode, e);
          }
          static fromSolidity(e, t) {
            (0, a.assertArgument)(
              null != e,
              "bad compiler output",
              "output",
              e
            ),
              "string" == typeof e && (e = JSON.parse(e));
            let n = e.abi,
              s = "";
            return (
              e.bytecode
                ? (s = e.bytecode)
                : e.evm && e.evm.bytecode && (s = e.evm.bytecode),
              new this(n, s, t)
            );
          }
        }
        t.ContractFactory = l;
      },
      37252: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.UndecodedEventLog =
            t.EventLog =
            t.ContractTransactionResponse =
            t.ContractTransactionReceipt =
            t.ContractUnknownEventPayload =
            t.ContractEventPayload =
            t.ContractFactory =
            t.Contract =
            t.BaseContract =
              void 0);
        var s = n(44350);
        Object.defineProperty(t, "BaseContract", {
          enumerable: !0,
          get: function () {
            return s.BaseContract;
          },
        }),
          Object.defineProperty(t, "Contract", {
            enumerable: !0,
            get: function () {
              return s.Contract;
            },
          });
        var i = n(31018);
        Object.defineProperty(t, "ContractFactory", {
          enumerable: !0,
          get: function () {
            return i.ContractFactory;
          },
        });
        var a = n(97151);
        Object.defineProperty(t, "ContractEventPayload", {
          enumerable: !0,
          get: function () {
            return a.ContractEventPayload;
          },
        }),
          Object.defineProperty(t, "ContractUnknownEventPayload", {
            enumerable: !0,
            get: function () {
              return a.ContractUnknownEventPayload;
            },
          }),
          Object.defineProperty(t, "ContractTransactionReceipt", {
            enumerable: !0,
            get: function () {
              return a.ContractTransactionReceipt;
            },
          }),
          Object.defineProperty(t, "ContractTransactionResponse", {
            enumerable: !0,
            get: function () {
              return a.ContractTransactionResponse;
            },
          }),
          Object.defineProperty(t, "EventLog", {
            enumerable: !0,
            get: function () {
              return a.EventLog;
            },
          }),
          Object.defineProperty(t, "UndecodedEventLog", {
            enumerable: !0,
            get: function () {
              return a.UndecodedEventLog;
            },
          });
      },
      97151: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ContractEventPayload =
            t.ContractUnknownEventPayload =
            t.ContractTransactionResponse =
            t.ContractTransactionReceipt =
            t.UndecodedEventLog =
            t.EventLog =
              void 0);
        let s = n(37143),
          i = n(42120);
        class a extends s.Log {
          interface;
          fragment;
          args;
          constructor(e, t, n) {
            super(e, e.provider);
            let s = t.decodeEventLog(n, e.data, e.topics);
            (0, i.defineProperties)(this, {
              args: s,
              fragment: n,
              interface: t,
            });
          }
          get eventName() {
            return this.fragment.name;
          }
          get eventSignature() {
            return this.fragment.format();
          }
        }
        t.EventLog = a;
        class o extends s.Log {
          error;
          constructor(e, t) {
            super(e, e.provider), (0, i.defineProperties)(this, { error: t });
          }
        }
        t.UndecodedEventLog = o;
        class l extends s.TransactionReceipt {
          #E;
          constructor(e, t, n) {
            super(n, t), (this.#E = e);
          }
          get logs() {
            return super.logs.map((e) => {
              let t = e.topics.length ? this.#E.getEvent(e.topics[0]) : null;
              if (t)
                try {
                  return new a(e, this.#E, t);
                } catch (t) {
                  return new o(e, t);
                }
              return e;
            });
          }
        }
        t.ContractTransactionReceipt = l;
        class u extends s.TransactionResponse {
          #E;
          constructor(e, t, n) {
            super(n, t), (this.#E = e);
          }
          async wait(e, t) {
            let n = await super.wait(e, t);
            return null == n ? null : new l(this.#E, this.provider, n);
          }
        }
        t.ContractTransactionResponse = u;
        class c extends i.EventPayload {
          log;
          constructor(e, t, n, s) {
            super(e, t, n), (0, i.defineProperties)(this, { log: s });
          }
          async getBlock() {
            return await this.log.getBlock();
          }
          async getTransaction() {
            return await this.log.getTransaction();
          }
          async getTransactionReceipt() {
            return await this.log.getTransactionReceipt();
          }
        }
        t.ContractUnknownEventPayload = c;
        class d extends c {
          constructor(e, t, n, s, o) {
            super(e, t, n, new a(o, e.interface, s));
            let l = e.interface.decodeEventLog(
              s,
              this.log.data,
              this.log.topics
            );
            (0, i.defineProperties)(this, { args: l, fragment: s });
          }
          get eventName() {
            return this.fragment.name;
          }
          get eventSignature() {
            return this.fragment.format();
          }
        }
        t.ContractEventPayload = d;
      },
      24083: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.randomBytes = t.pbkdf2Sync = t.createHmac = t.createHash = void 0);
        let s = n(60798),
          i = n(24112),
          a = n(67366),
          o = n(40937),
          l = n(42120),
          u = (function () {
            if ("undefined" != typeof self) return self;
            if ("undefined" != typeof window) return window;
            if (void 0 !== n.g) return n.g;
            throw Error("unable to locate global object");
          })(),
          c = u.crypto || u.msCrypto;
        (t.createHash = function (e) {
          switch (e) {
            case "sha256":
              return a.sha256.create();
            case "sha512":
              return o.sha512.create();
          }
          (0, l.assertArgument)(
            !1,
            "invalid hashing algorithm name",
            "algorithm",
            e
          );
        }),
          (t.createHmac = function (e, t) {
            let n = { sha256: a.sha256, sha512: o.sha512 }[e];
            return (
              (0, l.assertArgument)(
                null != n,
                "invalid hmac algorithm",
                "algorithm",
                e
              ),
              s.hmac.create(n, t)
            );
          }),
          (t.pbkdf2Sync = function (e, t, n, s, u) {
            let c = { sha256: a.sha256, sha512: o.sha512 }[u];
            return (
              (0, l.assertArgument)(
                null != c,
                "invalid pbkdf2 algorithm",
                "algorithm",
                u
              ),
              (0, i.pbkdf2)(c, e, t, { c: n, dkLen: s })
            );
          }),
          (t.randomBytes = function (e) {
            (0, l.assert)(
              null != c,
              "platform does not support secure random numbers",
              "UNSUPPORTED_OPERATION",
              { operation: "randomBytes" }
            ),
              (0, l.assertArgument)(
                Number.isInteger(e) && e > 0 && e <= 1024,
                "invalid length",
                "length",
                e
              );
            let t = new Uint8Array(e);
            return c.getRandomValues(t), t;
          });
      },
      76117: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.computeHmac = void 0);
        let s = n(24083),
          i = n(42120),
          a = !1,
          o = function (e, t, n) {
            return (0, s.createHmac)(e, t).update(n).digest();
          },
          l = o;
        function u(e, t, n) {
          let s = (0, i.getBytes)(t, "key"),
            a = (0, i.getBytes)(n, "data");
          return (0, i.hexlify)(l(e, s, a));
        }
        (t.computeHmac = u),
          (u._ = o),
          (u.lock = function () {
            a = !0;
          }),
          (u.register = function (e) {
            if (a) throw Error("computeHmac is locked");
            l = e;
          }),
          Object.freeze(u);
      },
      96965: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.lock =
            t.Signature =
            t.SigningKey =
            t.scryptSync =
            t.scrypt =
            t.pbkdf2 =
            t.sha512 =
            t.sha256 =
            t.ripemd160 =
            t.keccak256 =
            t.randomBytes =
            t.computeHmac =
              void 0);
        let s = n(76117);
        Object.defineProperty(t, "computeHmac", {
          enumerable: !0,
          get: function () {
            return s.computeHmac;
          },
        });
        let i = n(33037);
        Object.defineProperty(t, "keccak256", {
          enumerable: !0,
          get: function () {
            return i.keccak256;
          },
        });
        let a = n(95507);
        Object.defineProperty(t, "ripemd160", {
          enumerable: !0,
          get: function () {
            return a.ripemd160;
          },
        });
        let o = n(64989);
        Object.defineProperty(t, "pbkdf2", {
          enumerable: !0,
          get: function () {
            return o.pbkdf2;
          },
        });
        let l = n(62385);
        Object.defineProperty(t, "randomBytes", {
          enumerable: !0,
          get: function () {
            return l.randomBytes;
          },
        });
        let u = n(16168);
        Object.defineProperty(t, "scrypt", {
          enumerable: !0,
          get: function () {
            return u.scrypt;
          },
        }),
          Object.defineProperty(t, "scryptSync", {
            enumerable: !0,
            get: function () {
              return u.scryptSync;
            },
          });
        let c = n(69233);
        Object.defineProperty(t, "sha256", {
          enumerable: !0,
          get: function () {
            return c.sha256;
          },
        }),
          Object.defineProperty(t, "sha512", {
            enumerable: !0,
            get: function () {
              return c.sha512;
            },
          });
        var d = n(33106);
        Object.defineProperty(t, "SigningKey", {
          enumerable: !0,
          get: function () {
            return d.SigningKey;
          },
        });
        var h = n(63295);
        Object.defineProperty(t, "Signature", {
          enumerable: !0,
          get: function () {
            return h.Signature;
          },
        }),
          (t.lock = function () {
            s.computeHmac.lock(),
              i.keccak256.lock(),
              o.pbkdf2.lock(),
              l.randomBytes.lock(),
              a.ripemd160.lock(),
              u.scrypt.lock(),
              u.scryptSync.lock(),
              c.sha256.lock(),
              c.sha512.lock(),
              l.randomBytes.lock();
          });
      },
      33037: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.keccak256 = void 0);
        let s = n(7910),
          i = n(42120),
          a = !1,
          o = function (e) {
            return (0, s.keccak_256)(e);
          },
          l = o;
        function u(e) {
          let t = (0, i.getBytes)(e, "data");
          return (0, i.hexlify)(l(t));
        }
        (t.keccak256 = u),
          (u._ = o),
          (u.lock = function () {
            a = !0;
          }),
          (u.register = function (e) {
            if (a) throw TypeError("keccak256 is locked");
            l = e;
          }),
          Object.freeze(u);
      },
      64989: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.pbkdf2 = void 0);
        let s = n(24083),
          i = n(42120),
          a = !1,
          o = function (e, t, n, i, a) {
            return (0, s.pbkdf2Sync)(e, t, n, i, a);
          },
          l = o;
        function u(e, t, n, s, a) {
          let o = (0, i.getBytes)(e, "password"),
            u = (0, i.getBytes)(t, "salt");
          return (0, i.hexlify)(l(o, u, n, s, a));
        }
        (t.pbkdf2 = u),
          (u._ = o),
          (u.lock = function () {
            a = !0;
          }),
          (u.register = function (e) {
            if (a) throw Error("pbkdf2 is locked");
            l = e;
          }),
          Object.freeze(u);
      },
      62385: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.randomBytes = void 0);
        let s = n(24083),
          i = !1,
          a = function (e) {
            return new Uint8Array((0, s.randomBytes)(e));
          },
          o = a;
        function l(e) {
          return o(e);
        }
        (t.randomBytes = l),
          (l._ = a),
          (l.lock = function () {
            i = !0;
          }),
          (l.register = function (e) {
            if (i) throw Error("randomBytes is locked");
            o = e;
          }),
          Object.freeze(l);
      },
      95507: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ripemd160 = void 0);
        let s = n(67746),
          i = n(42120),
          a = !1,
          o = function (e) {
            return (0, s.ripemd160)(e);
          },
          l = o;
        function u(e) {
          let t = (0, i.getBytes)(e, "data");
          return (0, i.hexlify)(l(t));
        }
        (t.ripemd160 = u),
          (u._ = o),
          (u.lock = function () {
            a = !0;
          }),
          (u.register = function (e) {
            if (a) throw TypeError("ripemd160 is locked");
            l = e;
          }),
          Object.freeze(u);
      },
      16168: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.scryptSync = t.scrypt = void 0);
        let s = n(49468),
          i = n(42120),
          a = !1,
          o = !1,
          l = async function (e, t, n, i, a, o, l) {
            return await (0, s.scryptAsync)(e, t, {
              N: n,
              r: i,
              p: a,
              dkLen: o,
              onProgress: l,
            });
          },
          u = function (e, t, n, i, a, o) {
            return (0, s.scrypt)(e, t, { N: n, r: i, p: a, dkLen: o });
          },
          c = l,
          d = u;
        async function h(e, t, n, s, a, o, l) {
          let u = (0, i.getBytes)(e, "passwd"),
            d = (0, i.getBytes)(t, "salt");
          return (0, i.hexlify)(await c(u, d, n, s, a, o, l));
        }
        function p(e, t, n, s, a, o) {
          let l = (0, i.getBytes)(e, "passwd"),
            u = (0, i.getBytes)(t, "salt");
          return (0, i.hexlify)(d(l, u, n, s, a, o));
        }
        (t.scrypt = h),
          (h._ = l),
          (h.lock = function () {
            o = !0;
          }),
          (h.register = function (e) {
            if (o) throw Error("scrypt is locked");
            c = e;
          }),
          Object.freeze(h),
          (t.scryptSync = p),
          (p._ = u),
          (p.lock = function () {
            a = !0;
          }),
          (p.register = function (e) {
            if (a) throw Error("scryptSync is locked");
            d = e;
          }),
          Object.freeze(p);
      },
      69233: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.sha512 = t.sha256 = void 0);
        let s = n(24083),
          i = n(42120),
          a = function (e) {
            return (0, s.createHash)("sha256").update(e).digest();
          },
          o = function (e) {
            return (0, s.createHash)("sha512").update(e).digest();
          },
          l = a,
          u = o,
          c = !1,
          d = !1;
        function h(e) {
          let t = (0, i.getBytes)(e, "data");
          return (0, i.hexlify)(l(t));
        }
        function p(e) {
          let t = (0, i.getBytes)(e, "data");
          return (0, i.hexlify)(u(t));
        }
        (t.sha256 = h),
          (h._ = a),
          (h.lock = function () {
            c = !0;
          }),
          (h.register = function (e) {
            if (c) throw Error("sha256 is locked");
            l = e;
          }),
          Object.freeze(h),
          (t.sha512 = p),
          (p._ = o),
          (p.lock = function () {
            d = !0;
          }),
          (p.register = function (e) {
            if (d) throw Error("sha512 is locked");
            u = e;
          }),
          Object.freeze(h);
      },
      63295: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Signature = void 0);
        let s = n(61428),
          i = n(42120),
          a = BigInt(0),
          o = BigInt(1),
          l = BigInt(2),
          u = BigInt(27),
          c = BigInt(28),
          d = BigInt(35),
          h = {};
        function p(e) {
          return (0, i.zeroPadValue)((0, i.toBeArray)(e), 32);
        }
        class f {
          #P;
          #k;
          #T;
          #x;
          get r() {
            return this.#P;
          }
          set r(e) {
            (0, i.assertArgument)(
              32 === (0, i.dataLength)(e),
              "invalid r",
              "value",
              e
            ),
              (this.#P = (0, i.hexlify)(e));
          }
          get s() {
            return this.#k;
          }
          set s(e) {
            (0, i.assertArgument)(
              32 === (0, i.dataLength)(e),
              "invalid s",
              "value",
              e
            );
            let t = (0, i.hexlify)(e);
            (0, i.assertArgument)(
              8 > parseInt(t.substring(0, 3)),
              "non-canonical s",
              "value",
              t
            ),
              (this.#k = t);
          }
          get v() {
            return this.#T;
          }
          set v(e) {
            let t = (0, i.getNumber)(e, "value");
            (0, i.assertArgument)(27 === t || 28 === t, "invalid v", "v", e),
              (this.#T = t);
          }
          get networkV() {
            return this.#x;
          }
          get legacyChainId() {
            let e = this.networkV;
            return null == e ? null : f.getChainId(e);
          }
          get yParity() {
            return 27 === this.v ? 0 : 1;
          }
          get yParityAndS() {
            let e = (0, i.getBytes)(this.s);
            return this.yParity && (e[0] |= 128), (0, i.hexlify)(e);
          }
          get compactSerialized() {
            return (0, i.concat)([this.r, this.yParityAndS]);
          }
          get serialized() {
            return (0, i.concat)([
              this.r,
              this.s,
              this.yParity ? "0x1c" : "0x1b",
            ]);
          }
          constructor(e, t, n, s) {
            (0, i.assertPrivate)(e, h, "Signature"),
              (this.#P = t),
              (this.#k = n),
              (this.#T = s),
              (this.#x = null);
          }
          [Symbol.for("nodejs.util.inspect.custom")]() {
            return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
          }
          clone() {
            let e = new f(h, this.r, this.s, this.v);
            return this.networkV && (e.#x = this.networkV), e;
          }
          toJSON() {
            let e = this.networkV;
            return {
              _type: "signature",
              networkV: null != e ? e.toString() : null,
              r: this.r,
              s: this.s,
              v: this.v,
            };
          }
          static getChainId(e) {
            let t = (0, i.getBigInt)(e, "v");
            return t == u || t == c
              ? a
              : ((0, i.assertArgument)(t >= d, "invalid EIP-155 v", "v", e),
                (t - d) / l);
          }
          static getChainIdV(e, t) {
            return (0, i.getBigInt)(e) * l + BigInt(35 + t - 27);
          }
          static getNormalizedV(e) {
            let t = (0, i.getBigInt)(e);
            return t === a || t === u
              ? 27
              : t === o || t === c
              ? 28
              : ((0, i.assertArgument)(t >= d, "invalid v", "v", e),
                t & o ? 27 : 28);
          }
          static from(e) {
            function t(t, n) {
              (0, i.assertArgument)(t, n, "signature", e);
            }
            if (null == e) return new f(h, s.ZeroHash, s.ZeroHash, 27);
            if ("string" == typeof e) {
              let n = (0, i.getBytes)(e, "signature");
              if (64 === n.length) {
                let e = (0, i.hexlify)(n.slice(0, 32)),
                  t = n.slice(32, 64),
                  s = 128 & t[0] ? 28 : 27;
                return (t[0] &= 127), new f(h, e, (0, i.hexlify)(t), s);
              }
              if (65 === n.length) {
                let e = (0, i.hexlify)(n.slice(0, 32)),
                  s = n.slice(32, 64);
                t((128 & s[0]) == 0, "non-canonical s");
                let a = f.getNormalizedV(n[64]);
                return new f(h, e, (0, i.hexlify)(s), a);
              }
              t(!1, "invalid raw signature length");
            }
            if (e instanceof f) return e.clone();
            let n = e.r;
            t(null != n, "missing r");
            let a = p(n),
              o = (function (e, n) {
                if (null != e) return p(e);
                if (null != n) {
                  t((0, i.isHexString)(n, 32), "invalid yParityAndS");
                  let e = (0, i.getBytes)(n);
                  return (e[0] &= 127), (0, i.hexlify)(e);
                }
                t(!1, "missing s");
              })(e.s, e.yParityAndS);
            t((128 & (0, i.getBytes)(o)[0]) == 0, "non-canonical s");
            let { networkV: l, v: u } = (function (e, n, s) {
                if (null != e) {
                  let t = (0, i.getBigInt)(e);
                  return {
                    networkV: t >= d ? t : void 0,
                    v: f.getNormalizedV(t),
                  };
                }
                if (null != n)
                  return (
                    t((0, i.isHexString)(n, 32), "invalid yParityAndS"),
                    { v: 128 & (0, i.getBytes)(n)[0] ? 28 : 27 }
                  );
                if (null != s) {
                  switch ((0, i.getNumber)(s, "sig.yParity")) {
                    case 0:
                      return { v: 27 };
                    case 1:
                      return { v: 28 };
                  }
                  t(!1, "invalid yParity");
                }
                t(!1, "missing v");
              })(e.v, e.yParityAndS, e.yParity),
              c = new f(h, a, o, u);
            return (
              l && (c.#x = l),
              t(
                null == e.yParity ||
                  (0, i.getNumber)(e.yParity, "sig.yParity") === c.yParity,
                "yParity mismatch"
              ),
              t(
                null == e.yParityAndS || e.yParityAndS === c.yParityAndS,
                "yParityAndS mismatch"
              ),
              c
            );
          }
        }
        t.Signature = f;
      },
      33106: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SigningKey = void 0);
        let s = n(82958),
          i = n(42120),
          a = n(63295);
        class o {
          #O;
          constructor(e) {
            (0, i.assertArgument)(
              32 === (0, i.dataLength)(e),
              "invalid private key",
              "privateKey",
              "[REDACTED]"
            ),
              (this.#O = (0, i.hexlify)(e));
          }
          get privateKey() {
            return this.#O;
          }
          get publicKey() {
            return o.computePublicKey(this.#O);
          }
          get compressedPublicKey() {
            return o.computePublicKey(this.#O, !0);
          }
          sign(e) {
            (0, i.assertArgument)(
              32 === (0, i.dataLength)(e),
              "invalid digest length",
              "digest",
              e
            );
            let t = s.secp256k1.sign(
              (0, i.getBytesCopy)(e),
              (0, i.getBytesCopy)(this.#O),
              { lowS: !0 }
            );
            return a.Signature.from({
              r: (0, i.toBeHex)(t.r, 32),
              s: (0, i.toBeHex)(t.s, 32),
              v: t.recovery ? 28 : 27,
            });
          }
          computeSharedSecret(e) {
            let t = o.computePublicKey(e);
            return (0, i.hexlify)(
              s.secp256k1.getSharedSecret(
                (0, i.getBytesCopy)(this.#O),
                (0, i.getBytes)(t),
                !1
              )
            );
          }
          static computePublicKey(e, t) {
            let n = (0, i.getBytes)(e, "key");
            if (32 === n.length) {
              let e = s.secp256k1.getPublicKey(n, !!t);
              return (0, i.hexlify)(e);
            }
            if (64 === n.length) {
              let e = new Uint8Array(65);
              (e[0] = 4), e.set(n, 1), (n = e);
            }
            let a = s.secp256k1.ProjectivePoint.fromHex(n);
            return (0, i.hexlify)(a.toRawBytes(t));
          }
          static recoverPublicKey(e, t) {
            (0, i.assertArgument)(
              32 === (0, i.dataLength)(e),
              "invalid digest length",
              "digest",
              e
            );
            let n = a.Signature.from(t),
              o = s.secp256k1.Signature.fromCompact(
                (0, i.getBytesCopy)((0, i.concat)([n.r, n.s]))
              ),
              l = (o = o.addRecoveryBit(n.yParity)).recoverPublicKey(
                (0, i.getBytesCopy)(e)
              );
            return (
              (0, i.assertArgument)(
                null != l,
                "invalid signautre for digest",
                "signature",
                t
              ),
              "0x" + l.toHex(!1)
            );
          }
          static addPoints(e, t, n) {
            let i = s.secp256k1.ProjectivePoint.fromHex(
                o.computePublicKey(e).substring(2)
              ),
              a = s.secp256k1.ProjectivePoint.fromHex(
                o.computePublicKey(t).substring(2)
              );
            return "0x" + i.add(a).toHex(!!n);
          }
        }
        t.SigningKey = o;
      },
      81097: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ripemd160 =
            t.keccak256 =
            t.randomBytes =
            t.computeHmac =
            t.UndecodedEventLog =
            t.EventLog =
            t.ContractUnknownEventPayload =
            t.ContractTransactionResponse =
            t.ContractTransactionReceipt =
            t.ContractEventPayload =
            t.ContractFactory =
            t.Contract =
            t.BaseContract =
            t.MessagePrefix =
            t.EtherSymbol =
            t.ZeroHash =
            t.N =
            t.MaxInt256 =
            t.MinInt256 =
            t.MaxUint256 =
            t.WeiPerEther =
            t.ZeroAddress =
            t.resolveAddress =
            t.isAddress =
            t.isAddressable =
            t.getCreate2Address =
            t.getCreateAddress =
            t.getIcapAddress =
            t.getAddress =
            t.Typed =
            t.TransactionDescription =
            t.Result =
            t.LogDescription =
            t.Interface =
            t.Indexed =
            t.ErrorDescription =
            t.checkResultErrors =
            t.StructFragment =
            t.ParamType =
            t.NamedFragment =
            t.FunctionFragment =
            t.FallbackFragment =
            t.Fragment =
            t.EventFragment =
            t.ErrorFragment =
            t.ConstructorFragment =
            t.AbiCoder =
            t.encodeBytes32String =
            t.decodeBytes32String =
            t.version =
              void 0),
          (t.EnsPlugin =
            t.Network =
            t.EnsResolver =
            t.WebSocketProvider =
            t.SocketProvider =
            t.IpcSocketProvider =
            t.QuickNodeProvider =
            t.PocketProvider =
            t.InfuraWebSocketProvider =
            t.InfuraProvider =
            t.EtherscanProvider =
            t.CloudflareProvider =
            t.ChainstackProvider =
            t.AnkrProvider =
            t.AlchemyProvider =
            t.BrowserProvider =
            t.JsonRpcSigner =
            t.JsonRpcProvider =
            t.JsonRpcApiProvider =
            t.FallbackProvider =
            t.AbstractProvider =
            t.VoidSigner =
            t.NonceManager =
            t.AbstractSigner =
            t.TransactionResponse =
            t.TransactionReceipt =
            t.Log =
            t.FeeData =
            t.Block =
            t.getDefaultProvider =
            t.verifyTypedData =
            t.TypedDataEncoder =
            t.solidityPackedSha256 =
            t.solidityPackedKeccak256 =
            t.solidityPacked =
            t.verifyMessage =
            t.hashMessage =
            t.dnsEncode =
            t.namehash =
            t.isValidName =
            t.ensNormalize =
            t.id =
            t.SigningKey =
            t.Signature =
            t.lock =
            t.scryptSync =
            t.scrypt =
            t.pbkdf2 =
            t.sha512 =
            t.sha256 =
              void 0),
          (t.getUint =
            t.getNumber =
            t.getBigInt =
            t.FixedNumber =
            t.FetchCancelSignal =
            t.FetchResponse =
            t.FetchRequest =
            t.EventPayload =
            t.isError =
            t.isCallException =
            t.makeError =
            t.assertPrivate =
            t.assertNormalize =
            t.assertArgumentCount =
            t.assertArgument =
            t.assert =
            t.resolveProperties =
            t.defineProperties =
            t.zeroPadValue =
            t.zeroPadBytes =
            t.stripZerosLeft =
            t.isBytesLike =
            t.isHexString =
            t.hexlify =
            t.getBytesCopy =
            t.getBytes =
            t.dataSlice =
            t.dataLength =
            t.concat =
            t.encodeBase64 =
            t.decodeBase64 =
            t.encodeBase58 =
            t.decodeBase58 =
            t.Transaction =
            t.recoverAddress =
            t.computeAddress =
            t.accessListify =
            t.showThrottleMessage =
            t.copyRequest =
            t.UnmanagedSubscriber =
            t.SocketSubscriber =
            t.SocketPendingSubscriber =
            t.SocketEventSubscriber =
            t.SocketBlockSubscriber =
            t.MulticoinProviderPlugin =
            t.NetworkPlugin =
            t.GasCostPlugin =
            t.FetchUrlFeeDataNetworkPlugin =
            t.FeeDataNetworkPlugin =
            t.EtherscanPlugin =
              void 0),
          (t.wordlists =
            t.WordlistOwlA =
            t.WordlistOwl =
            t.LangEn =
            t.Wordlist =
            t.encryptKeystoreJsonSync =
            t.encryptKeystoreJson =
            t.decryptKeystoreJson =
            t.decryptKeystoreJsonSync =
            t.decryptCrowdsaleJson =
            t.isKeystoreJson =
            t.isCrowdsaleJson =
            t.getIndexedAccountPath =
            t.getAccountPath =
            t.defaultPath =
            t.Wallet =
            t.HDNodeVoidWallet =
            t.HDNodeWallet =
            t.BaseWallet =
            t.Mnemonic =
            t.uuidV4 =
            t.encodeRlp =
            t.decodeRlp =
            t.Utf8ErrorFuncs =
            t.toUtf8String =
            t.toUtf8CodePoints =
            t.toUtf8Bytes =
            t.parseUnits =
            t.formatUnits =
            t.parseEther =
            t.formatEther =
            t.mask =
            t.toTwos =
            t.fromTwos =
            t.toQuantity =
            t.toNumber =
            t.toBeHex =
            t.toBigInt =
            t.toBeArray =
              void 0);
        var s = n(79406);
        Object.defineProperty(t, "version", {
          enumerable: !0,
          get: function () {
            return s.version;
          },
        });
        var i = n(93707);
        Object.defineProperty(t, "decodeBytes32String", {
          enumerable: !0,
          get: function () {
            return i.decodeBytes32String;
          },
        }),
          Object.defineProperty(t, "encodeBytes32String", {
            enumerable: !0,
            get: function () {
              return i.encodeBytes32String;
            },
          }),
          Object.defineProperty(t, "AbiCoder", {
            enumerable: !0,
            get: function () {
              return i.AbiCoder;
            },
          }),
          Object.defineProperty(t, "ConstructorFragment", {
            enumerable: !0,
            get: function () {
              return i.ConstructorFragment;
            },
          }),
          Object.defineProperty(t, "ErrorFragment", {
            enumerable: !0,
            get: function () {
              return i.ErrorFragment;
            },
          }),
          Object.defineProperty(t, "EventFragment", {
            enumerable: !0,
            get: function () {
              return i.EventFragment;
            },
          }),
          Object.defineProperty(t, "Fragment", {
            enumerable: !0,
            get: function () {
              return i.Fragment;
            },
          }),
          Object.defineProperty(t, "FallbackFragment", {
            enumerable: !0,
            get: function () {
              return i.FallbackFragment;
            },
          }),
          Object.defineProperty(t, "FunctionFragment", {
            enumerable: !0,
            get: function () {
              return i.FunctionFragment;
            },
          }),
          Object.defineProperty(t, "NamedFragment", {
            enumerable: !0,
            get: function () {
              return i.NamedFragment;
            },
          }),
          Object.defineProperty(t, "ParamType", {
            enumerable: !0,
            get: function () {
              return i.ParamType;
            },
          }),
          Object.defineProperty(t, "StructFragment", {
            enumerable: !0,
            get: function () {
              return i.StructFragment;
            },
          }),
          Object.defineProperty(t, "checkResultErrors", {
            enumerable: !0,
            get: function () {
              return i.checkResultErrors;
            },
          }),
          Object.defineProperty(t, "ErrorDescription", {
            enumerable: !0,
            get: function () {
              return i.ErrorDescription;
            },
          }),
          Object.defineProperty(t, "Indexed", {
            enumerable: !0,
            get: function () {
              return i.Indexed;
            },
          }),
          Object.defineProperty(t, "Interface", {
            enumerable: !0,
            get: function () {
              return i.Interface;
            },
          }),
          Object.defineProperty(t, "LogDescription", {
            enumerable: !0,
            get: function () {
              return i.LogDescription;
            },
          }),
          Object.defineProperty(t, "Result", {
            enumerable: !0,
            get: function () {
              return i.Result;
            },
          }),
          Object.defineProperty(t, "TransactionDescription", {
            enumerable: !0,
            get: function () {
              return i.TransactionDescription;
            },
          }),
          Object.defineProperty(t, "Typed", {
            enumerable: !0,
            get: function () {
              return i.Typed;
            },
          });
        var a = n(45475);
        Object.defineProperty(t, "getAddress", {
          enumerable: !0,
          get: function () {
            return a.getAddress;
          },
        }),
          Object.defineProperty(t, "getIcapAddress", {
            enumerable: !0,
            get: function () {
              return a.getIcapAddress;
            },
          }),
          Object.defineProperty(t, "getCreateAddress", {
            enumerable: !0,
            get: function () {
              return a.getCreateAddress;
            },
          }),
          Object.defineProperty(t, "getCreate2Address", {
            enumerable: !0,
            get: function () {
              return a.getCreate2Address;
            },
          }),
          Object.defineProperty(t, "isAddressable", {
            enumerable: !0,
            get: function () {
              return a.isAddressable;
            },
          }),
          Object.defineProperty(t, "isAddress", {
            enumerable: !0,
            get: function () {
              return a.isAddress;
            },
          }),
          Object.defineProperty(t, "resolveAddress", {
            enumerable: !0,
            get: function () {
              return a.resolveAddress;
            },
          });
        var o = n(61428);
        Object.defineProperty(t, "ZeroAddress", {
          enumerable: !0,
          get: function () {
            return o.ZeroAddress;
          },
        }),
          Object.defineProperty(t, "WeiPerEther", {
            enumerable: !0,
            get: function () {
              return o.WeiPerEther;
            },
          }),
          Object.defineProperty(t, "MaxUint256", {
            enumerable: !0,
            get: function () {
              return o.MaxUint256;
            },
          }),
          Object.defineProperty(t, "MinInt256", {
            enumerable: !0,
            get: function () {
              return o.MinInt256;
            },
          }),
          Object.defineProperty(t, "MaxInt256", {
            enumerable: !0,
            get: function () {
              return o.MaxInt256;
            },
          }),
          Object.defineProperty(t, "N", {
            enumerable: !0,
            get: function () {
              return o.N;
            },
          }),
          Object.defineProperty(t, "ZeroHash", {
            enumerable: !0,
            get: function () {
              return o.ZeroHash;
            },
          }),
          Object.defineProperty(t, "EtherSymbol", {
            enumerable: !0,
            get: function () {
              return o.EtherSymbol;
            },
          }),
          Object.defineProperty(t, "MessagePrefix", {
            enumerable: !0,
            get: function () {
              return o.MessagePrefix;
            },
          });
        var l = n(37252);
        Object.defineProperty(t, "BaseContract", {
          enumerable: !0,
          get: function () {
            return l.BaseContract;
          },
        }),
          Object.defineProperty(t, "Contract", {
            enumerable: !0,
            get: function () {
              return l.Contract;
            },
          }),
          Object.defineProperty(t, "ContractFactory", {
            enumerable: !0,
            get: function () {
              return l.ContractFactory;
            },
          }),
          Object.defineProperty(t, "ContractEventPayload", {
            enumerable: !0,
            get: function () {
              return l.ContractEventPayload;
            },
          }),
          Object.defineProperty(t, "ContractTransactionReceipt", {
            enumerable: !0,
            get: function () {
              return l.ContractTransactionReceipt;
            },
          }),
          Object.defineProperty(t, "ContractTransactionResponse", {
            enumerable: !0,
            get: function () {
              return l.ContractTransactionResponse;
            },
          }),
          Object.defineProperty(t, "ContractUnknownEventPayload", {
            enumerable: !0,
            get: function () {
              return l.ContractUnknownEventPayload;
            },
          }),
          Object.defineProperty(t, "EventLog", {
            enumerable: !0,
            get: function () {
              return l.EventLog;
            },
          }),
          Object.defineProperty(t, "UndecodedEventLog", {
            enumerable: !0,
            get: function () {
              return l.UndecodedEventLog;
            },
          });
        var u = n(96965);
        Object.defineProperty(t, "computeHmac", {
          enumerable: !0,
          get: function () {
            return u.computeHmac;
          },
        }),
          Object.defineProperty(t, "randomBytes", {
            enumerable: !0,
            get: function () {
              return u.randomBytes;
            },
          }),
          Object.defineProperty(t, "keccak256", {
            enumerable: !0,
            get: function () {
              return u.keccak256;
            },
          }),
          Object.defineProperty(t, "ripemd160", {
            enumerable: !0,
            get: function () {
              return u.ripemd160;
            },
          }),
          Object.defineProperty(t, "sha256", {
            enumerable: !0,
            get: function () {
              return u.sha256;
            },
          }),
          Object.defineProperty(t, "sha512", {
            enumerable: !0,
            get: function () {
              return u.sha512;
            },
          }),
          Object.defineProperty(t, "pbkdf2", {
            enumerable: !0,
            get: function () {
              return u.pbkdf2;
            },
          }),
          Object.defineProperty(t, "scrypt", {
            enumerable: !0,
            get: function () {
              return u.scrypt;
            },
          }),
          Object.defineProperty(t, "scryptSync", {
            enumerable: !0,
            get: function () {
              return u.scryptSync;
            },
          }),
          Object.defineProperty(t, "lock", {
            enumerable: !0,
            get: function () {
              return u.lock;
            },
          }),
          Object.defineProperty(t, "Signature", {
            enumerable: !0,
            get: function () {
              return u.Signature;
            },
          }),
          Object.defineProperty(t, "SigningKey", {
            enumerable: !0,
            get: function () {
              return u.SigningKey;
            },
          });
        var c = n(62475);
        Object.defineProperty(t, "id", {
          enumerable: !0,
          get: function () {
            return c.id;
          },
        }),
          Object.defineProperty(t, "ensNormalize", {
            enumerable: !0,
            get: function () {
              return c.ensNormalize;
            },
          }),
          Object.defineProperty(t, "isValidName", {
            enumerable: !0,
            get: function () {
              return c.isValidName;
            },
          }),
          Object.defineProperty(t, "namehash", {
            enumerable: !0,
            get: function () {
              return c.namehash;
            },
          }),
          Object.defineProperty(t, "dnsEncode", {
            enumerable: !0,
            get: function () {
              return c.dnsEncode;
            },
          }),
          Object.defineProperty(t, "hashMessage", {
            enumerable: !0,
            get: function () {
              return c.hashMessage;
            },
          }),
          Object.defineProperty(t, "verifyMessage", {
            enumerable: !0,
            get: function () {
              return c.verifyMessage;
            },
          }),
          Object.defineProperty(t, "solidityPacked", {
            enumerable: !0,
            get: function () {
              return c.solidityPacked;
            },
          }),
          Object.defineProperty(t, "solidityPackedKeccak256", {
            enumerable: !0,
            get: function () {
              return c.solidityPackedKeccak256;
            },
          }),
          Object.defineProperty(t, "solidityPackedSha256", {
            enumerable: !0,
            get: function () {
              return c.solidityPackedSha256;
            },
          }),
          Object.defineProperty(t, "TypedDataEncoder", {
            enumerable: !0,
            get: function () {
              return c.TypedDataEncoder;
            },
          }),
          Object.defineProperty(t, "verifyTypedData", {
            enumerable: !0,
            get: function () {
              return c.verifyTypedData;
            },
          });
        var d = n(4878);
        Object.defineProperty(t, "getDefaultProvider", {
          enumerable: !0,
          get: function () {
            return d.getDefaultProvider;
          },
        }),
          Object.defineProperty(t, "Block", {
            enumerable: !0,
            get: function () {
              return d.Block;
            },
          }),
          Object.defineProperty(t, "FeeData", {
            enumerable: !0,
            get: function () {
              return d.FeeData;
            },
          }),
          Object.defineProperty(t, "Log", {
            enumerable: !0,
            get: function () {
              return d.Log;
            },
          }),
          Object.defineProperty(t, "TransactionReceipt", {
            enumerable: !0,
            get: function () {
              return d.TransactionReceipt;
            },
          }),
          Object.defineProperty(t, "TransactionResponse", {
            enumerable: !0,
            get: function () {
              return d.TransactionResponse;
            },
          }),
          Object.defineProperty(t, "AbstractSigner", {
            enumerable: !0,
            get: function () {
              return d.AbstractSigner;
            },
          }),
          Object.defineProperty(t, "NonceManager", {
            enumerable: !0,
            get: function () {
              return d.NonceManager;
            },
          }),
          Object.defineProperty(t, "VoidSigner", {
            enumerable: !0,
            get: function () {
              return d.VoidSigner;
            },
          }),
          Object.defineProperty(t, "AbstractProvider", {
            enumerable: !0,
            get: function () {
              return d.AbstractProvider;
            },
          }),
          Object.defineProperty(t, "FallbackProvider", {
            enumerable: !0,
            get: function () {
              return d.FallbackProvider;
            },
          }),
          Object.defineProperty(t, "JsonRpcApiProvider", {
            enumerable: !0,
            get: function () {
              return d.JsonRpcApiProvider;
            },
          }),
          Object.defineProperty(t, "JsonRpcProvider", {
            enumerable: !0,
            get: function () {
              return d.JsonRpcProvider;
            },
          }),
          Object.defineProperty(t, "JsonRpcSigner", {
            enumerable: !0,
            get: function () {
              return d.JsonRpcSigner;
            },
          }),
          Object.defineProperty(t, "BrowserProvider", {
            enumerable: !0,
            get: function () {
              return d.BrowserProvider;
            },
          }),
          Object.defineProperty(t, "AlchemyProvider", {
            enumerable: !0,
            get: function () {
              return d.AlchemyProvider;
            },
          }),
          Object.defineProperty(t, "AnkrProvider", {
            enumerable: !0,
            get: function () {
              return d.AnkrProvider;
            },
          }),
          Object.defineProperty(t, "ChainstackProvider", {
            enumerable: !0,
            get: function () {
              return d.ChainstackProvider;
            },
          }),
          Object.defineProperty(t, "CloudflareProvider", {
            enumerable: !0,
            get: function () {
              return d.CloudflareProvider;
            },
          }),
          Object.defineProperty(t, "EtherscanProvider", {
            enumerable: !0,
            get: function () {
              return d.EtherscanProvider;
            },
          }),
          Object.defineProperty(t, "InfuraProvider", {
            enumerable: !0,
            get: function () {
              return d.InfuraProvider;
            },
          }),
          Object.defineProperty(t, "InfuraWebSocketProvider", {
            enumerable: !0,
            get: function () {
              return d.InfuraWebSocketProvider;
            },
          }),
          Object.defineProperty(t, "PocketProvider", {
            enumerable: !0,
            get: function () {
              return d.PocketProvider;
            },
          }),
          Object.defineProperty(t, "QuickNodeProvider", {
            enumerable: !0,
            get: function () {
              return d.QuickNodeProvider;
            },
          }),
          Object.defineProperty(t, "IpcSocketProvider", {
            enumerable: !0,
            get: function () {
              return d.IpcSocketProvider;
            },
          }),
          Object.defineProperty(t, "SocketProvider", {
            enumerable: !0,
            get: function () {
              return d.SocketProvider;
            },
          }),
          Object.defineProperty(t, "WebSocketProvider", {
            enumerable: !0,
            get: function () {
              return d.WebSocketProvider;
            },
          }),
          Object.defineProperty(t, "EnsResolver", {
            enumerable: !0,
            get: function () {
              return d.EnsResolver;
            },
          }),
          Object.defineProperty(t, "Network", {
            enumerable: !0,
            get: function () {
              return d.Network;
            },
          }),
          Object.defineProperty(t, "EnsPlugin", {
            enumerable: !0,
            get: function () {
              return d.EnsPlugin;
            },
          }),
          Object.defineProperty(t, "EtherscanPlugin", {
            enumerable: !0,
            get: function () {
              return d.EtherscanPlugin;
            },
          }),
          Object.defineProperty(t, "FeeDataNetworkPlugin", {
            enumerable: !0,
            get: function () {
              return d.FeeDataNetworkPlugin;
            },
          }),
          Object.defineProperty(t, "FetchUrlFeeDataNetworkPlugin", {
            enumerable: !0,
            get: function () {
              return d.FetchUrlFeeDataNetworkPlugin;
            },
          }),
          Object.defineProperty(t, "GasCostPlugin", {
            enumerable: !0,
            get: function () {
              return d.GasCostPlugin;
            },
          }),
          Object.defineProperty(t, "NetworkPlugin", {
            enumerable: !0,
            get: function () {
              return d.NetworkPlugin;
            },
          }),
          Object.defineProperty(t, "MulticoinProviderPlugin", {
            enumerable: !0,
            get: function () {
              return d.MulticoinProviderPlugin;
            },
          }),
          Object.defineProperty(t, "SocketBlockSubscriber", {
            enumerable: !0,
            get: function () {
              return d.SocketBlockSubscriber;
            },
          }),
          Object.defineProperty(t, "SocketEventSubscriber", {
            enumerable: !0,
            get: function () {
              return d.SocketEventSubscriber;
            },
          }),
          Object.defineProperty(t, "SocketPendingSubscriber", {
            enumerable: !0,
            get: function () {
              return d.SocketPendingSubscriber;
            },
          }),
          Object.defineProperty(t, "SocketSubscriber", {
            enumerable: !0,
            get: function () {
              return d.SocketSubscriber;
            },
          }),
          Object.defineProperty(t, "UnmanagedSubscriber", {
            enumerable: !0,
            get: function () {
              return d.UnmanagedSubscriber;
            },
          }),
          Object.defineProperty(t, "copyRequest", {
            enumerable: !0,
            get: function () {
              return d.copyRequest;
            },
          }),
          Object.defineProperty(t, "showThrottleMessage", {
            enumerable: !0,
            get: function () {
              return d.showThrottleMessage;
            },
          });
        var h = n(2290);
        Object.defineProperty(t, "accessListify", {
          enumerable: !0,
          get: function () {
            return h.accessListify;
          },
        }),
          Object.defineProperty(t, "computeAddress", {
            enumerable: !0,
            get: function () {
              return h.computeAddress;
            },
          }),
          Object.defineProperty(t, "recoverAddress", {
            enumerable: !0,
            get: function () {
              return h.recoverAddress;
            },
          }),
          Object.defineProperty(t, "Transaction", {
            enumerable: !0,
            get: function () {
              return h.Transaction;
            },
          });
        var p = n(42120);
        Object.defineProperty(t, "decodeBase58", {
          enumerable: !0,
          get: function () {
            return p.decodeBase58;
          },
        }),
          Object.defineProperty(t, "encodeBase58", {
            enumerable: !0,
            get: function () {
              return p.encodeBase58;
            },
          }),
          Object.defineProperty(t, "decodeBase64", {
            enumerable: !0,
            get: function () {
              return p.decodeBase64;
            },
          }),
          Object.defineProperty(t, "encodeBase64", {
            enumerable: !0,
            get: function () {
              return p.encodeBase64;
            },
          }),
          Object.defineProperty(t, "concat", {
            enumerable: !0,
            get: function () {
              return p.concat;
            },
          }),
          Object.defineProperty(t, "dataLength", {
            enumerable: !0,
            get: function () {
              return p.dataLength;
            },
          }),
          Object.defineProperty(t, "dataSlice", {
            enumerable: !0,
            get: function () {
              return p.dataSlice;
            },
          }),
          Object.defineProperty(t, "getBytes", {
            enumerable: !0,
            get: function () {
              return p.getBytes;
            },
          }),
          Object.defineProperty(t, "getBytesCopy", {
            enumerable: !0,
            get: function () {
              return p.getBytesCopy;
            },
          }),
          Object.defineProperty(t, "hexlify", {
            enumerable: !0,
            get: function () {
              return p.hexlify;
            },
          }),
          Object.defineProperty(t, "isHexString", {
            enumerable: !0,
            get: function () {
              return p.isHexString;
            },
          }),
          Object.defineProperty(t, "isBytesLike", {
            enumerable: !0,
            get: function () {
              return p.isBytesLike;
            },
          }),
          Object.defineProperty(t, "stripZerosLeft", {
            enumerable: !0,
            get: function () {
              return p.stripZerosLeft;
            },
          }),
          Object.defineProperty(t, "zeroPadBytes", {
            enumerable: !0,
            get: function () {
              return p.zeroPadBytes;
            },
          }),
          Object.defineProperty(t, "zeroPadValue", {
            enumerable: !0,
            get: function () {
              return p.zeroPadValue;
            },
          }),
          Object.defineProperty(t, "defineProperties", {
            enumerable: !0,
            get: function () {
              return p.defineProperties;
            },
          }),
          Object.defineProperty(t, "resolveProperties", {
            enumerable: !0,
            get: function () {
              return p.resolveProperties;
            },
          }),
          Object.defineProperty(t, "assert", {
            enumerable: !0,
            get: function () {
              return p.assert;
            },
          }),
          Object.defineProperty(t, "assertArgument", {
            enumerable: !0,
            get: function () {
              return p.assertArgument;
            },
          }),
          Object.defineProperty(t, "assertArgumentCount", {
            enumerable: !0,
            get: function () {
              return p.assertArgumentCount;
            },
          }),
          Object.defineProperty(t, "assertNormalize", {
            enumerable: !0,
            get: function () {
              return p.assertNormalize;
            },
          }),
          Object.defineProperty(t, "assertPrivate", {
            enumerable: !0,
            get: function () {
              return p.assertPrivate;
            },
          }),
          Object.defineProperty(t, "makeError", {
            enumerable: !0,
            get: function () {
              return p.makeError;
            },
          }),
          Object.defineProperty(t, "isCallException", {
            enumerable: !0,
            get: function () {
              return p.isCallException;
            },
          }),
          Object.defineProperty(t, "isError", {
            enumerable: !0,
            get: function () {
              return p.isError;
            },
          }),
          Object.defineProperty(t, "EventPayload", {
            enumerable: !0,
            get: function () {
              return p.EventPayload;
            },
          }),
          Object.defineProperty(t, "FetchRequest", {
            enumerable: !0,
            get: function () {
              return p.FetchRequest;
            },
          }),
          Object.defineProperty(t, "FetchResponse", {
            enumerable: !0,
            get: function () {
              return p.FetchResponse;
            },
          }),
          Object.defineProperty(t, "FetchCancelSignal", {
            enumerable: !0,
            get: function () {
              return p.FetchCancelSignal;
            },
          }),
          Object.defineProperty(t, "FixedNumber", {
            enumerable: !0,
            get: function () {
              return p.FixedNumber;
            },
          }),
          Object.defineProperty(t, "getBigInt", {
            enumerable: !0,
            get: function () {
              return p.getBigInt;
            },
          }),
          Object.defineProperty(t, "getNumber", {
            enumerable: !0,
            get: function () {
              return p.getNumber;
            },
          }),
          Object.defineProperty(t, "getUint", {
            enumerable: !0,
            get: function () {
              return p.getUint;
            },
          }),
          Object.defineProperty(t, "toBeArray", {
            enumerable: !0,
            get: function () {
              return p.toBeArray;
            },
          }),
          Object.defineProperty(t, "toBigInt", {
            enumerable: !0,
            get: function () {
              return p.toBigInt;
            },
          }),
          Object.defineProperty(t, "toBeHex", {
            enumerable: !0,
            get: function () {
              return p.toBeHex;
            },
          }),
          Object.defineProperty(t, "toNumber", {
            enumerable: !0,
            get: function () {
              return p.toNumber;
            },
          }),
          Object.defineProperty(t, "toQuantity", {
            enumerable: !0,
            get: function () {
              return p.toQuantity;
            },
          }),
          Object.defineProperty(t, "fromTwos", {
            enumerable: !0,
            get: function () {
              return p.fromTwos;
            },
          }),
          Object.defineProperty(t, "toTwos", {
            enumerable: !0,
            get: function () {
              return p.toTwos;
            },
          }),
          Object.defineProperty(t, "mask", {
            enumerable: !0,
            get: function () {
              return p.mask;
            },
          }),
          Object.defineProperty(t, "formatEther", {
            enumerable: !0,
            get: function () {
              return p.formatEther;
            },
          }),
          Object.defineProperty(t, "parseEther", {
            enumerable: !0,
            get: function () {
              return p.parseEther;
            },
          }),
          Object.defineProperty(t, "formatUnits", {
            enumerable: !0,
            get: function () {
              return p.formatUnits;
            },
          }),
          Object.defineProperty(t, "parseUnits", {
            enumerable: !0,
            get: function () {
              return p.parseUnits;
            },
          }),
          Object.defineProperty(t, "toUtf8Bytes", {
            enumerable: !0,
            get: function () {
              return p.toUtf8Bytes;
            },
          }),
          Object.defineProperty(t, "toUtf8CodePoints", {
            enumerable: !0,
            get: function () {
              return p.toUtf8CodePoints;
            },
          }),
          Object.defineProperty(t, "toUtf8String", {
            enumerable: !0,
            get: function () {
              return p.toUtf8String;
            },
          }),
          Object.defineProperty(t, "Utf8ErrorFuncs", {
            enumerable: !0,
            get: function () {
              return p.Utf8ErrorFuncs;
            },
          }),
          Object.defineProperty(t, "decodeRlp", {
            enumerable: !0,
            get: function () {
              return p.decodeRlp;
            },
          }),
          Object.defineProperty(t, "encodeRlp", {
            enumerable: !0,
            get: function () {
              return p.encodeRlp;
            },
          }),
          Object.defineProperty(t, "uuidV4", {
            enumerable: !0,
            get: function () {
              return p.uuidV4;
            },
          });
        var f = n(91602);
        Object.defineProperty(t, "Mnemonic", {
          enumerable: !0,
          get: function () {
            return f.Mnemonic;
          },
        }),
          Object.defineProperty(t, "BaseWallet", {
            enumerable: !0,
            get: function () {
              return f.BaseWallet;
            },
          }),
          Object.defineProperty(t, "HDNodeWallet", {
            enumerable: !0,
            get: function () {
              return f.HDNodeWallet;
            },
          }),
          Object.defineProperty(t, "HDNodeVoidWallet", {
            enumerable: !0,
            get: function () {
              return f.HDNodeVoidWallet;
            },
          }),
          Object.defineProperty(t, "Wallet", {
            enumerable: !0,
            get: function () {
              return f.Wallet;
            },
          }),
          Object.defineProperty(t, "defaultPath", {
            enumerable: !0,
            get: function () {
              return f.defaultPath;
            },
          }),
          Object.defineProperty(t, "getAccountPath", {
            enumerable: !0,
            get: function () {
              return f.getAccountPath;
            },
          }),
          Object.defineProperty(t, "getIndexedAccountPath", {
            enumerable: !0,
            get: function () {
              return f.getIndexedAccountPath;
            },
          }),
          Object.defineProperty(t, "isCrowdsaleJson", {
            enumerable: !0,
            get: function () {
              return f.isCrowdsaleJson;
            },
          }),
          Object.defineProperty(t, "isKeystoreJson", {
            enumerable: !0,
            get: function () {
              return f.isKeystoreJson;
            },
          }),
          Object.defineProperty(t, "decryptCrowdsaleJson", {
            enumerable: !0,
            get: function () {
              return f.decryptCrowdsaleJson;
            },
          }),
          Object.defineProperty(t, "decryptKeystoreJsonSync", {
            enumerable: !0,
            get: function () {
              return f.decryptKeystoreJsonSync;
            },
          }),
          Object.defineProperty(t, "decryptKeystoreJson", {
            enumerable: !0,
            get: function () {
              return f.decryptKeystoreJson;
            },
          }),
          Object.defineProperty(t, "encryptKeystoreJson", {
            enumerable: !0,
            get: function () {
              return f.encryptKeystoreJson;
            },
          }),
          Object.defineProperty(t, "encryptKeystoreJsonSync", {
            enumerable: !0,
            get: function () {
              return f.encryptKeystoreJsonSync;
            },
          });
        var g = n(60659);
        Object.defineProperty(t, "Wordlist", {
          enumerable: !0,
          get: function () {
            return g.Wordlist;
          },
        }),
          Object.defineProperty(t, "LangEn", {
            enumerable: !0,
            get: function () {
              return g.LangEn;
            },
          }),
          Object.defineProperty(t, "WordlistOwl", {
            enumerable: !0,
            get: function () {
              return g.WordlistOwl;
            },
          }),
          Object.defineProperty(t, "WordlistOwlA", {
            enumerable: !0,
            get: function () {
              return g.WordlistOwlA;
            },
          }),
          Object.defineProperty(t, "wordlists", {
            enumerable: !0,
            get: function () {
              return g.wordlists;
            },
          });
      },
      52625: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }), (t.id = void 0);
        let s = n(96965),
          i = n(42120);
        t.id = function (e) {
          return (0, s.keccak256)((0, i.toUtf8Bytes)(e));
        };
      },
      62475: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.verifyTypedData =
            t.TypedDataEncoder =
            t.solidityPackedSha256 =
            t.solidityPackedKeccak256 =
            t.solidityPacked =
            t.verifyMessage =
            t.hashMessage =
            t.dnsEncode =
            t.namehash =
            t.isValidName =
            t.ensNormalize =
            t.id =
              void 0);
        var s = n(52625);
        Object.defineProperty(t, "id", {
          enumerable: !0,
          get: function () {
            return s.id;
          },
        });
        var i = n(85420);
        Object.defineProperty(t, "ensNormalize", {
          enumerable: !0,
          get: function () {
            return i.ensNormalize;
          },
        }),
          Object.defineProperty(t, "isValidName", {
            enumerable: !0,
            get: function () {
              return i.isValidName;
            },
          }),
          Object.defineProperty(t, "namehash", {
            enumerable: !0,
            get: function () {
              return i.namehash;
            },
          }),
          Object.defineProperty(t, "dnsEncode", {
            enumerable: !0,
            get: function () {
              return i.dnsEncode;
            },
          });
        var a = n(18043);
        Object.defineProperty(t, "hashMessage", {
          enumerable: !0,
          get: function () {
            return a.hashMessage;
          },
        }),
          Object.defineProperty(t, "verifyMessage", {
            enumerable: !0,
            get: function () {
              return a.verifyMessage;
            },
          });
        var o = n(18191);
        Object.defineProperty(t, "solidityPacked", {
          enumerable: !0,
          get: function () {
            return o.solidityPacked;
          },
        }),
          Object.defineProperty(t, "solidityPackedKeccak256", {
            enumerable: !0,
            get: function () {
              return o.solidityPackedKeccak256;
            },
          }),
          Object.defineProperty(t, "solidityPackedSha256", {
            enumerable: !0,
            get: function () {
              return o.solidityPackedSha256;
            },
          });
        var l = n(58993);
        Object.defineProperty(t, "TypedDataEncoder", {
          enumerable: !0,
          get: function () {
            return l.TypedDataEncoder;
          },
        }),
          Object.defineProperty(t, "verifyTypedData", {
            enumerable: !0,
            get: function () {
              return l.verifyTypedData;
            },
          });
      },
      18043: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.verifyMessage = t.hashMessage = void 0);
        let s = n(96965),
          i = n(61428),
          a = n(2290),
          o = n(42120);
        function l(e) {
          return (
            "string" == typeof e && (e = (0, o.toUtf8Bytes)(e)),
            (0, s.keccak256)(
              (0, o.concat)([
                (0, o.toUtf8Bytes)(i.MessagePrefix),
                (0, o.toUtf8Bytes)(String(e.length)),
                e,
              ])
            )
          );
        }
        (t.hashMessage = l),
          (t.verifyMessage = function (e, t) {
            let n = l(e);
            return (0, a.recoverAddress)(n, t);
          });
      },
      85420: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.dnsEncode = t.namehash = t.isValidName = t.ensNormalize = void 0);
        let s = n(96965),
          i = n(42120),
          a = n(40030),
          o = new Uint8Array(32);
        function l(e) {
          return (
            (0, i.assertArgument)(
              0 !== e.length,
              "invalid ENS name; empty component",
              "comp",
              e
            ),
            e
          );
        }
        function u(e) {
          let t = (0, i.toUtf8Bytes)(c(e)),
            n = [];
          if (0 === e.length) return n;
          let s = 0;
          for (let e = 0; e < t.length; e++)
            46 === t[e] && (n.push(l(t.slice(s, e))), (s = e + 1));
          return (
            (0, i.assertArgument)(
              s < t.length,
              "invalid ENS name; empty component",
              "name",
              e
            ),
            n.push(l(t.slice(s))),
            n
          );
        }
        function c(e) {
          try {
            if (0 === e.length) throw Error("empty label");
            return (0, a.ens_normalize)(e);
          } catch (t) {
            (0, i.assertArgument)(
              !1,
              `invalid ENS name (${t.message})`,
              "name",
              e
            );
          }
        }
        o.fill(0),
          (t.ensNormalize = c),
          (t.isValidName = function (e) {
            try {
              return 0 !== u(e).length;
            } catch (e) {}
            return !1;
          }),
          (t.namehash = function (e) {
            (0, i.assertArgument)(
              "string" == typeof e,
              "invalid ENS name; not a string",
              "name",
              e
            ),
              (0, i.assertArgument)(
                e.length,
                "invalid ENS name (empty label)",
                "name",
                e
              );
            let t = o,
              n = u(e);
            for (; n.length; )
              t = (0, s.keccak256)(
                (0, i.concat)([t, (0, s.keccak256)(n.pop())])
              );
            return (0, i.hexlify)(t);
          }),
          (t.dnsEncode = function (e, t) {
            let n = null != t ? t : 63;
            return (
              (0, i.assertArgument)(
                n <= 255,
                "DNS encoded label cannot exceed 255",
                "length",
                n
              ),
              (0, i.hexlify)(
                (0, i.concat)(
                  u(e).map((t) => {
                    (0, i.assertArgument)(
                      t.length <= n,
                      `label ${JSON.stringify(e)} exceeds ${n} bytes`,
                      "name",
                      e
                    );
                    let s = new Uint8Array(t.length + 1);
                    return s.set(t, 1), (s[0] = s.length - 1), s;
                  })
                )
              ) + "00"
            );
          });
      },
      18191: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.solidityPackedSha256 =
            t.solidityPackedKeccak256 =
            t.solidityPacked =
              void 0);
        let s = n(45475),
          i = n(96965),
          a = n(42120),
          o = RegExp("^bytes([0-9]+)$"),
          l = RegExp("^(u?int)([0-9]*)$"),
          u = RegExp("^(.*)\\[([0-9]*)\\]$");
        function c(e, t) {
          (0, a.assertArgument)(
            e.length === t.length,
            "wrong number of values; expected ${ types.length }",
            "values",
            t
          );
          let n = [];
          return (
            e.forEach(function (e, i) {
              n.push(
                (function e(t, n, i) {
                  switch (t) {
                    case "address":
                      if (i) return (0, a.getBytes)((0, a.zeroPadValue)(n, 32));
                      return (0, a.getBytes)((0, s.getAddress)(n));
                    case "string":
                      return (0, a.toUtf8Bytes)(n);
                    case "bytes":
                      return (0, a.getBytes)(n);
                    case "bool":
                      if (((n = n ? "0x01" : "0x00"), i))
                        return (0, a.getBytes)((0, a.zeroPadValue)(n, 32));
                      return (0, a.getBytes)(n);
                  }
                  let c = t.match(l);
                  if (c) {
                    let e = "int" === c[1],
                      s = parseInt(c[2] || "256");
                    return (
                      (0, a.assertArgument)(
                        (!c[2] || c[2] === String(s)) &&
                          s % 8 == 0 &&
                          0 !== s &&
                          s <= 256,
                        "invalid number type",
                        "type",
                        t
                      ),
                      i && (s = 256),
                      e && (n = (0, a.toTwos)(n, s)),
                      (0, a.getBytes)(
                        (0, a.zeroPadValue)((0, a.toBeArray)(n), s / 8)
                      )
                    );
                  }
                  if ((c = t.match(o))) {
                    let e = parseInt(c[1]);
                    return ((0, a.assertArgument)(
                      String(e) === c[1] && 0 !== e && e <= 32,
                      "invalid bytes type",
                      "type",
                      t
                    ),
                    (0, a.assertArgument)(
                      (0, a.dataLength)(n) === e,
                      `invalid value for ${t}`,
                      "value",
                      n
                    ),
                    i)
                      ? (0, a.getBytes)((0, a.zeroPadBytes)(n, 32))
                      : n;
                  }
                  if ((c = t.match(u)) && Array.isArray(n)) {
                    let s = c[1],
                      i = parseInt(c[2] || String(n.length));
                    (0, a.assertArgument)(
                      i === n.length,
                      `invalid array length for ${t}`,
                      "value",
                      n
                    );
                    let o = [];
                    return (
                      n.forEach(function (t) {
                        o.push(e(s, t, !0));
                      }),
                      (0, a.getBytes)((0, a.concat)(o))
                    );
                  }
                  (0, a.assertArgument)(!1, "invalid type", "type", t);
                })(e, t[i])
              );
            }),
            (0, a.hexlify)((0, a.concat)(n))
          );
        }
        (t.solidityPacked = c),
          (t.solidityPackedKeccak256 = function (e, t) {
            return (0, i.keccak256)(c(e, t));
          }),
          (t.solidityPackedSha256 = function (e, t) {
            return (0, i.sha256)(c(e, t));
          });
      },
      58993: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.verifyTypedData = t.TypedDataEncoder = void 0);
        let s = n(45475),
          i = n(96965),
          a = n(2290),
          o = n(42120),
          l = n(52625),
          u = new Uint8Array(32);
        u.fill(0);
        let c = BigInt(-1),
          d = BigInt(0),
          h = BigInt(1),
          p = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          ),
          f = (0, o.toBeHex)(h, 32),
          g = (0, o.toBeHex)(d, 32),
          m = {
            name: "string",
            version: "string",
            chainId: "uint256",
            verifyingContract: "address",
            salt: "bytes32",
          },
          y = ["name", "version", "chainId", "verifyingContract", "salt"];
        function b(e) {
          return function (t) {
            return (
              (0, o.assertArgument)(
                "string" == typeof t,
                `invalid domain value for ${JSON.stringify(e)}`,
                `domain.${e}`,
                t
              ),
              t
            );
          };
        }
        let A = {
          name: b("name"),
          version: b("version"),
          chainId: function (e) {
            let t = (0, o.getBigInt)(e, "domain.chainId");
            return ((0, o.assertArgument)(
              t >= 0,
              "invalid chain ID",
              "domain.chainId",
              e
            ),
            Number.isSafeInteger(t))
              ? Number(t)
              : (0, o.toQuantity)(t);
          },
          verifyingContract: function (e) {
            try {
              return (0, s.getAddress)(e).toLowerCase();
            } catch (e) {}
            (0, o.assertArgument)(
              !1,
              'invalid domain value "verifyingContract"',
              "domain.verifyingContract",
              e
            );
          },
          salt: function (e) {
            let t = (0, o.getBytes)(e, "domain.salt");
            return (
              (0, o.assertArgument)(
                32 === t.length,
                'invalid domain value "salt"',
                "domain.salt",
                e
              ),
              (0, o.hexlify)(t)
            );
          },
        };
        function w(e) {
          {
            let t = e.match(/^(u?)int(\d+)$/);
            if (t) {
              let n = "" === t[1],
                s = parseInt(t[2]);
              (0, o.assertArgument)(
                s % 8 == 0 && 0 !== s && s <= 256 && t[2] === String(s),
                "invalid numeric width",
                "type",
                e
              );
              let i = (0, o.mask)(p, n ? s - 1 : s),
                a = n ? (i + h) * c : d;
              return function (t) {
                let s = (0, o.getBigInt)(t, "value");
                return (
                  (0, o.assertArgument)(
                    s >= a && s <= i,
                    `value out-of-bounds for ${e}`,
                    "value",
                    s
                  ),
                  (0, o.toBeHex)(n ? (0, o.toTwos)(s, 256) : s, 32)
                );
              };
            }
          }
          {
            let t = e.match(/^bytes(\d+)$/);
            if (t) {
              let n = parseInt(t[1]);
              return (
                (0, o.assertArgument)(
                  0 !== n && n <= 32 && t[1] === String(n),
                  "invalid bytes width",
                  "type",
                  e
                ),
                function (t) {
                  let s = (0, o.getBytes)(t);
                  return (
                    (0, o.assertArgument)(
                      s.length === n,
                      `invalid length for ${e}`,
                      "value",
                      t
                    ),
                    (function (e) {
                      let t = (0, o.getBytes)(e),
                        n = t.length % 32;
                      return n
                        ? (0, o.concat)([t, u.slice(n)])
                        : (0, o.hexlify)(t);
                    })(t)
                  );
                }
              );
            }
          }
          switch (e) {
            case "address":
              return function (e) {
                return (0, o.zeroPadValue)((0, s.getAddress)(e), 32);
              };
            case "bool":
              return function (e) {
                return e ? f : g;
              };
            case "bytes":
              return function (e) {
                return (0, i.keccak256)(e);
              };
            case "string":
              return function (e) {
                return (0, l.id)(e);
              };
          }
          return null;
        }
        function v(e, t) {
          return `${e}(${t
            .map(({ name: e, type: t }) => t + " " + e)
            .join(",")})`;
        }
        function E(e) {
          let t = e.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
          return t
            ? {
                base: t[1],
                index: t[2] + t[4],
                array: {
                  base: t[1],
                  prefix: t[1] + t[2],
                  count: t[5] ? parseInt(t[5]) : -1,
                },
              }
            : { base: e };
        }
        class P {
          primaryType;
          #S;
          get types() {
            return JSON.parse(this.#S);
          }
          #C;
          #B;
          constructor(e) {
            (this.#C = new Map()), (this.#B = new Map());
            let t = new Map(),
              n = new Map(),
              s = new Map(),
              i = {};
            for (let a in (Object.keys(e).forEach((a) => {
              (i[a] = e[a].map(({ name: t, type: n }) => {
                let { base: s, index: i } = E(n);
                return (
                  "int" !== s || e.int || (s = "int256"),
                  "uint" !== s || e.uint || (s = "uint256"),
                  { name: t, type: s + (i || "") }
                );
              })),
                t.set(a, new Set()),
                n.set(a, []),
                s.set(a, new Set());
            }),
            (this.#S = JSON.stringify(i)),
            i)) {
              let s = new Set();
              for (let l of i[a]) {
                (0, o.assertArgument)(
                  !s.has(l.name),
                  `duplicate variable name ${JSON.stringify(
                    l.name
                  )} in ${JSON.stringify(a)}`,
                  "types",
                  e
                ),
                  s.add(l.name);
                let i = E(l.type).base;
                (0, o.assertArgument)(
                  i !== a,
                  `circular type reference to ${JSON.stringify(i)}`,
                  "types",
                  e
                ),
                  w(i) ||
                    ((0, o.assertArgument)(
                      n.has(i),
                      `unknown type ${JSON.stringify(i)}`,
                      "types",
                      e
                    ),
                    n.get(i).push(a),
                    t.get(a).add(i));
              }
            }
            let a = Array.from(n.keys()).filter((e) => 0 === n.get(e).length);
            for (let [l, u] of ((0, o.assertArgument)(
              0 !== a.length,
              "missing primary type",
              "types",
              e
            ),
            (0, o.assertArgument)(
              1 === a.length,
              `ambiguous primary types or unused types: ${a
                .map((e) => JSON.stringify(e))
                .join(", ")}`,
              "types",
              e
            ),
            (0, o.defineProperties)(this, { primaryType: a[0] }),
            (function i(a, l) {
              for (let u of ((0, o.assertArgument)(
                !l.has(a),
                `circular type reference to ${JSON.stringify(a)}`,
                "types",
                e
              ),
              l.add(a),
              t.get(a)))
                if (n.has(u)) for (let e of (i(u, l), l)) s.get(e).add(u);
              l.delete(a);
            })(this.primaryType, new Set()),
            s)) {
              let e = Array.from(u);
              e.sort(),
                this.#C.set(l, v(l, i[l]) + e.map((e) => v(e, i[e])).join(""));
            }
          }
          getEncoder(e) {
            let t = this.#B.get(e);
            return t || ((t = this.#N(e)), this.#B.set(e, t)), t;
          }
          #N(e) {
            {
              let t = w(e);
              if (t) return t;
            }
            let t = E(e).array;
            if (t) {
              let e = t.prefix,
                n = this.getEncoder(e);
              return (s) => {
                (0, o.assertArgument)(
                  -1 === t.count || t.count === s.length,
                  `array length mismatch; expected length ${t.count}`,
                  "value",
                  s
                );
                let a = s.map(n);
                return (
                  this.#C.has(e) && (a = a.map(i.keccak256)),
                  (0, i.keccak256)((0, o.concat)(a))
                );
              };
            }
            let n = this.types[e];
            if (n) {
              let t = (0, l.id)(this.#C.get(e));
              return (e) => {
                let s = n.map(({ name: t, type: n }) => {
                  let s = this.getEncoder(n)(e[t]);
                  return this.#C.has(n) ? (0, i.keccak256)(s) : s;
                });
                return s.unshift(t), (0, o.concat)(s);
              };
            }
            (0, o.assertArgument)(!1, `unknown type: ${e}`, "type", e);
          }
          encodeType(e) {
            let t = this.#C.get(e);
            return (
              (0, o.assertArgument)(
                t,
                `unknown type: ${JSON.stringify(e)}`,
                "name",
                e
              ),
              t
            );
          }
          encodeData(e, t) {
            return this.getEncoder(e)(t);
          }
          hashStruct(e, t) {
            return (0, i.keccak256)(this.encodeData(e, t));
          }
          encode(e) {
            return this.encodeData(this.primaryType, e);
          }
          hash(e) {
            return this.hashStruct(this.primaryType, e);
          }
          _visit(e, t, n) {
            if (w(e)) return n(e, t);
            let s = E(e).array;
            if (s)
              return (
                (0, o.assertArgument)(
                  -1 === s.count || s.count === t.length,
                  `array length mismatch; expected length ${s.count}`,
                  "value",
                  t
                ),
                t.map((e) => this._visit(s.prefix, e, n))
              );
            let i = this.types[e];
            if (i)
              return i.reduce(
                (e, { name: s, type: i }) => (
                  (e[s] = this._visit(i, t[s], n)), e
                ),
                {}
              );
            (0, o.assertArgument)(!1, `unknown type: ${e}`, "type", e);
          }
          visit(e, t) {
            return this._visit(this.primaryType, e, t);
          }
          static from(e) {
            return new P(e);
          }
          static getPrimaryType(e) {
            return P.from(e).primaryType;
          }
          static hashStruct(e, t, n) {
            return P.from(t).hashStruct(e, n);
          }
          static hashDomain(e) {
            let t = [];
            for (let n in e) {
              if (null == e[n]) continue;
              let s = m[n];
              (0, o.assertArgument)(
                s,
                `invalid typed-data domain key: ${JSON.stringify(n)}`,
                "domain",
                e
              ),
                t.push({ name: n, type: s });
            }
            return (
              t.sort((e, t) => y.indexOf(e.name) - y.indexOf(t.name)),
              P.hashStruct("EIP712Domain", { EIP712Domain: t }, e)
            );
          }
          static encode(e, t, n) {
            return (0, o.concat)([
              "0x1901",
              P.hashDomain(e),
              P.from(t).hash(n),
            ]);
          }
          static hash(e, t, n) {
            return (0, i.keccak256)(P.encode(e, t, n));
          }
          static async resolveNames(e, t, n, s) {
            for (let t in (e = Object.assign({}, e)))
              null == e[t] && delete e[t];
            let i = {};
            e.verifyingContract &&
              !(0, o.isHexString)(e.verifyingContract, 20) &&
              (i[e.verifyingContract] = "0x");
            let a = P.from(t);
            for (let e in (a.visit(
              n,
              (e, t) => (
                "address" !== e || (0, o.isHexString)(t, 20) || (i[t] = "0x"), t
              )
            ),
            i))
              i[e] = await s(e);
            return (
              e.verifyingContract &&
                i[e.verifyingContract] &&
                (e.verifyingContract = i[e.verifyingContract]),
              (n = a.visit(n, (e, t) => ("address" === e && i[t] ? i[t] : t))),
              { domain: e, value: n }
            );
          }
          static getPayload(e, t, n) {
            P.hashDomain(e);
            let s = {},
              i = [];
            y.forEach((t) => {
              let n = e[t];
              null != n && ((s[t] = A[t](n)), i.push({ name: t, type: m[t] }));
            });
            let a = P.from(t),
              l = Object.assign({}, (t = a.types));
            return (
              (0, o.assertArgument)(
                null == l.EIP712Domain,
                "types must not contain EIP712Domain type",
                "types.EIP712Domain",
                t
              ),
              (l.EIP712Domain = i),
              a.encode(n),
              {
                types: l,
                domain: s,
                primaryType: a.primaryType,
                message: a.visit(n, (e, t) => {
                  if (e.match(/^bytes(\d*)/))
                    return (0, o.hexlify)((0, o.getBytes)(t));
                  if (e.match(/^u?int/)) return (0, o.getBigInt)(t).toString();
                  switch (e) {
                    case "address":
                      return t.toLowerCase();
                    case "bool":
                      return !!t;
                    case "string":
                      return (
                        (0, o.assertArgument)(
                          "string" == typeof t,
                          "invalid string",
                          "value",
                          t
                        ),
                        t
                      );
                  }
                  (0, o.assertArgument)(!1, "unsupported type", "type", e);
                }),
              }
            );
          }
        }
        (t.TypedDataEncoder = P),
          (t.verifyTypedData = function (e, t, n, s) {
            return (0, a.recoverAddress)(P.hash(e, t, n), s);
          });
      },
      59237: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ethers = void 0);
        let s = n(94427),
          i = s.__importStar(n(81097));
        (t.ethers = i), s.__exportStar(n(81097), t);
      },
      55142: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AbstractProvider = t.UnmanagedSubscriber = void 0);
        let s = n(45475),
          i = n(61428),
          a = n(37252),
          o = n(62475),
          l = n(2290),
          u = n(42120),
          c = n(54087),
          d = n(83080),
          h = n(54837),
          p = n(37143),
          f = n(21097),
          g = BigInt(2);
        function m(e) {
          return e && "function" == typeof e.then;
        }
        function y(e, t) {
          return (
            e +
            ":" +
            JSON.stringify(t, (e, t) => {
              if (null == t) return "null";
              if ("bigint" == typeof t) return `bigint:${t.toString()}`;
              if ("string" == typeof t) return t.toLowerCase();
              if ("object" == typeof t && !Array.isArray(t)) {
                let e = Object.keys(t);
                return e.sort(), e.reduce((e, n) => ((e[n] = t[n]), e), {});
              }
              return t;
            })
          );
        }
        class b {
          name;
          constructor(e) {
            (0, u.defineProperties)(this, { name: e });
          }
          start() {}
          stop() {}
          pause(e) {}
          resume() {}
        }
        function A(e) {
          return (e = Array.from(new Set(e).values())).sort(), e;
        }
        async function w(e, t) {
          if (null == e) throw Error("invalid event");
          if ((Array.isArray(e) && (e = { topics: e }), "string" == typeof e))
            switch (e) {
              case "block":
              case "debug":
              case "error":
              case "finalized":
              case "network":
              case "pending":
              case "safe":
                return { type: e, tag: e };
            }
          if ((0, u.isHexString)(e, 32)) {
            let t = e.toLowerCase();
            return { type: "transaction", tag: y("tx", { hash: t }), hash: t };
          }
          if (e.orphan) {
            let t = e;
            return {
              type: "orphan",
              tag: y("orphan", t),
              filter: JSON.parse(JSON.stringify(t)),
            };
          }
          if (e.address || e.topics) {
            let n = e,
              i = {
                topics: (n.topics || []).map((e) =>
                  null == e
                    ? null
                    : Array.isArray(e)
                    ? A(e.map((e) => e.toLowerCase()))
                    : e.toLowerCase()
                ),
              };
            if (n.address) {
              let e = [],
                a = [],
                o = (n) => {
                  (0, u.isHexString)(n)
                    ? e.push(n)
                    : a.push(
                        (async () => {
                          e.push(await (0, s.resolveAddress)(n, t));
                        })()
                      );
                };
              Array.isArray(n.address) ? n.address.forEach(o) : o(n.address),
                a.length && (await Promise.all(a)),
                (i.address = A(e.map((e) => e.toLowerCase())));
            }
            return { filter: i, tag: y("event", i), type: "event" };
          }
          (0, u.assertArgument)(!1, "unknown ProviderEvent", "event", e);
        }
        function v() {
          return new Date().getTime();
        }
        t.UnmanagedSubscriber = b;
        let E = { cacheTimeout: 250, pollingInterval: 4e3 };
        class P {
          #R;
          #I;
          #M;
          #L;
          #_;
          #F;
          #D;
          #U;
          #j;
          #H;
          #$;
          #w;
          constructor(e, t) {
            if (((this.#w = Object.assign({}, E, t || {})), "any" === e))
              (this.#F = !0), (this.#_ = null);
            else if (e) {
              let t = h.Network.from(e);
              (this.#F = !1),
                (this.#_ = Promise.resolve(t)),
                setTimeout(() => {
                  this.emit("network", t, null);
                }, 0);
            } else (this.#F = !1), (this.#_ = null);
            (this.#U = -1),
              (this.#D = new Map()),
              (this.#R = new Map()),
              (this.#I = new Map()),
              (this.#M = null),
              (this.#L = !1),
              (this.#j = 1),
              (this.#H = new Map()),
              (this.#$ = !1);
          }
          get pollingInterval() {
            return this.#w.pollingInterval;
          }
          get provider() {
            return this;
          }
          get plugins() {
            return Array.from(this.#I.values());
          }
          attachPlugin(e) {
            if (this.#I.get(e.name))
              throw Error(`cannot replace existing plugin: ${e.name} `);
            return this.#I.set(e.name, e.connect(this)), this;
          }
          getPlugin(e) {
            return this.#I.get(e) || null;
          }
          get disableCcipRead() {
            return this.#$;
          }
          set disableCcipRead(e) {
            this.#$ = !!e;
          }
          async #G(e) {
            let t = this.#w.cacheTimeout;
            if (t < 0) return await this._perform(e);
            let n = y(e.method, e),
              s = this.#D.get(n);
            return (
              s ||
                ((s = this._perform(e)),
                this.#D.set(n, s),
                setTimeout(() => {
                  this.#D.get(n) === s && this.#D.delete(n);
                }, t)),
              await s
            );
          }
          async ccipReadFetch(e, t, n) {
            if (this.disableCcipRead || 0 === n.length || null == e.to)
              return null;
            let s = e.to.toLowerCase(),
              i = t.toLowerCase(),
              a = [];
            for (let t = 0; t < n.length; t++) {
              let o;
              let l = n[t],
                c = l.replace("{sender}", s).replace("{data}", i),
                d = new u.FetchRequest(c);
              -1 === l.indexOf("{data}") && (d.body = { data: i, sender: s }),
                this.emit("debug", {
                  action: "sendCcipReadFetchRequest",
                  request: d,
                  index: t,
                  urls: n,
                });
              let h = "unknown error";
              try {
                o = await d.send();
              } catch (e) {
                a.push(e.message),
                  this.emit("debug", {
                    action: "receiveCcipReadFetchError",
                    request: d,
                    result: { error: e },
                  });
                continue;
              }
              try {
                let e = o.bodyJson;
                if (e.data)
                  return (
                    this.emit("debug", {
                      action: "receiveCcipReadFetchResult",
                      request: d,
                      result: e,
                    }),
                    e.data
                  );
                e.message && (h = e.message),
                  this.emit("debug", {
                    action: "receiveCcipReadFetchError",
                    request: d,
                    result: e,
                  });
              } catch (e) {}
              (0, u.assert)(
                o.statusCode < 400 || o.statusCode >= 500,
                `response not found during CCIP fetch: ${h}`,
                "OFFCHAIN_FAULT",
                {
                  reason: "404_MISSING_RESOURCE",
                  transaction: e,
                  info: { url: l, errorMessage: h },
                }
              ),
                a.push(h);
            }
            (0, u.assert)(
              !1,
              `error encountered during CCIP fetch: ${a
                .map((e) => JSON.stringify(e))
                .join(", ")}`,
              "OFFCHAIN_FAULT",
              {
                reason: "500_SERVER_ERROR",
                transaction: e,
                info: { urls: n, errorMessages: a },
              }
            );
          }
          _wrapBlock(e, t) {
            return new p.Block((0, d.formatBlock)(e), this);
          }
          _wrapLog(e, t) {
            return new p.Log((0, d.formatLog)(e), this);
          }
          _wrapTransactionReceipt(e, t) {
            return new p.TransactionReceipt(
              (0, d.formatTransactionReceipt)(e),
              this
            );
          }
          _wrapTransactionResponse(e, t) {
            return new p.TransactionResponse(
              (0, d.formatTransactionResponse)(e),
              this
            );
          }
          _detectNetwork() {
            (0, u.assert)(
              !1,
              "sub-classes must implement this",
              "UNSUPPORTED_OPERATION",
              { operation: "_detectNetwork" }
            );
          }
          async _perform(e) {
            (0, u.assert)(
              !1,
              `unsupported method: ${e.method}`,
              "UNSUPPORTED_OPERATION",
              { operation: e.method, info: e }
            );
          }
          async getBlockNumber() {
            let e = (0, u.getNumber)(
              await this.#G({ method: "getBlockNumber" }),
              "%response"
            );
            return this.#U >= 0 && (this.#U = e), e;
          }
          _getAddress(e) {
            return (0, s.resolveAddress)(e, this);
          }
          _getBlockTag(e) {
            if (null == e) return "latest";
            switch (e) {
              case "earliest":
                return "0x0";
              case "finalized":
              case "latest":
              case "pending":
              case "safe":
                return e;
            }
            return (0, u.isHexString)(e)
              ? (0, u.isHexString)(e, 32)
                ? e
                : (0, u.toQuantity)(e)
              : ("bigint" == typeof e && (e = (0, u.getNumber)(e, "blockTag")),
                "number" == typeof e)
              ? e >= 0
                ? (0, u.toQuantity)(e)
                : this.#U >= 0
                ? (0, u.toQuantity)(this.#U + e)
                : this.getBlockNumber().then((t) => (0, u.toQuantity)(t + e))
              : void (0, u.assertArgument)(
                  !1,
                  "invalid blockTag",
                  "blockTag",
                  e
                );
          }
          _getFilter(e) {
            let t, n;
            let s = (e.topics || []).map((e) =>
                null == e
                  ? null
                  : Array.isArray(e)
                  ? A(e.map((e) => e.toLowerCase()))
                  : e.toLowerCase()
              ),
              i = "blockHash" in e ? e.blockHash : void 0,
              a = (e, t, n) => {
                let a;
                switch (e.length) {
                  case 0:
                    break;
                  case 1:
                    a = e[0];
                    break;
                  default:
                    e.sort(), (a = e);
                }
                if (i && (null != t || null != n))
                  throw Error("invalid filter");
                let o = {};
                return (
                  a && (o.address = a),
                  s.length && (o.topics = s),
                  t && (o.fromBlock = t),
                  n && (o.toBlock = n),
                  i && (o.blockHash = i),
                  o
                );
              },
              o = [];
            if (e.address) {
              if (Array.isArray(e.address))
                for (let t of e.address) o.push(this._getAddress(t));
              else o.push(this._getAddress(e.address));
            }
            return (
              "fromBlock" in e && (t = this._getBlockTag(e.fromBlock)),
              ("toBlock" in e && (n = this._getBlockTag(e.toBlock)),
              o.filter((e) => "string" != typeof e).length ||
                (null != t && "string" != typeof t) ||
                (null != n && "string" != typeof n))
                ? Promise.all([Promise.all(o), t, n]).then((e) =>
                    a(e[0], e[1], e[2])
                  )
                : a(o, t, n)
            );
          }
          _getTransactionRequest(e) {
            let t = (0, p.copyRequest)(e),
              n = [];
            if (
              (["to", "from"].forEach((e) => {
                if (null == t[e]) return;
                let i = (0, s.resolveAddress)(t[e], this);
                m(i)
                  ? n.push(
                      (async function () {
                        t[e] = await i;
                      })()
                    )
                  : (t[e] = i);
              }),
              null != t.blockTag)
            ) {
              let e = this._getBlockTag(t.blockTag);
              m(e)
                ? n.push(
                    (async function () {
                      t.blockTag = await e;
                    })()
                  )
                : (t.blockTag = e);
            }
            return n.length
              ? (async function () {
                  return await Promise.all(n), t;
                })()
              : t;
          }
          async getNetwork() {
            if (null == this.#_) {
              let e = (async () => {
                try {
                  let e = await this._detectNetwork();
                  return this.emit("network", e, null), e;
                } catch (t) {
                  throw (this.#_ === e && (this.#_ = null), t);
                }
              })();
              return (this.#_ = e), (await e).clone();
            }
            let e = this.#_,
              [t, n] = await Promise.all([e, this._detectNetwork()]);
            return (
              t.chainId !== n.chainId &&
                (this.#F
                  ? (this.emit("network", n, t),
                    this.#_ === e && (this.#_ = Promise.resolve(n)))
                  : (0, u.assert)(
                      !1,
                      `network changed: ${t.chainId} => ${n.chainId} `,
                      "NETWORK_ERROR",
                      { event: "changed" }
                    )),
              t.clone()
            );
          }
          async getFeeData() {
            let e = await this.getNetwork(),
              t = async () => {
                let {
                    _block: t,
                    gasPrice: n,
                    priorityFee: s,
                  } = await (0, u.resolveProperties)({
                    _block: this.#K("latest", !1),
                    gasPrice: (async () => {
                      try {
                        let e = await this.#G({ method: "getGasPrice" });
                        return (0, u.getBigInt)(e, "%response");
                      } catch (e) {}
                      return null;
                    })(),
                    priorityFee: (async () => {
                      try {
                        let e = await this.#G({ method: "getPriorityFee" });
                        return (0, u.getBigInt)(e, "%response");
                      } catch (e) {}
                      return null;
                    })(),
                  }),
                  i = null,
                  a = null,
                  o = this._wrapBlock(t, e);
                return (
                  o &&
                    o.baseFeePerGas &&
                    ((a = null != s ? s : BigInt("1000000000")),
                    (i = o.baseFeePerGas * g + a)),
                  new p.FeeData(n, i, a)
                );
              },
              n = e.getPlugin(
                "org.ethers.plugins.network.FetchUrlFeeDataPlugin"
              );
            if (n) {
              let e = new u.FetchRequest(n.url),
                s = await n.processFunc(t, this, e);
              return new p.FeeData(
                s.gasPrice,
                s.maxFeePerGas,
                s.maxPriorityFeePerGas
              );
            }
            return await t();
          }
          async estimateGas(e) {
            let t = this._getTransactionRequest(e);
            return (
              m(t) && (t = await t),
              (0, u.getBigInt)(
                await this.#G({ method: "estimateGas", transaction: t }),
                "%response"
              )
            );
          }
          async #V(e, t, n) {
            (0, u.assert)(
              n < 10,
              "CCIP read exceeded maximum redirections",
              "OFFCHAIN_FAULT",
              {
                reason: "TOO_MANY_REDIRECTS",
                transaction: Object.assign({}, e, {
                  blockTag: t,
                  enableCcipRead: !0,
                }),
              }
            );
            let i = (0, p.copyRequest)(e);
            try {
              return (0, u.hexlify)(
                await this._perform({
                  method: "call",
                  transaction: i,
                  blockTag: t,
                })
              );
            } catch (e) {
              if (
                !this.disableCcipRead &&
                (0, u.isCallException)(e) &&
                e.data &&
                n >= 0 &&
                "latest" === t &&
                null != i.to &&
                "0x556f1830" === (0, u.dataSlice)(e.data, 0, 4)
              ) {
                let a;
                let o = e.data,
                  l = await (0, s.resolveAddress)(i.to, this);
                try {
                  a = (function (e) {
                    let t = {
                      sender: "",
                      urls: [],
                      calldata: "",
                      selector: "",
                      extraData: "",
                      errorArgs: [],
                    };
                    (0, u.assert)(
                      (0, u.dataLength)(e) >= 160,
                      "insufficient OffchainLookup data",
                      "OFFCHAIN_FAULT",
                      { reason: "insufficient OffchainLookup data" }
                    );
                    let n = (0, u.dataSlice)(e, 0, 32);
                    (0, u.assert)(
                      (0, u.dataSlice)(n, 0, 12) === (0, u.dataSlice)(O, 0, 12),
                      "corrupt OffchainLookup sender",
                      "OFFCHAIN_FAULT",
                      { reason: "corrupt OffchainLookup sender" }
                    ),
                      (t.sender = (0, u.dataSlice)(n, 12));
                    try {
                      let n = [],
                        s = (0, u.getNumber)((0, u.dataSlice)(e, 32, 64)),
                        i = (0, u.getNumber)((0, u.dataSlice)(e, s, s + 32)),
                        a = (0, u.dataSlice)(e, s + 32);
                      for (let e = 0; e < i; e++) {
                        let t = (function (e, t) {
                          try {
                            let n = k(e, t);
                            if (n) return (0, u.toUtf8String)(n);
                          } catch (e) {}
                          return null;
                        })(a, 32 * e);
                        if (null == t) throw Error("abort");
                        n.push(t);
                      }
                      t.urls = n;
                    } catch (e) {
                      (0, u.assert)(
                        !1,
                        "corrupt OffchainLookup urls",
                        "OFFCHAIN_FAULT",
                        { reason: "corrupt OffchainLookup urls" }
                      );
                    }
                    try {
                      let n = k(e, 64);
                      if (null == n) throw Error("abort");
                      t.calldata = n;
                    } catch (e) {
                      (0, u.assert)(
                        !1,
                        "corrupt OffchainLookup calldata",
                        "OFFCHAIN_FAULT",
                        { reason: "corrupt OffchainLookup calldata" }
                      );
                    }
                    (0, u.assert)(
                      (0, u.dataSlice)(e, 100, 128) ===
                        (0, u.dataSlice)(O, 0, 28),
                      "corrupt OffchainLookup callbaackSelector",
                      "OFFCHAIN_FAULT",
                      { reason: "corrupt OffchainLookup callbaackSelector" }
                    ),
                      (t.selector = (0, u.dataSlice)(e, 96, 100));
                    try {
                      let n = k(e, 128);
                      if (null == n) throw Error("abort");
                      t.extraData = n;
                    } catch (e) {
                      (0, u.assert)(
                        !1,
                        "corrupt OffchainLookup extraData",
                        "OFFCHAIN_FAULT",
                        { reason: "corrupt OffchainLookup extraData" }
                      );
                    }
                    return (
                      (t.errorArgs = "sender,urls,calldata,selector,extraData"
                        .split(/,/)
                        .map((e) => t[e])),
                      t
                    );
                  })((0, u.dataSlice)(e.data, 4));
                } catch (e) {
                  (0, u.assert)(!1, e.message, "OFFCHAIN_FAULT", {
                    reason: "BAD_DATA",
                    transaction: i,
                    info: { data: o },
                  });
                }
                (0, u.assert)(
                  a.sender.toLowerCase() === l.toLowerCase(),
                  "CCIP Read sender mismatch",
                  "CALL_EXCEPTION",
                  {
                    action: "call",
                    data: o,
                    reason: "OffchainLookup",
                    transaction: i,
                    invocation: null,
                    revert: {
                      signature:
                        "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                      name: "OffchainLookup",
                      args: a.errorArgs,
                    },
                  }
                );
                let c = await this.ccipReadFetch(i, a.calldata, a.urls);
                (0, u.assert)(
                  null != c,
                  "CCIP Read failed to fetch data",
                  "OFFCHAIN_FAULT",
                  {
                    reason: "FETCH_FAILED",
                    transaction: i,
                    info: { data: e.data, errorArgs: a.errorArgs },
                  }
                );
                let d = {
                  to: l,
                  data: (0, u.concat)([
                    a.selector,
                    (function (e) {
                      let t = [],
                        n = 0;
                      for (let s = 0; s < e.length; s++) t.push(x), (n += 32);
                      for (let s = 0; s < e.length; s++) {
                        let i = (0, u.getBytes)(e[s]);
                        (t[s] = T(n)),
                          t.push(T(i.length)),
                          t.push(
                            (function (e) {
                              if (e.length % 32 == 0) return e;
                              let t = new Uint8Array(
                                32 * Math.ceil(e.length / 32)
                              );
                              return t.set(e), t;
                            })(i)
                          ),
                          (n += 32 + 32 * Math.ceil(i.length / 32));
                      }
                      return (0, u.concat)(t);
                    })([c, a.extraData]),
                  ]),
                };
                this.emit("debug", {
                  action: "sendCcipReadCall",
                  transaction: d,
                });
                try {
                  let e = await this.#V(d, t, n + 1);
                  return (
                    this.emit("debug", {
                      action: "receiveCcipReadCallResult",
                      transaction: Object.assign({}, d),
                      result: e,
                    }),
                    e
                  );
                } catch (e) {
                  throw (
                    (this.emit("debug", {
                      action: "receiveCcipReadCallError",
                      transaction: Object.assign({}, d),
                      error: e,
                    }),
                    e)
                  );
                }
              }
              throw e;
            }
          }
          async #z(e) {
            let { value: t } = await (0, u.resolveProperties)({
              network: this.getNetwork(),
              value: e,
            });
            return t;
          }
          async call(e) {
            let { tx: t, blockTag: n } = await (0, u.resolveProperties)({
              tx: this._getTransactionRequest(e),
              blockTag: this._getBlockTag(e.blockTag),
            });
            return await this.#z(this.#V(t, n, e.enableCcipRead ? 0 : -1));
          }
          async #J(e, t, n) {
            let s = this._getAddress(t),
              i = this._getBlockTag(n);
            return (
              ("string" != typeof s || "string" != typeof i) &&
                ([s, i] = await Promise.all([s, i])),
              await this.#z(
                this.#G(Object.assign(e, { address: s, blockTag: i }))
              )
            );
          }
          async getBalance(e, t) {
            return (0, u.getBigInt)(
              await this.#J({ method: "getBalance" }, e, t),
              "%response"
            );
          }
          async getTransactionCount(e, t) {
            return (0, u.getNumber)(
              await this.#J({ method: "getTransactionCount" }, e, t),
              "%response"
            );
          }
          async getCode(e, t) {
            return (0, u.hexlify)(await this.#J({ method: "getCode" }, e, t));
          }
          async getStorage(e, t, n) {
            let s = (0, u.getBigInt)(t, "position");
            return (0, u.hexlify)(
              await this.#J({ method: "getStorage", position: s }, e, n)
            );
          }
          async broadcastTransaction(e) {
            let {
                blockNumber: t,
                hash: n,
                network: s,
              } = await (0, u.resolveProperties)({
                blockNumber: this.getBlockNumber(),
                hash: this._perform({
                  method: "broadcastTransaction",
                  signedTransaction: e,
                }),
                network: this.getNetwork(),
              }),
              i = l.Transaction.from(e);
            if (i.hash !== n)
              throw Error("@TODO: the returned hash did not match");
            return this._wrapTransactionResponse(i, s).replaceableTransaction(
              t
            );
          }
          async #K(e, t) {
            if ((0, u.isHexString)(e, 32))
              return await this.#G({
                method: "getBlock",
                blockHash: e,
                includeTransactions: t,
              });
            let n = this._getBlockTag(e);
            return (
              "string" != typeof n && (n = await n),
              await this.#G({
                method: "getBlock",
                blockTag: n,
                includeTransactions: t,
              })
            );
          }
          async getBlock(e, t) {
            let { network: n, params: s } = await (0, u.resolveProperties)({
              network: this.getNetwork(),
              params: this.#K(e, !!t),
            });
            return null == s ? null : this._wrapBlock(s, n);
          }
          async getTransaction(e) {
            let { network: t, params: n } = await (0, u.resolveProperties)({
              network: this.getNetwork(),
              params: this.#G({ method: "getTransaction", hash: e }),
            });
            return null == n ? null : this._wrapTransactionResponse(n, t);
          }
          async getTransactionReceipt(e) {
            let { network: t, params: n } = await (0, u.resolveProperties)({
              network: this.getNetwork(),
              params: this.#G({ method: "getTransactionReceipt", hash: e }),
            });
            if (null == n) return null;
            if (null == n.gasPrice && null == n.effectiveGasPrice) {
              let t = await this.#G({ method: "getTransaction", hash: e });
              if (null == t)
                throw Error(
                  "report this; could not find tx or effectiveGasPrice"
                );
              n.effectiveGasPrice = t.gasPrice;
            }
            return this._wrapTransactionReceipt(n, t);
          }
          async getTransactionResult(e) {
            let { result: t } = await (0, u.resolveProperties)({
              network: this.getNetwork(),
              result: this.#G({ method: "getTransactionResult", hash: e }),
            });
            return null == t ? null : (0, u.hexlify)(t);
          }
          async getLogs(e) {
            let t = this._getFilter(e);
            m(t) && (t = await t);
            let { network: n, params: s } = await (0, u.resolveProperties)({
              network: this.getNetwork(),
              params: this.#G({ method: "getLogs", filter: t }),
            });
            return s.map((e) => this._wrapLog(e, n));
          }
          _getProvider(e) {
            (0, u.assert)(
              !1,
              "provider cannot connect to target network",
              "UNSUPPORTED_OPERATION",
              { operation: "_getProvider()" }
            );
          }
          async getResolver(e) {
            return await c.EnsResolver.fromName(this, e);
          }
          async getAvatar(e) {
            let t = await this.getResolver(e);
            return t ? await t.getAvatar() : null;
          }
          async resolveName(e) {
            let t = await this.getResolver(e);
            return t ? await t.getAddress() : null;
          }
          async lookupAddress(e) {
            e = (0, s.getAddress)(e);
            let t = (0, o.namehash)(
              e.substring(2).toLowerCase() + ".addr.reverse"
            );
            try {
              let n = await c.EnsResolver.getEnsAddress(this),
                s = new a.Contract(
                  n,
                  ["function resolver(bytes32) view returns (address)"],
                  this
                ),
                o = await s.resolver(t);
              if (null == o || o === i.ZeroAddress) return null;
              let l = new a.Contract(
                  o,
                  ["function name(bytes32) view returns (string)"],
                  this
                ),
                u = await l.name(t);
              if ((await this.resolveName(u)) !== e) return null;
              return u;
            } catch (e) {
              if (
                ((0, u.isError)(e, "BAD_DATA") && "0x" === e.value) ||
                (0, u.isError)(e, "CALL_EXCEPTION")
              )
                return null;
              throw e;
            }
            return null;
          }
          async waitForTransaction(e, t, n) {
            let s = null != t ? t : 1;
            return 0 === s
              ? this.getTransactionReceipt(e)
              : new Promise(async (t, i) => {
                  let a = null,
                    o = async (n) => {
                      try {
                        let i = await this.getTransactionReceipt(e);
                        if (null != i && n - i.blockNumber + 1 >= s) {
                          t(i), a && (clearTimeout(a), (a = null));
                          return;
                        }
                      } catch (e) {
                        console.log("EEE", e);
                      }
                      this.once("block", o);
                    };
                  null != n &&
                    (a = setTimeout(() => {
                      null != a &&
                        ((a = null),
                        this.off("block", o),
                        i(
                          (0, u.makeError)("timeout", "TIMEOUT", {
                            reason: "timeout",
                          })
                        ));
                    }, n)),
                    o(await this.getBlockNumber());
                });
          }
          async waitForBlock(e) {
            (0, u.assert)(!1, "not implemented yet", "NOT_IMPLEMENTED", {
              operation: "waitForBlock",
            });
          }
          _clearTimeout(e) {
            let t = this.#H.get(e);
            t && (t.timer && clearTimeout(t.timer), this.#H.delete(e));
          }
          _setTimeout(e, t) {
            null == t && (t = 0);
            let n = this.#j++,
              s = () => {
                this.#H.delete(n), e();
              };
            if (this.paused) this.#H.set(n, { timer: null, func: s, time: t });
            else {
              let e = setTimeout(s, t);
              this.#H.set(n, { timer: e, func: s, time: v() });
            }
            return n;
          }
          _forEachSubscriber(e) {
            for (let t of this.#R.values()) e(t.subscriber);
          }
          _getSubscriber(e) {
            switch (e.type) {
              case "debug":
              case "error":
              case "network":
                return new b(e.type);
              case "block": {
                let e = new f.PollingBlockSubscriber(this);
                return (e.pollingInterval = this.pollingInterval), e;
              }
              case "safe":
              case "finalized":
                return new f.PollingBlockTagSubscriber(this, e.type);
              case "event":
                return new f.PollingEventSubscriber(this, e.filter);
              case "transaction":
                return new f.PollingTransactionSubscriber(this, e.hash);
              case "orphan":
                return new f.PollingOrphanSubscriber(this, e.filter);
            }
            throw Error(`unsupported event: ${e.type}`);
          }
          _recoverSubscriber(e, t) {
            for (let n of this.#R.values())
              if (n.subscriber === e) {
                n.started && n.subscriber.stop(),
                  (n.subscriber = t),
                  n.started && t.start(),
                  null != this.#M && t.pause(this.#M);
                break;
              }
          }
          async #Q(e, t) {
            let n = await w(e, this);
            return (
              "event" === n.type &&
                t &&
                t.length > 0 &&
                !0 === t[0].removed &&
                (n = await w({ orphan: "drop-log", log: t[0] }, this)),
              this.#R.get(n.tag) || null
            );
          }
          async #q(e) {
            let t = await w(e, this),
              n = t.tag,
              s = this.#R.get(n);
            return (
              !s &&
                ((s = {
                  subscriber: this._getSubscriber(t),
                  tag: n,
                  addressableMap: new WeakMap(),
                  nameMap: new Map(),
                  started: !1,
                  listeners: [],
                }),
                this.#R.set(n, s)),
              s
            );
          }
          async on(e, t) {
            let n = await this.#q(e);
            return (
              n.listeners.push({ listener: t, once: !1 }),
              n.started ||
                (n.subscriber.start(),
                (n.started = !0),
                null != this.#M && n.subscriber.pause(this.#M)),
              this
            );
          }
          async once(e, t) {
            let n = await this.#q(e);
            return (
              n.listeners.push({ listener: t, once: !0 }),
              n.started ||
                (n.subscriber.start(),
                (n.started = !0),
                null != this.#M && n.subscriber.pause(this.#M)),
              this
            );
          }
          async emit(e, ...t) {
            let n = await this.#Q(e, t);
            if (!n || 0 === n.listeners.length) return !1;
            let s = n.listeners.length;
            return (
              (n.listeners = n.listeners.filter(({ listener: n, once: s }) => {
                let i = new u.EventPayload(this, s ? null : n, e);
                try {
                  n.call(this, ...t, i);
                } catch (e) {}
                return !s;
              })),
              0 === n.listeners.length &&
                (n.started && n.subscriber.stop(), this.#R.delete(n.tag)),
              s > 0
            );
          }
          async listenerCount(e) {
            if (e) {
              let t = await this.#Q(e);
              return t ? t.listeners.length : 0;
            }
            let t = 0;
            for (let { listeners: e } of this.#R.values()) t += e.length;
            return t;
          }
          async listeners(e) {
            if (e) {
              let t = await this.#Q(e);
              return t ? t.listeners.map(({ listener: e }) => e) : [];
            }
            let t = [];
            for (let { listeners: e } of this.#R.values())
              t = t.concat(e.map(({ listener: e }) => e));
            return t;
          }
          async off(e, t) {
            let n = await this.#Q(e);
            if (!n) return this;
            if (t) {
              let e = n.listeners.map(({ listener: e }) => e).indexOf(t);
              e >= 0 && n.listeners.splice(e, 1);
            }
            return (
              (t && 0 !== n.listeners.length) ||
                (n.started && n.subscriber.stop(), this.#R.delete(n.tag)),
              this
            );
          }
          async removeAllListeners(e) {
            if (e) {
              let { tag: t, started: n, subscriber: s } = await this.#q(e);
              n && s.stop(), this.#R.delete(t);
            } else
              for (let [e, { started: t, subscriber: n }] of this.#R)
                t && n.stop(), this.#R.delete(e);
            return this;
          }
          async addListener(e, t) {
            return await this.on(e, t);
          }
          async removeListener(e, t) {
            return this.off(e, t);
          }
          get destroyed() {
            return this.#L;
          }
          destroy() {
            for (let e of (this.removeAllListeners(), this.#H.keys()))
              this._clearTimeout(e);
            this.#L = !0;
          }
          get paused() {
            return null != this.#M;
          }
          set paused(e) {
            !!e !== this.paused &&
              (this.paused ? this.resume() : this.pause(!1));
          }
          pause(e) {
            if (((this.#U = -1), null != this.#M)) {
              if (!!e == this.#M) return;
              (0, u.assert)(
                !1,
                "cannot change pause type; resume first",
                "UNSUPPORTED_OPERATION",
                { operation: "pause" }
              );
            }
            for (let t of (this._forEachSubscriber((t) => t.pause(e)),
            (this.#M = !!e),
            this.#H.values()))
              t.timer && clearTimeout(t.timer), (t.time = v() - t.time);
          }
          resume() {
            if (null != this.#M)
              for (let e of (this._forEachSubscriber((e) => e.resume()),
              (this.#M = null),
              this.#H.values())) {
                let t = e.time;
                t < 0 && (t = 0), (e.time = v()), setTimeout(e.func, t);
              }
          }
        }
        function k(e, t) {
          if ("0x" === e) return null;
          try {
            let n = (0, u.getNumber)((0, u.dataSlice)(e, t, t + 32)),
              s = (0, u.getNumber)((0, u.dataSlice)(e, n, n + 32));
            return (0, u.dataSlice)(e, n + 32, n + 32 + s);
          } catch (e) {}
          return null;
        }
        function T(e) {
          let t = (0, u.toBeArray)(e);
          if (t.length > 32) throw Error("internal; should not happen");
          let n = new Uint8Array(32);
          return n.set(t, 32 - t.length), n;
        }
        t.AbstractProvider = P;
        let x = new Uint8Array([]),
          O =
            "0x0000000000000000000000000000000000000000000000000000000000000000";
      },
      35649: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.VoidSigner = t.AbstractSigner = void 0);
        let s = n(45475),
          i = n(2290),
          a = n(42120),
          o = n(37143);
        function l(e, t) {
          if (e.provider) return e.provider;
          (0, a.assert)(!1, "missing provider", "UNSUPPORTED_OPERATION", {
            operation: t,
          });
        }
        async function u(e, t) {
          let n = (0, o.copyRequest)(t);
          if (
            (null != n.to && (n.to = (0, s.resolveAddress)(n.to, e)),
            null != n.from)
          ) {
            let t = n.from;
            n.from = Promise.all([
              e.getAddress(),
              (0, s.resolveAddress)(t, e),
            ]).then(
              ([e, t]) => (
                (0, a.assertArgument)(
                  e.toLowerCase() === t.toLowerCase(),
                  "transaction from mismatch",
                  "tx.from",
                  t
                ),
                e
              )
            );
          } else n.from = e.getAddress();
          return await (0, a.resolveProperties)(n);
        }
        class c {
          provider;
          constructor(e) {
            (0, a.defineProperties)(this, { provider: e || null });
          }
          async getNonce(e) {
            return l(this, "getTransactionCount").getTransactionCount(
              await this.getAddress(),
              e
            );
          }
          async populateCall(e) {
            return await u(this, e);
          }
          async populateTransaction(e) {
            let t = l(this, "populateTransaction"),
              n = await u(this, e);
            null == n.nonce && (n.nonce = await this.getNonce("pending")),
              null == n.gasLimit && (n.gasLimit = await this.estimateGas(n));
            let s = await this.provider.getNetwork();
            if (null != n.chainId) {
              let t = (0, a.getBigInt)(n.chainId);
              (0, a.assertArgument)(
                t === s.chainId,
                "transaction chainId mismatch",
                "tx.chainId",
                e.chainId
              );
            } else n.chainId = s.chainId;
            let i = null != n.maxFeePerGas || null != n.maxPriorityFeePerGas;
            if (
              (null != n.gasPrice && (2 === n.type || i)
                ? (0, a.assertArgument)(
                    !1,
                    "eip-1559 transaction do not support gasPrice",
                    "tx",
                    e
                  )
                : (0 === n.type || 1 === n.type) &&
                  i &&
                  (0, a.assertArgument)(
                    !1,
                    "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
                    "tx",
                    e
                  ),
              (2 === n.type || null == n.type) &&
                null != n.maxFeePerGas &&
                null != n.maxPriorityFeePerGas)
            )
              n.type = 2;
            else if (0 === n.type || 1 === n.type) {
              let e = await t.getFeeData();
              (0, a.assert)(
                null != e.gasPrice,
                "network does not support gasPrice",
                "UNSUPPORTED_OPERATION",
                { operation: "getGasPrice" }
              ),
                null == n.gasPrice && (n.gasPrice = e.gasPrice);
            } else {
              let e = await t.getFeeData();
              if (null == n.type) {
                if (null != e.maxFeePerGas && null != e.maxPriorityFeePerGas) {
                  if (((n.type = 2), null != n.gasPrice)) {
                    let e = n.gasPrice;
                    delete n.gasPrice,
                      (n.maxFeePerGas = e),
                      (n.maxPriorityFeePerGas = e);
                  } else
                    null == n.maxFeePerGas && (n.maxFeePerGas = e.maxFeePerGas),
                      null == n.maxPriorityFeePerGas &&
                        (n.maxPriorityFeePerGas = e.maxPriorityFeePerGas);
                } else
                  null != e.gasPrice
                    ? ((0, a.assert)(
                        !i,
                        "network does not support EIP-1559",
                        "UNSUPPORTED_OPERATION",
                        { operation: "populateTransaction" }
                      ),
                      null == n.gasPrice && (n.gasPrice = e.gasPrice),
                      (n.type = 0))
                    : (0, a.assert)(
                        !1,
                        "failed to get consistent fee data",
                        "UNSUPPORTED_OPERATION",
                        { operation: "signer.getFeeData" }
                      );
              } else
                (2 === n.type || 3 === n.type) &&
                  (null == n.maxFeePerGas && (n.maxFeePerGas = e.maxFeePerGas),
                  null == n.maxPriorityFeePerGas &&
                    (n.maxPriorityFeePerGas = e.maxPriorityFeePerGas));
            }
            return await (0, a.resolveProperties)(n);
          }
          async estimateGas(e) {
            return l(this, "estimateGas").estimateGas(
              await this.populateCall(e)
            );
          }
          async call(e) {
            return l(this, "call").call(await this.populateCall(e));
          }
          async resolveName(e) {
            let t = l(this, "resolveName");
            return await t.resolveName(e);
          }
          async sendTransaction(e) {
            let t = l(this, "sendTransaction"),
              n = await this.populateTransaction(e);
            delete n.from;
            let s = i.Transaction.from(n);
            return await t.broadcastTransaction(await this.signTransaction(s));
          }
        }
        t.AbstractSigner = c;
        class d extends c {
          address;
          constructor(e, t) {
            super(t), (0, a.defineProperties)(this, { address: e });
          }
          async getAddress() {
            return this.address;
          }
          connect(e) {
            return new d(this.address, e);
          }
          #W(e, t) {
            (0, a.assert)(
              !1,
              `VoidSigner cannot sign ${e}`,
              "UNSUPPORTED_OPERATION",
              { operation: t }
            );
          }
          async signTransaction(e) {
            this.#W("transactions", "signTransaction");
          }
          async signMessage(e) {
            this.#W("messages", "signMessage");
          }
          async signTypedData(e, t, n) {
            this.#W("typed-data", "signTypedData");
          }
        }
        t.VoidSigner = d;
      },
      32813: function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.showThrottleMessage = void 0);
        let n = new Set();
        t.showThrottleMessage = function (e) {
          n.has(e) ||
            (n.add(e),
            console.log("========= NOTICE ========="),
            console.log(
              `Request-Rate Exceeded for ${e} (this message will not be repeated)`
            ),
            console.log(""),
            console.log(
              "The default API keys for each service are provided as a highly-throttled,"
            ),
            console.log(
              "community resource for low-traffic projects and early prototyping."
            ),
            console.log(""),
            console.log(
              "While your application will continue to function, we highly recommended"
            ),
            console.log(
              "signing up for your own API keys to improve performance, increase your"
            ),
            console.log(
              "request rate/limit and enable other perks, such as metrics and advanced APIs."
            ),
            console.log(""),
            console.log("For more details: https://docs.ethers.org/api-keys/"),
            console.log("=========================="));
        };
      },
      7994: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getDefaultProvider = void 0);
        let s = n(42120),
          i = n(16791),
          a = n(23815),
          o = n(60085),
          l = n(3377),
          u = n(22880),
          c = n(35012),
          d = n(81333),
          h = n(24129),
          p = n(32013),
          f = n(54837),
          g = n(62196),
          m =
            "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(
              " "
            );
        t.getDefaultProvider = function (e, t) {
          null == t && (t = {});
          let n = (e) =>
            "-" !== t[e] &&
            ("string" == typeof t.exclusive
              ? e === t.exclusive
              : !Array.isArray(t.exclusive) || -1 !== t.exclusive.indexOf(e));
          if ("string" == typeof e && e.match(/^https?:/))
            return new p.JsonRpcProvider(e);
          if (
            ("string" == typeof e && e.match(/^wss?:/)) ||
            (e && "function" == typeof e.send && "function" == typeof e.close)
          )
            return new g.WebSocketProvider(e);
          let y = null;
          try {
            y = f.Network.from(e);
          } catch (e) {}
          let b = [];
          if (
            (n("publicPolygon") &&
              y &&
              ("matic" === y.name
                ? b.push(
                    new p.JsonRpcProvider("https://polygon-rpc.com/", y, {
                      staticNetwork: y,
                    })
                  )
                : "matic-amoy" === y.name &&
                  b.push(
                    new p.JsonRpcProvider(
                      "https://rpc-amoy.polygon.technology/",
                      y,
                      { staticNetwork: y }
                    )
                  )),
            n("alchemy"))
          )
            try {
              b.push(new a.AlchemyProvider(e, t.alchemy));
            } catch (e) {}
          if (n("ankr") && null != t.ankr)
            try {
              b.push(new i.AnkrProvider(e, t.ankr));
            } catch (e) {}
          if (n("chainstack"))
            try {
              b.push(new o.ChainstackProvider(e, t.chainstack));
            } catch (e) {}
          if (n("cloudflare"))
            try {
              b.push(new l.CloudflareProvider(e));
            } catch (e) {}
          if (n("etherscan"))
            try {
              b.push(new u.EtherscanProvider(e, t.etherscan));
            } catch (e) {}
          if (n("infura"))
            try {
              let n,
                s = t.infura;
              "object" == typeof s &&
                ((n = s.projectSecret), (s = s.projectId)),
                b.push(new c.InfuraProvider(e, s, n));
            } catch (e) {}
          if (n("quicknode"))
            try {
              let n = t.quicknode;
              b.push(new d.QuickNodeProvider(e, n));
            } catch (e) {}
          if (
            ((0, s.assert)(
              b.length,
              "unsupported default network",
              "UNSUPPORTED_OPERATION",
              { operation: "getDefaultProvider" }
            ),
            1 === b.length)
          )
            return b[0];
          let A = Math.floor(b.length / 2);
          return (
            A > 2 && (A = 2),
            y && -1 !== m.indexOf(y.name) && (A = 1),
            t && t.quorum && (A = t.quorum),
            new h.FallbackProvider(b, void 0, { quorum: A })
          );
        };
      },
      54087: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EnsResolver =
            t.BasicMulticoinProviderPlugin =
            t.MulticoinProviderPlugin =
              void 0);
        let s = n(45475),
          i = n(61428),
          a = n(37252),
          o = n(62475),
          l = n(42120);
        function u(e) {
          return (
            e.match(/^ipfs:\/\/ipfs\//i)
              ? (e = e.substring(12))
              : e.match(/^ipfs:\/\//i)
              ? (e = e.substring(7))
              : (0, l.assertArgument)(!1, "unsupported IPFS format", "link", e),
            `https://gateway.ipfs.io/ipfs/${e}`
          );
        }
        class c {
          name;
          constructor(e) {
            (0, l.defineProperties)(this, { name: e });
          }
          connect(e) {
            return this;
          }
          supportsCoinType(e) {
            return !1;
          }
          async encodeAddress(e, t) {
            throw Error("unsupported coin");
          }
          async decodeAddress(e, t) {
            throw Error("unsupported coin");
          }
        }
        t.MulticoinProviderPlugin = c;
        class d extends c {
          constructor() {
            super("org.ethers.plugins.provider.BasicMulticoin");
          }
        }
        t.BasicMulticoinProviderPlugin = d;
        let h = RegExp("^(ipfs)://(.*)$", "i"),
          p = [
            RegExp("^(https)://(.*)$", "i"),
            RegExp("^(data):(.*)$", "i"),
            h,
            RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
          ];
        class f {
          provider;
          address;
          name;
          #Y;
          #Z;
          constructor(e, t, n) {
            (0, l.defineProperties)(this, { provider: e, address: t, name: n }),
              (this.#Y = null),
              (this.#Z = new a.Contract(
                t,
                [
                  "function supportsInterface(bytes4) view returns (bool)",
                  "function resolve(bytes, bytes) view returns (bytes)",
                  "function addr(bytes32) view returns (address)",
                  "function addr(bytes32, uint) view returns (bytes)",
                  "function text(bytes32, string) view returns (string)",
                  "function contenthash(bytes32) view returns (bytes)",
                ],
                e
              ));
          }
          async supportsWildcard() {
            return (
              null == this.#Y &&
                (this.#Y = (async () => {
                  try {
                    return await this.#Z.supportsInterface("0x9061b923");
                  } catch (e) {
                    if ((0, l.isError)(e, "CALL_EXCEPTION")) return !1;
                    throw ((this.#Y = null), e);
                  }
                })()),
              await this.#Y
            );
          }
          async #X(e, t) {
            t = (t || []).slice();
            let n = this.#Z.interface;
            t.unshift((0, o.namehash)(this.name));
            let s = null;
            (await this.supportsWildcard()) &&
              ((s = n.getFunction(e)),
              (0, l.assert)(s, "missing fragment", "UNKNOWN_ERROR", {
                info: { funcName: e },
              }),
              (t = [
                (0, o.dnsEncode)(this.name, 255),
                n.encodeFunctionData(s, t),
              ]),
              (e = "resolve(bytes,bytes)")),
              t.push({ enableCcipRead: !0 });
            try {
              let i = await this.#Z[e](...t);
              if (s) return n.decodeFunctionResult(s, i)[0];
              return i;
            } catch (e) {
              if (!(0, l.isError)(e, "CALL_EXCEPTION")) throw e;
            }
            return null;
          }
          async getAddress(e) {
            if ((null == e && (e = 60), 60 === e))
              try {
                let e = await this.#X("addr(bytes32)");
                if (null == e || e === i.ZeroAddress) return null;
                return e;
              } catch (e) {
                if ((0, l.isError)(e, "CALL_EXCEPTION")) return null;
                throw e;
              }
            if (e >= 0 && e < 2147483648) {
              let t = e + 2147483648,
                n = await this.#X("addr(bytes32,uint)", [t]);
              if ((0, l.isHexString)(n, 20)) return (0, s.getAddress)(n);
            }
            let t = null;
            for (let n of this.provider.plugins)
              if (n instanceof c && n.supportsCoinType(e)) {
                t = n;
                break;
              }
            if (null == t) return null;
            let n = await this.#X("addr(bytes32,uint)", [e]);
            if (null == n || "0x" === n) return null;
            let a = await t.decodeAddress(e, n);
            if (null != a) return a;
            (0, l.assert)(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
              operation: `getAddress(${e})`,
              info: { coinType: e, data: n },
            });
          }
          async getText(e) {
            let t = await this.#X("text(bytes32,string)", [e]);
            return null == t || "0x" === t ? null : t;
          }
          async getContentHash() {
            let e = await this.#X("contenthash(bytes32)");
            if (null == e || "0x" === e) return null;
            let t = e.match(
              /^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
            );
            if (t) {
              let e = "e3010170" === t[1] ? "ipfs" : "ipns",
                n = parseInt(t[4], 16);
              if (t[5].length === 2 * n)
                return `${e}://${(0, l.encodeBase58)("0x" + t[2])}`;
            }
            let n = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (n && 64 === n[1].length) return `bzz://${n[1]}`;
            (0, l.assert)(
              !1,
              "invalid or unsupported content hash data",
              "UNSUPPORTED_OPERATION",
              { operation: "getContentHash()", info: { data: e } }
            );
          }
          async getAvatar() {
            return (await this._getAvatar()).url;
          }
          async _getAvatar() {
            let e = [{ type: "name", value: this.name }];
            try {
              let t = await this.getText("avatar");
              if (null == t)
                return (
                  e.push({ type: "!avatar", value: "" }),
                  { url: null, linkage: e }
                );
              e.push({ type: "avatar", value: t });
              for (let n = 0; n < p.length; n++) {
                let s = t.match(p[n]);
                if (null == s) continue;
                let i = s[1].toLowerCase();
                switch (i) {
                  case "https":
                  case "data":
                    return (
                      e.push({ type: "url", value: t }), { linkage: e, url: t }
                    );
                  case "ipfs": {
                    let n = u(t);
                    return (
                      e.push({ type: "ipfs", value: t }),
                      e.push({ type: "url", value: n }),
                      { linkage: e, url: n }
                    );
                  }
                  case "erc721":
                  case "erc1155": {
                    let n =
                      "erc721" === i ? "tokenURI(uint256)" : "uri(uint256)";
                    e.push({ type: i, value: t });
                    let o = await this.getAddress();
                    if (null == o)
                      return (
                        e.push({ type: "!owner", value: "" }),
                        { url: null, linkage: e }
                      );
                    let c = (s[2] || "").split("/");
                    if (2 !== c.length)
                      return (
                        e.push({ type: `!${i}caip`, value: s[2] || "" }),
                        { url: null, linkage: e }
                      );
                    let d = c[1],
                      p = new a.Contract(
                        c[0],
                        [
                          "function tokenURI(uint) view returns (string)",
                          "function ownerOf(uint) view returns (address)",
                          "function uri(uint) view returns (string)",
                          "function balanceOf(address, uint256) view returns (uint)",
                        ],
                        this.provider
                      );
                    if ("erc721" === i) {
                      let t = await p.ownerOf(d);
                      if (o !== t)
                        return (
                          e.push({ type: "!owner", value: t }),
                          { url: null, linkage: e }
                        );
                      e.push({ type: "owner", value: t });
                    } else if ("erc1155" === i) {
                      let t = await p.balanceOf(o, d);
                      if (!t)
                        return (
                          e.push({ type: "!balance", value: "0" }),
                          { url: null, linkage: e }
                        );
                      e.push({ type: "balance", value: t.toString() });
                    }
                    let f = await p[n](d);
                    if (null == f || "0x" === f)
                      return (
                        e.push({ type: "!metadata-url", value: "" }),
                        { url: null, linkage: e }
                      );
                    e.push({ type: "metadata-url-base", value: f }),
                      "erc1155" === i &&
                        ((f = f.replace(
                          "{id}",
                          (0, l.toBeHex)(d, 32).substring(2)
                        )),
                        e.push({ type: "metadata-url-expanded", value: f })),
                      f.match(/^ipfs:/i) && (f = u(f)),
                      e.push({ type: "metadata-url", value: f });
                    let g = {},
                      m = await new l.FetchRequest(f).send();
                    m.assertOk();
                    try {
                      g = m.bodyJson;
                    } catch (t) {
                      try {
                        e.push({ type: "!metadata", value: m.bodyText });
                      } catch (n) {
                        let t = m.body;
                        t &&
                          e.push({
                            type: "!metadata",
                            value: (0, l.hexlify)(t),
                          });
                      }
                      return { url: null, linkage: e };
                    }
                    if (!g)
                      return (
                        e.push({ type: "!metadata", value: "" }),
                        { url: null, linkage: e }
                      );
                    e.push({ type: "metadata", value: JSON.stringify(g) });
                    let y = g.image;
                    if ("string" != typeof y)
                      return (
                        e.push({ type: "!imageUrl", value: "" }),
                        { url: null, linkage: e }
                      );
                    if (y.match(/^(https:\/\/|data:)/i));
                    else {
                      let t = y.match(h);
                      if (null == t)
                        return (
                          e.push({ type: "!imageUrl-ipfs", value: y }),
                          { url: null, linkage: e }
                        );
                      e.push({ type: "imageUrl-ipfs", value: y }), (y = u(y));
                    }
                    return (
                      e.push({ type: "url", value: y }), { linkage: e, url: y }
                    );
                  }
                }
              }
            } catch (e) {}
            return { linkage: e, url: null };
          }
          static async getEnsAddress(e) {
            let t = await e.getNetwork(),
              n = t.getPlugin("org.ethers.plugins.network.Ens");
            return (
              (0, l.assert)(
                n,
                "network does not support ENS",
                "UNSUPPORTED_OPERATION",
                { operation: "getEnsAddress", info: { network: t } }
              ),
              n.address
            );
          }
          static async #ee(e, t) {
            let n = await f.getEnsAddress(e);
            try {
              let s = new a.Contract(
                  n,
                  ["function resolver(bytes32) view returns (address)"],
                  e
                ),
                l = await s.resolver((0, o.namehash)(t), {
                  enableCcipRead: !0,
                });
              if (l === i.ZeroAddress) return null;
              return l;
            } catch (e) {
              throw e;
            }
            return null;
          }
          static async fromName(e, t) {
            let n = t;
            for (;;) {
              if ("" === n || "." === n || ("eth" !== t && "eth" === n))
                return null;
              let s = await f.#ee(e, n);
              if (null != s) {
                let i = new f(e, s, t);
                if (n !== t && !(await i.supportsWildcard())) return null;
                return i;
              }
              n = n.split(".").slice(1).join(".");
            }
          }
        }
        t.EnsResolver = f;
      },
      83080: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.formatTransactionResponse =
            t.formatTransactionReceipt =
            t.formatReceiptLog =
            t.formatBlock =
            t.formatLog =
            t.formatUint256 =
            t.formatHash =
            t.formatData =
            t.formatBoolean =
            t.object =
            t.arrayOf =
            t.allowNull =
              void 0);
        let s = n(45475),
          i = n(96965),
          a = n(2290),
          o = n(42120),
          l = BigInt(0);
        function u(e, t) {
          return function (n) {
            return null == n ? t : e(n);
          };
        }
        function c(e, t) {
          return (n) => {
            if (t && null == n) return null;
            if (!Array.isArray(n)) throw Error("not an array");
            return n.map((t) => e(t));
          };
        }
        function d(e, t) {
          return (n) => {
            let s = {};
            for (let i in e) {
              let a = i;
              if (t && i in t && !(a in n)) {
                for (let e of t[i])
                  if (e in n) {
                    a = e;
                    break;
                  }
              }
              try {
                let t = e[i](n[a]);
                void 0 !== t && (s[i] = t);
              } catch (t) {
                let e = t instanceof Error ? t.message : "not-an-error";
                (0, o.assert)(
                  !1,
                  `invalid value for value.${i} (${e})`,
                  "BAD_DATA",
                  { value: n }
                );
              }
            }
            return s;
          };
        }
        function h(e) {
          switch (e) {
            case !0:
            case "true":
              return !0;
            case !1:
            case "false":
              return !1;
          }
          (0, o.assertArgument)(
            !1,
            `invalid boolean; ${JSON.stringify(e)}`,
            "value",
            e
          );
        }
        function p(e) {
          return (
            (0, o.assertArgument)(
              (0, o.isHexString)(e, !0),
              "invalid data",
              "value",
              e
            ),
            e
          );
        }
        function f(e) {
          return (
            (0, o.assertArgument)(
              (0, o.isHexString)(e, 32),
              "invalid hash",
              "value",
              e
            ),
            e
          );
        }
        (t.allowNull = u),
          (t.arrayOf = c),
          (t.object = d),
          (t.formatBoolean = h),
          (t.formatData = p),
          (t.formatHash = f),
          (t.formatUint256 = function (e) {
            if (!(0, o.isHexString)(e)) throw Error("invalid uint256");
            return (0, o.zeroPadValue)(e, 32);
          });
        let g = d(
          {
            address: s.getAddress,
            blockHash: f,
            blockNumber: o.getNumber,
            data: p,
            index: o.getNumber,
            removed: u(h, !1),
            topics: c(f),
            transactionHash: f,
            transactionIndex: o.getNumber,
          },
          { index: ["logIndex"] }
        );
        t.formatLog = function (e) {
          return g(e);
        };
        let m = d(
          {
            hash: u(f),
            parentHash: f,
            parentBeaconBlockRoot: u(f, null),
            number: o.getNumber,
            timestamp: o.getNumber,
            nonce: u(p),
            difficulty: o.getBigInt,
            gasLimit: o.getBigInt,
            gasUsed: o.getBigInt,
            stateRoot: u(f, null),
            receiptsRoot: u(f, null),
            blobGasUsed: u(o.getBigInt, null),
            excessBlobGas: u(o.getBigInt, null),
            miner: u(s.getAddress),
            prevRandao: u(f, null),
            extraData: p,
            baseFeePerGas: u(o.getBigInt),
          },
          { prevRandao: ["mixHash"] }
        );
        t.formatBlock = function (e) {
          let t = m(e);
          return (
            (t.transactions = e.transactions.map((e) =>
              "string" == typeof e ? e : w(e)
            )),
            t
          );
        };
        let y = d(
          {
            transactionIndex: o.getNumber,
            blockNumber: o.getNumber,
            transactionHash: f,
            address: s.getAddress,
            topics: c(f),
            data: p,
            index: o.getNumber,
            blockHash: f,
          },
          { index: ["logIndex"] }
        );
        function b(e) {
          return y(e);
        }
        t.formatReceiptLog = b;
        let A = d(
          {
            to: u(s.getAddress, null),
            from: u(s.getAddress, null),
            contractAddress: u(s.getAddress, null),
            index: o.getNumber,
            root: u(o.hexlify),
            gasUsed: o.getBigInt,
            blobGasUsed: u(o.getBigInt, null),
            logsBloom: u(p),
            blockHash: f,
            hash: f,
            logs: c(b),
            blockNumber: o.getNumber,
            cumulativeGasUsed: o.getBigInt,
            effectiveGasPrice: u(o.getBigInt),
            blobGasPrice: u(o.getBigInt, null),
            status: u(o.getNumber),
            type: u(o.getNumber, 0),
          },
          {
            effectiveGasPrice: ["gasPrice"],
            hash: ["transactionHash"],
            index: ["transactionIndex"],
          }
        );
        function w(e) {
          e.to &&
            (0, o.getBigInt)(e.to) === l &&
            (e.to = "0x0000000000000000000000000000000000000000");
          let t = d(
            {
              hash: f,
              index: u(o.getNumber, void 0),
              type: (e) => ("0x" === e || null == e ? 0 : (0, o.getNumber)(e)),
              accessList: u(a.accessListify, null),
              blobVersionedHashes: u(c(f, !0), null),
              blockHash: u(f, null),
              blockNumber: u(o.getNumber, null),
              transactionIndex: u(o.getNumber, null),
              from: s.getAddress,
              gasPrice: u(o.getBigInt),
              maxPriorityFeePerGas: u(o.getBigInt),
              maxFeePerGas: u(o.getBigInt),
              maxFeePerBlobGas: u(o.getBigInt, null),
              gasLimit: o.getBigInt,
              to: u(s.getAddress, null),
              value: o.getBigInt,
              nonce: o.getNumber,
              data: p,
              creates: u(s.getAddress, null),
              chainId: u(o.getBigInt, null),
            },
            { data: ["input"], gasLimit: ["gas"], index: ["transactionIndex"] }
          )(e);
          if (
            (null == t.to &&
              null == t.creates &&
              (t.creates = (0, s.getCreateAddress)(t)),
            (1 === e.type || 2 === e.type) &&
              null == e.accessList &&
              (t.accessList = []),
            e.signature
              ? (t.signature = i.Signature.from(e.signature))
              : (t.signature = i.Signature.from(e)),
            null == t.chainId)
          ) {
            let e = t.signature.legacyChainId;
            null != e && (t.chainId = e);
          }
          return (
            t.blockHash &&
              (0, o.getBigInt)(t.blockHash) === l &&
              (t.blockHash = null),
            t
          );
        }
        (t.formatTransactionReceipt = function (e) {
          return A(e);
        }),
          (t.formatTransactionResponse = w);
      },
      4878: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SocketEventSubscriber =
            t.SocketPendingSubscriber =
            t.SocketBlockSubscriber =
            t.SocketSubscriber =
            t.WebSocketProvider =
            t.SocketProvider =
            t.IpcSocketProvider =
            t.QuickNodeProvider =
            t.PocketProvider =
            t.InfuraWebSocketProvider =
            t.InfuraProvider =
            t.EtherscanPlugin =
            t.EtherscanProvider =
            t.ChainstackProvider =
            t.CloudflareProvider =
            t.AnkrProvider =
            t.AlchemyProvider =
            t.BrowserProvider =
            t.JsonRpcSigner =
            t.JsonRpcProvider =
            t.JsonRpcApiProvider =
            t.FallbackProvider =
            t.copyRequest =
            t.TransactionResponse =
            t.TransactionReceipt =
            t.Log =
            t.FeeData =
            t.Block =
            t.FetchUrlFeeDataNetworkPlugin =
            t.FeeDataNetworkPlugin =
            t.EnsPlugin =
            t.GasCostPlugin =
            t.NetworkPlugin =
            t.NonceManager =
            t.Network =
            t.MulticoinProviderPlugin =
            t.EnsResolver =
            t.getDefaultProvider =
            t.showThrottleMessage =
            t.VoidSigner =
            t.AbstractSigner =
            t.UnmanagedSubscriber =
            t.AbstractProvider =
              void 0);
        var s = n(55142);
        Object.defineProperty(t, "AbstractProvider", {
          enumerable: !0,
          get: function () {
            return s.AbstractProvider;
          },
        }),
          Object.defineProperty(t, "UnmanagedSubscriber", {
            enumerable: !0,
            get: function () {
              return s.UnmanagedSubscriber;
            },
          });
        var i = n(35649);
        Object.defineProperty(t, "AbstractSigner", {
          enumerable: !0,
          get: function () {
            return i.AbstractSigner;
          },
        }),
          Object.defineProperty(t, "VoidSigner", {
            enumerable: !0,
            get: function () {
              return i.VoidSigner;
            },
          });
        var a = n(32813);
        Object.defineProperty(t, "showThrottleMessage", {
          enumerable: !0,
          get: function () {
            return a.showThrottleMessage;
          },
        });
        var o = n(7994);
        Object.defineProperty(t, "getDefaultProvider", {
          enumerable: !0,
          get: function () {
            return o.getDefaultProvider;
          },
        });
        var l = n(54087);
        Object.defineProperty(t, "EnsResolver", {
          enumerable: !0,
          get: function () {
            return l.EnsResolver;
          },
        }),
          Object.defineProperty(t, "MulticoinProviderPlugin", {
            enumerable: !0,
            get: function () {
              return l.MulticoinProviderPlugin;
            },
          });
        var u = n(54837);
        Object.defineProperty(t, "Network", {
          enumerable: !0,
          get: function () {
            return u.Network;
          },
        });
        var c = n(22992);
        Object.defineProperty(t, "NonceManager", {
          enumerable: !0,
          get: function () {
            return c.NonceManager;
          },
        });
        var d = n(67004);
        Object.defineProperty(t, "NetworkPlugin", {
          enumerable: !0,
          get: function () {
            return d.NetworkPlugin;
          },
        }),
          Object.defineProperty(t, "GasCostPlugin", {
            enumerable: !0,
            get: function () {
              return d.GasCostPlugin;
            },
          }),
          Object.defineProperty(t, "EnsPlugin", {
            enumerable: !0,
            get: function () {
              return d.EnsPlugin;
            },
          }),
          Object.defineProperty(t, "FeeDataNetworkPlugin", {
            enumerable: !0,
            get: function () {
              return d.FeeDataNetworkPlugin;
            },
          }),
          Object.defineProperty(t, "FetchUrlFeeDataNetworkPlugin", {
            enumerable: !0,
            get: function () {
              return d.FetchUrlFeeDataNetworkPlugin;
            },
          });
        var h = n(37143);
        Object.defineProperty(t, "Block", {
          enumerable: !0,
          get: function () {
            return h.Block;
          },
        }),
          Object.defineProperty(t, "FeeData", {
            enumerable: !0,
            get: function () {
              return h.FeeData;
            },
          }),
          Object.defineProperty(t, "Log", {
            enumerable: !0,
            get: function () {
              return h.Log;
            },
          }),
          Object.defineProperty(t, "TransactionReceipt", {
            enumerable: !0,
            get: function () {
              return h.TransactionReceipt;
            },
          }),
          Object.defineProperty(t, "TransactionResponse", {
            enumerable: !0,
            get: function () {
              return h.TransactionResponse;
            },
          }),
          Object.defineProperty(t, "copyRequest", {
            enumerable: !0,
            get: function () {
              return h.copyRequest;
            },
          });
        var p = n(24129);
        Object.defineProperty(t, "FallbackProvider", {
          enumerable: !0,
          get: function () {
            return p.FallbackProvider;
          },
        });
        var f = n(32013);
        Object.defineProperty(t, "JsonRpcApiProvider", {
          enumerable: !0,
          get: function () {
            return f.JsonRpcApiProvider;
          },
        }),
          Object.defineProperty(t, "JsonRpcProvider", {
            enumerable: !0,
            get: function () {
              return f.JsonRpcProvider;
            },
          }),
          Object.defineProperty(t, "JsonRpcSigner", {
            enumerable: !0,
            get: function () {
              return f.JsonRpcSigner;
            },
          });
        var g = n(30292);
        Object.defineProperty(t, "BrowserProvider", {
          enumerable: !0,
          get: function () {
            return g.BrowserProvider;
          },
        });
        var m = n(23815);
        Object.defineProperty(t, "AlchemyProvider", {
          enumerable: !0,
          get: function () {
            return m.AlchemyProvider;
          },
        });
        var y = n(16791);
        Object.defineProperty(t, "AnkrProvider", {
          enumerable: !0,
          get: function () {
            return y.AnkrProvider;
          },
        });
        var b = n(3377);
        Object.defineProperty(t, "CloudflareProvider", {
          enumerable: !0,
          get: function () {
            return b.CloudflareProvider;
          },
        });
        var A = n(60085);
        Object.defineProperty(t, "ChainstackProvider", {
          enumerable: !0,
          get: function () {
            return A.ChainstackProvider;
          },
        });
        var w = n(22880);
        Object.defineProperty(t, "EtherscanProvider", {
          enumerable: !0,
          get: function () {
            return w.EtherscanProvider;
          },
        }),
          Object.defineProperty(t, "EtherscanPlugin", {
            enumerable: !0,
            get: function () {
              return w.EtherscanPlugin;
            },
          });
        var v = n(35012);
        Object.defineProperty(t, "InfuraProvider", {
          enumerable: !0,
          get: function () {
            return v.InfuraProvider;
          },
        }),
          Object.defineProperty(t, "InfuraWebSocketProvider", {
            enumerable: !0,
            get: function () {
              return v.InfuraWebSocketProvider;
            },
          });
        var E = n(52751);
        Object.defineProperty(t, "PocketProvider", {
          enumerable: !0,
          get: function () {
            return E.PocketProvider;
          },
        });
        var P = n(81333);
        Object.defineProperty(t, "QuickNodeProvider", {
          enumerable: !0,
          get: function () {
            return P.QuickNodeProvider;
          },
        });
        let k = n(28306);
        Object.defineProperty(t, "IpcSocketProvider", {
          enumerable: !0,
          get: function () {
            return k.IpcSocketProvider;
          },
        });
        var T = n(12394);
        Object.defineProperty(t, "SocketProvider", {
          enumerable: !0,
          get: function () {
            return T.SocketProvider;
          },
        });
        var x = n(62196);
        Object.defineProperty(t, "WebSocketProvider", {
          enumerable: !0,
          get: function () {
            return x.WebSocketProvider;
          },
        });
        var O = n(12394);
        Object.defineProperty(t, "SocketSubscriber", {
          enumerable: !0,
          get: function () {
            return O.SocketSubscriber;
          },
        }),
          Object.defineProperty(t, "SocketBlockSubscriber", {
            enumerable: !0,
            get: function () {
              return O.SocketBlockSubscriber;
            },
          }),
          Object.defineProperty(t, "SocketPendingSubscriber", {
            enumerable: !0,
            get: function () {
              return O.SocketPendingSubscriber;
            },
          }),
          Object.defineProperty(t, "SocketEventSubscriber", {
            enumerable: !0,
            get: function () {
              return O.SocketEventSubscriber;
            },
          });
      },
      54837: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Network = void 0);
        let s = n(2290),
          i = n(42120),
          a = n(67004),
          o = new Map();
        class l {
          #et;
          #er;
          #I;
          constructor(e, t) {
            (this.#et = e),
              (this.#er = (0, i.getBigInt)(t)),
              (this.#I = new Map());
          }
          toJSON() {
            return { name: this.name, chainId: String(this.chainId) };
          }
          get name() {
            return this.#et;
          }
          set name(e) {
            this.#et = e;
          }
          get chainId() {
            return this.#er;
          }
          set chainId(e) {
            this.#er = (0, i.getBigInt)(e, "chainId");
          }
          matches(e) {
            if (null == e) return !1;
            if ("string" == typeof e) {
              try {
                return this.chainId === (0, i.getBigInt)(e);
              } catch (e) {}
              return this.name === e;
            }
            if ("number" == typeof e || "bigint" == typeof e) {
              try {
                return this.chainId === (0, i.getBigInt)(e);
              } catch (e) {}
              return !1;
            }
            if ("object" == typeof e) {
              if (null != e.chainId) {
                try {
                  return this.chainId === (0, i.getBigInt)(e.chainId);
                } catch (e) {}
                return !1;
              }
              if (null != e.name) return this.name === e.name;
            }
            return !1;
          }
          get plugins() {
            return Array.from(this.#I.values());
          }
          attachPlugin(e) {
            if (this.#I.get(e.name))
              throw Error(`cannot replace existing plugin: ${e.name} `);
            return this.#I.set(e.name, e.clone()), this;
          }
          getPlugin(e) {
            return this.#I.get(e) || null;
          }
          getPlugins(e) {
            return this.plugins.filter((t) => t.name.split("#")[0] === e);
          }
          clone() {
            let e = new l(this.name, this.chainId);
            return (
              this.plugins.forEach((t) => {
                e.attachPlugin(t.clone());
              }),
              e
            );
          }
          computeIntrinsicGas(e) {
            let t =
                this.getPlugin("org.ethers.plugins.network.GasCost") ||
                new a.GasCostPlugin(),
              n = t.txBase;
            if ((null == e.to && (n += t.txCreate), e.data))
              for (let s = 2; s < e.data.length; s += 2)
                "00" === e.data.substring(s, s + 2)
                  ? (n += t.txDataZero)
                  : (n += t.txDataNonzero);
            if (e.accessList) {
              let i = (0, s.accessListify)(e.accessList);
              for (let e in i)
                n +=
                  t.txAccessListAddress +
                  t.txAccessListStorageKey * i[e].storageKeys.length;
            }
            return n;
          }
          static from(e) {
            if (
              ((function () {
                d ||
                  ((d = !0),
                  e("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] }),
                  e("ropsten", 3, { ensNetwork: 3 }),
                  e("rinkeby", 4, { ensNetwork: 4 }),
                  e("goerli", 5, { ensNetwork: 5 }),
                  e("kovan", 42, { ensNetwork: 42 }),
                  e("sepolia", 11155111, { ensNetwork: 11155111 }),
                  e("holesky", 17e3, { ensNetwork: 17e3 }),
                  e("classic", 61, {}),
                  e("classicKotti", 6, {}),
                  e("arbitrum", 42161, { ensNetwork: 1 }),
                  e("arbitrum-goerli", 421613, {}),
                  e("arbitrum-sepolia", 421614, {}),
                  e("base", 8453, { ensNetwork: 1 }),
                  e("base-goerli", 84531, {}),
                  e("base-sepolia", 84532, {}),
                  e("bnb", 56, { ensNetwork: 1 }),
                  e("bnbt", 97, {}),
                  e("linea", 59144, { ensNetwork: 1 }),
                  e("linea-goerli", 59140, {}),
                  e("linea-sepolia", 59141, {}),
                  e("matic", 137, {
                    ensNetwork: 1,
                    plugins: [c("https://gasstation.polygon.technology/v2")],
                  }),
                  e("matic-amoy", 80002, {}),
                  e("matic-mumbai", 80001, {
                    altNames: ["maticMumbai", "maticmum"],
                    plugins: [
                      c("https://gasstation-testnet.polygon.technology/v2"),
                    ],
                  }),
                  e("optimism", 10, { ensNetwork: 1, plugins: [] }),
                  e("optimism-goerli", 420, {}),
                  e("optimism-sepolia", 11155420, {}),
                  e("xdai", 100, { ensNetwork: 1 }));
                function e(e, t, n) {
                  let s = function () {
                    let s = new l(e, t);
                    return (
                      null != n.ensNetwork &&
                        s.attachPlugin(new a.EnsPlugin(null, n.ensNetwork)),
                      s.attachPlugin(new a.GasCostPlugin()),
                      (n.plugins || []).forEach((e) => {
                        s.attachPlugin(e);
                      }),
                      s
                    );
                  };
                  l.register(e, s),
                    l.register(t, s),
                    n.altNames &&
                      n.altNames.forEach((e) => {
                        l.register(e, s);
                      });
                }
              })(),
              null == e)
            )
              return l.from("mainnet");
            if (
              ("number" == typeof e && (e = BigInt(e)),
              "string" == typeof e || "bigint" == typeof e)
            ) {
              let t = o.get(e);
              if (t) return t();
              if ("bigint" == typeof e) return new l("unknown", e);
              (0, i.assertArgument)(!1, "unknown network", "network", e);
            }
            if ("function" == typeof e.clone) return e.clone();
            if ("object" == typeof e) {
              (0, i.assertArgument)(
                "string" == typeof e.name && "number" == typeof e.chainId,
                "invalid network object name or chainId",
                "network",
                e
              );
              let t = new l(e.name, e.chainId);
              return (
                (e.ensAddress || null != e.ensNetwork) &&
                  t.attachPlugin(new a.EnsPlugin(e.ensAddress, e.ensNetwork)),
                t
              );
            }
            (0, i.assertArgument)(!1, "invalid network", "network", e);
          }
          static register(e, t) {
            "number" == typeof e && (e = BigInt(e));
            let n = o.get(e);
            n &&
              (0, i.assertArgument)(
                !1,
                `conflicting network for ${JSON.stringify(n.name)}`,
                "nameOrChainId",
                e
              ),
              o.set(e, t);
          }
        }
        function u(e, t) {
          let n = String(e);
          if (!n.match(/^[0-9.]+$/)) throw Error(`invalid gwei value: ${e}`);
          let s = n.split(".");
          if ((1 === s.length && s.push(""), 2 !== s.length))
            throw Error(`invalid gwei value: ${e}`);
          for (; s[1].length < t; ) s[1] += "0";
          if (s[1].length > 9) {
            let e = BigInt(s[1].substring(0, 9));
            !s[1].substring(9).match(/^0+$/) && e++, (s[1] = e.toString());
          }
          return BigInt(s[0] + s[1]);
        }
        function c(e) {
          return new a.FetchUrlFeeDataNetworkPlugin(e, async (e, t, n) => {
            let s;
            n.setHeader("User-Agent", "ethers");
            try {
              let [t, i] = await Promise.all([n.send(), e()]),
                a = (s = t).bodyJson.standard;
              return {
                gasPrice: i.gasPrice,
                maxFeePerGas: u(a.maxFee, 9),
                maxPriorityFeePerGas: u(a.maxPriorityFee, 9),
              };
            } catch (e) {
              (0, i.assert)(
                !1,
                `error encountered with polygon gas station (${JSON.stringify(
                  n.url
                )})`,
                "SERVER_ERROR",
                { request: n, response: s, error: e }
              );
            }
          });
        }
        t.Network = l;
        let d = !1;
      },
      67004: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FetchUrlFeeDataNetworkPlugin =
            t.FeeDataNetworkPlugin =
            t.EnsPlugin =
            t.GasCostPlugin =
            t.NetworkPlugin =
              void 0);
        let s = n(39290),
          i = n(42120);
        class a {
          name;
          constructor(e) {
            (0, s.defineProperties)(this, { name: e });
          }
          clone() {
            return new a(this.name);
          }
        }
        t.NetworkPlugin = a;
        class o extends a {
          effectiveBlock;
          txBase;
          txCreate;
          txDataZero;
          txDataNonzero;
          txAccessListStorageKey;
          txAccessListAddress;
          constructor(e, t) {
            null == e && (e = 0),
              super(`org.ethers.network.plugins.GasCost#${e || 0}`);
            let n = { effectiveBlock: e };
            function a(e, s) {
              let a = (t || {})[e];
              null == a && (a = s),
                (0, i.assertArgument)(
                  "number" == typeof a,
                  `invalud value for ${e}`,
                  "costs",
                  t
                ),
                (n[e] = a);
            }
            a("txBase", 21e3),
              a("txCreate", 32e3),
              a("txDataZero", 4),
              a("txDataNonzero", 16),
              a("txAccessListStorageKey", 1900),
              a("txAccessListAddress", 2400),
              (0, s.defineProperties)(this, n);
          }
          clone() {
            return new o(this.effectiveBlock, this);
          }
        }
        t.GasCostPlugin = o;
        class l extends a {
          address;
          targetNetwork;
          constructor(e, t) {
            super("org.ethers.plugins.network.Ens"),
              (0, s.defineProperties)(this, {
                address: e || "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
                targetNetwork: null == t ? 1 : t,
              });
          }
          clone() {
            return new l(this.address, this.targetNetwork);
          }
        }
        t.EnsPlugin = l;
        class u extends a {
          #en;
          get feeDataFunc() {
            return this.#en;
          }
          constructor(e) {
            super("org.ethers.plugins.network.FeeData"), (this.#en = e);
          }
          async getFeeData(e) {
            return await this.#en(e);
          }
          clone() {
            return new u(this.#en);
          }
        }
        t.FeeDataNetworkPlugin = u;
        class c extends a {
          #es;
          #ei;
          get url() {
            return this.#es;
          }
          get processFunc() {
            return this.#ei;
          }
          constructor(e, t) {
            super("org.ethers.plugins.network.FetchUrlFeeDataPlugin"),
              (this.#es = e),
              (this.#ei = t);
          }
          clone() {
            return this;
          }
        }
        t.FetchUrlFeeDataNetworkPlugin = c;
      },
      23815: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AlchemyProvider = void 0);
        let s = n(42120),
          i = n(32813),
          a = n(54837),
          o = n(32013),
          l = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
        class u extends o.JsonRpcProvider {
          apiKey;
          constructor(e, t) {
            null == e && (e = "mainnet");
            let n = a.Network.from(e);
            null == t && (t = l),
              super(u.getRequest(n, t), n, { staticNetwork: n }),
              (0, s.defineProperties)(this, { apiKey: t });
          }
          _getProvider(e) {
            try {
              return new u(e, this.apiKey);
            } catch (e) {}
            return super._getProvider(e);
          }
          async _perform(e) {
            if ("getTransactionResult" === e.method) {
              let t;
              let { trace: n, tx: i } = await (0, s.resolveProperties)({
                trace: this.send("trace_transaction", [e.hash]),
                tx: this.getTransaction(e.hash),
              });
              if (null == n || null == i) return null;
              let a = !1;
              try {
                (t = n[0].result.output), (a = "Reverted" === n[0].error);
              } catch (e) {}
              if (t)
                return (
                  (0, s.assert)(
                    !a,
                    "an error occurred during transaction executions",
                    "CALL_EXCEPTION",
                    {
                      action: "getTransactionResult",
                      data: t,
                      reason: null,
                      transaction: i,
                      invocation: null,
                      revert: null,
                    }
                  ),
                  t
                );
              (0, s.assert)(!1, "could not parse trace result", "BAD_DATA", {
                value: n,
              });
            }
            return await super._perform(e);
          }
          isCommunityResource() {
            return this.apiKey === l;
          }
          static getRequest(e, t) {
            null == t && (t = l);
            let n = new s.FetchRequest(
              `https://${(function (e) {
                switch (e) {
                  case "mainnet":
                    return "eth-mainnet.alchemyapi.io";
                  case "goerli":
                    return "eth-goerli.g.alchemy.com";
                  case "sepolia":
                    return "eth-sepolia.g.alchemy.com";
                  case "arbitrum":
                    return "arb-mainnet.g.alchemy.com";
                  case "arbitrum-goerli":
                    return "arb-goerli.g.alchemy.com";
                  case "arbitrum-sepolia":
                    return "arb-sepolia.g.alchemy.com";
                  case "base":
                    return "base-mainnet.g.alchemy.com";
                  case "base-goerli":
                    return "base-goerli.g.alchemy.com";
                  case "base-sepolia":
                    return "base-sepolia.g.alchemy.com";
                  case "matic":
                    return "polygon-mainnet.g.alchemy.com";
                  case "matic-amoy":
                    return "polygon-amoy.g.alchemy.com";
                  case "matic-mumbai":
                    return "polygon-mumbai.g.alchemy.com";
                  case "optimism":
                    return "opt-mainnet.g.alchemy.com";
                  case "optimism-goerli":
                    return "opt-goerli.g.alchemy.com";
                  case "optimism-sepolia":
                    return "opt-sepolia.g.alchemy.com";
                }
                (0, s.assertArgument)(!1, "unsupported network", "network", e);
              })(e.name)}/v2/${t}`
            );
            return (
              (n.allowGzip = !0),
              t === l &&
                (n.retryFunc = async (e, t, n) => (
                  (0, i.showThrottleMessage)("alchemy"), !0
                )),
              n
            );
          }
        }
        t.AlchemyProvider = u;
      },
      16791: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AnkrProvider = void 0);
        let s = n(42120),
          i = n(32813),
          a = n(54837),
          o = n(32013),
          l =
            "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
        class u extends o.JsonRpcProvider {
          apiKey;
          constructor(e, t) {
            null == e && (e = "mainnet");
            let n = a.Network.from(e);
            null == t && (t = l),
              super(u.getRequest(n, t), n, { polling: !0, staticNetwork: n }),
              (0, s.defineProperties)(this, { apiKey: t });
          }
          _getProvider(e) {
            try {
              return new u(e, this.apiKey);
            } catch (e) {}
            return super._getProvider(e);
          }
          static getRequest(e, t) {
            null == t && (t = l);
            let n = new s.FetchRequest(
              `https://${(function (e) {
                switch (e) {
                  case "mainnet":
                    return "rpc.ankr.com/eth";
                  case "goerli":
                    return "rpc.ankr.com/eth_goerli";
                  case "sepolia":
                    return "rpc.ankr.com/eth_sepolia";
                  case "arbitrum":
                    return "rpc.ankr.com/arbitrum";
                  case "base":
                    return "rpc.ankr.com/base";
                  case "base-goerli":
                    return "rpc.ankr.com/base_goerli";
                  case "base-sepolia":
                    return "rpc.ankr.com/base_sepolia";
                  case "bnb":
                    return "rpc.ankr.com/bsc";
                  case "bnbt":
                    return "rpc.ankr.com/bsc_testnet_chapel";
                  case "matic":
                    return "rpc.ankr.com/polygon";
                  case "matic-mumbai":
                    return "rpc.ankr.com/polygon_mumbai";
                  case "optimism":
                    return "rpc.ankr.com/optimism";
                  case "optimism-goerli":
                    return "rpc.ankr.com/optimism_testnet";
                  case "optimism-sepolia":
                    return "rpc.ankr.com/optimism_sepolia";
                }
                (0, s.assertArgument)(!1, "unsupported network", "network", e);
              })(e.name)}/${t}`
            );
            return (
              (n.allowGzip = !0),
              t === l &&
                (n.retryFunc = async (e, t, n) => (
                  (0, i.showThrottleMessage)("AnkrProvider"), !0
                )),
              n
            );
          }
          getRpcError(e, t) {
            return (
              "eth_sendRawTransaction" === e.method &&
                t &&
                t.error &&
                "INTERNAL_ERROR: could not replace existing tx" ===
                  t.error.message &&
                (t.error.message = "replacement transaction underpriced"),
              super.getRpcError(e, t)
            );
          }
          isCommunityResource() {
            return this.apiKey === l;
          }
        }
        t.AnkrProvider = u;
      },
      30292: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BrowserProvider = void 0);
        let s = n(42120),
          i = n(32013);
        class a extends i.JsonRpcApiPollingProvider {
          #ea;
          constructor(e, t, n) {
            let i = Object.assign({}, null != n ? n : {}, { batchMaxCount: 1 });
            (0, s.assertArgument)(
              e && e.request,
              "invalid EIP-1193 provider",
              "ethereum",
              e
            ),
              super(t, i),
              (this.#ea = async (t, n) => {
                let s = { method: t, params: n };
                this.emit("debug", {
                  action: "sendEip1193Request",
                  payload: s,
                });
                try {
                  let t = await e.request(s);
                  return (
                    this.emit("debug", {
                      action: "receiveEip1193Result",
                      result: t,
                    }),
                    t
                  );
                } catch (t) {
                  let e = Error(t.message);
                  throw (
                    ((e.code = t.code),
                    (e.data = t.data),
                    (e.payload = s),
                    this.emit("debug", {
                      action: "receiveEip1193Error",
                      error: e,
                    }),
                    e)
                  );
                }
              });
          }
          async send(e, t) {
            return await this._start(), await super.send(e, t);
          }
          async _send(e) {
            (0, s.assertArgument)(
              !Array.isArray(e),
              "EIP-1193 does not support batch request",
              "payload",
              e
            );
            try {
              let t = await this.#ea(e.method, e.params || []);
              return [{ id: e.id, result: t }];
            } catch (t) {
              return [
                {
                  id: e.id,
                  error: { code: t.code, data: t.data, message: t.message },
                },
              ];
            }
          }
          getRpcError(e, t) {
            switch ((t = JSON.parse(JSON.stringify(t))).error.code || -1) {
              case 4001:
                t.error.message = `ethers-user-denied: ${t.error.message}`;
                break;
              case 4200:
                t.error.message = `ethers-unsupported: ${t.error.message}`;
            }
            return super.getRpcError(e, t);
          }
          async hasSigner(e) {
            null == e && (e = 0);
            let t = await this.send("eth_accounts", []);
            return "number" == typeof e
              ? t.length > e
              : ((e = e.toLowerCase()),
                0 !== t.filter((t) => t.toLowerCase() === e).length);
          }
          async getSigner(e) {
            if ((null == e && (e = 0), !(await this.hasSigner(e))))
              try {
                await this.#ea("eth_requestAccounts", []);
              } catch (t) {
                let e = t.payload;
                throw this.getRpcError(e, { id: e.id, error: t });
              }
            return await super.getSigner(e);
          }
        }
        t.BrowserProvider = a;
      },
      60085: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ChainstackProvider = void 0);
        let s = n(42120),
          i = n(32813),
          a = n(54837),
          o = n(32013);
        function l(e) {
          switch (e) {
            case "mainnet":
              return "39f1d67cedf8b7831010a665328c9197";
            case "arbitrum":
              return "0550c209db33c3abf4cc927e1e18cea1";
            case "bnb":
              return "98b5a77e531614387366f6fc5da097f8";
            case "matic":
              return "cd9d4d70377471aa7c142ec4a4205249";
          }
          (0, s.assertArgument)(!1, "unsupported network", "network", e);
        }
        class u extends o.JsonRpcProvider {
          apiKey;
          constructor(e, t) {
            null == e && (e = "mainnet");
            let n = a.Network.from(e);
            null == t && (t = l(n.name)),
              super(u.getRequest(n, t), n, { staticNetwork: n }),
              (0, s.defineProperties)(this, { apiKey: t });
          }
          _getProvider(e) {
            try {
              return new u(e, this.apiKey);
            } catch (e) {}
            return super._getProvider(e);
          }
          isCommunityResource() {
            return this.apiKey === l(this._network.name);
          }
          static getRequest(e, t) {
            null == t && (t = l(e.name));
            let n = new s.FetchRequest(
              `https://${(function (e) {
                switch (e) {
                  case "mainnet":
                    return "ethereum-mainnet.core.chainstack.com";
                  case "arbitrum":
                    return "arbitrum-mainnet.core.chainstack.com";
                  case "bnb":
                    return "bsc-mainnet.core.chainstack.com";
                  case "matic":
                    return "polygon-mainnet.core.chainstack.com";
                }
                (0, s.assertArgument)(!1, "unsupported network", "network", e);
              })(e.name)}/${t}`
            );
            return (
              (n.allowGzip = !0),
              t === l(e.name) &&
                (n.retryFunc = async (e, t, n) => (
                  (0, i.showThrottleMessage)("ChainstackProvider"), !0
                )),
              n
            );
          }
        }
        t.ChainstackProvider = u;
      },
      3377: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CloudflareProvider = void 0);
        let s = n(42120),
          i = n(54837),
          a = n(32013);
        class o extends a.JsonRpcProvider {
          constructor(e) {
            null == e && (e = "mainnet");
            let t = i.Network.from(e);
            (0, s.assertArgument)(
              "mainnet" === t.name,
              "unsupported network",
              "network",
              e
            ),
              super("https://cloudflare-eth.com/", t, { staticNetwork: t });
          }
        }
        t.CloudflareProvider = o;
      },
      22880: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EtherscanProvider = t.EtherscanPlugin = void 0);
        let s = n(93707),
          i = n(37252),
          a = n(2290),
          o = n(42120),
          l = n(55142),
          u = n(54837),
          c = n(67004),
          d = n(32813),
          h = "org.ethers.plugins.provider.Etherscan";
        class p extends c.NetworkPlugin {
          baseUrl;
          constructor(e) {
            super(h), (0, o.defineProperties)(this, { baseUrl: e });
          }
          clone() {
            return new p(this.baseUrl);
          }
        }
        t.EtherscanPlugin = p;
        let f = ["enableCcipRead"],
          g = 1;
        class m extends l.AbstractProvider {
          network;
          apiKey;
          #eo;
          constructor(e, t) {
            super();
            let n = u.Network.from(e);
            (this.#eo = n.getPlugin(h)),
              (0, o.defineProperties)(this, {
                apiKey: null != t ? t : null,
                network: n,
              }),
              this.getBaseUrl();
          }
          getBaseUrl() {
            if (this.#eo) return this.#eo.baseUrl;
            switch (this.network.name) {
              case "mainnet":
                return "https://api.etherscan.io";
              case "goerli":
                return "https://api-goerli.etherscan.io";
              case "sepolia":
                return "https://api-sepolia.etherscan.io";
              case "holesky":
                return "https://api-holesky.etherscan.io";
              case "arbitrum":
                return "https://api.arbiscan.io";
              case "arbitrum-goerli":
                return "https://api-goerli.arbiscan.io";
              case "base":
                return "https://api.basescan.org";
              case "base-sepolia":
                return "https://api-sepolia.basescan.org";
              case "bnb":
                return "https://api.bscscan.com";
              case "bnbt":
                return "https://api-testnet.bscscan.com";
              case "matic":
                return "https://api.polygonscan.com";
              case "matic-amoy":
                return "https://api-amoy.polygonscan.com";
              case "matic-mumbai":
                return "https://api-testnet.polygonscan.com";
              case "optimism":
                return "https://api-optimistic.etherscan.io";
              case "optimism-goerli":
                return "https://api-goerli-optimistic.etherscan.io";
            }
            (0, o.assertArgument)(
              !1,
              "unsupported network",
              "network",
              this.network
            );
          }
          getUrl(e, t) {
            let n = Object.keys(t).reduce((e, n) => {
                let s = t[n];
                return null != s && (e += `&${n}=${s}`), e;
              }, ""),
              s = this.apiKey ? `&apikey=${this.apiKey}` : "";
            return `${this.getBaseUrl()}/api?module=${e}${n}${s}`;
          }
          getPostUrl() {
            return `${this.getBaseUrl()}/api`;
          }
          getPostData(e, t) {
            return (t.module = e), (t.apikey = this.apiKey), t;
          }
          async detectNetwork() {
            return this.network;
          }
          async fetch(e, t, n) {
            let s = g++,
              i = n ? this.getPostUrl() : this.getUrl(e, t),
              a = n ? this.getPostData(e, t) : null;
            this.emit("debug", {
              action: "sendRequest",
              id: s,
              url: i,
              payload: a,
            });
            let l = new o.FetchRequest(i);
            l.setThrottleParams({ slotInterval: 1e3 }),
              (l.retryFunc = (e, t, n) => (
                this.isCommunityResource() &&
                  (0, d.showThrottleMessage)("Etherscan"),
                Promise.resolve(!0)
              )),
              (l.processFunc = async (t, n) => {
                let i = n.hasBody()
                    ? JSON.parse((0, o.toUtf8String)(n.body))
                    : {},
                  a =
                    ("string" == typeof i.result ? i.result : "")
                      .toLowerCase()
                      .indexOf("rate limit") >= 0;
                return (
                  "proxy" === e
                    ? i &&
                      0 == i.status &&
                      "NOTOK" == i.message &&
                      a &&
                      (this.emit("debug", {
                        action: "receiveError",
                        id: s,
                        reason: "proxy-NOTOK",
                        error: i,
                      }),
                      n.throwThrottleError(i.result, 2e3))
                    : a &&
                      (this.emit("debug", {
                        action: "receiveError",
                        id: s,
                        reason: "null result",
                        error: i.result,
                      }),
                      n.throwThrottleError(i.result, 2e3)),
                  n
                );
              }),
              a &&
                (l.setHeader(
                  "content-type",
                  "application/x-www-form-urlencoded; charset=UTF-8"
                ),
                (l.body = Object.keys(a)
                  .map((e) => `${e}=${a[e]}`)
                  .join("&")));
            let u = await l.send();
            try {
              u.assertOk();
            } catch (e) {
              this.emit("debug", {
                action: "receiveError",
                id: s,
                error: e,
                reason: "assertOk",
              }),
                (0, o.assert)(!1, "response error", "SERVER_ERROR", {
                  request: l,
                  response: u,
                });
            }
            u.hasBody() ||
              (this.emit("debug", {
                action: "receiveError",
                id: s,
                error: "missing body",
                reason: "null body",
              }),
              (0, o.assert)(!1, "missing response", "SERVER_ERROR", {
                request: l,
                response: u,
              }));
            let c = JSON.parse((0, o.toUtf8String)(u.body));
            return (
              "proxy" === e
                ? ("2.0" != c.jsonrpc &&
                    (this.emit("debug", {
                      action: "receiveError",
                      id: s,
                      result: c,
                      reason: "invalid JSON-RPC",
                    }),
                    (0, o.assert)(
                      !1,
                      "invalid JSON-RPC response (missing jsonrpc='2.0')",
                      "SERVER_ERROR",
                      { request: l, response: u, info: { result: c } }
                    )),
                  c.error &&
                    (this.emit("debug", {
                      action: "receiveError",
                      id: s,
                      result: c,
                      reason: "JSON-RPC error",
                    }),
                    (0, o.assert)(!1, "error response", "SERVER_ERROR", {
                      request: l,
                      response: u,
                      info: { result: c },
                    })))
                : (0 == c.status &&
                    ("No records found" === c.message ||
                      "No transactions found" === c.message)) ||
                  (1 == c.status &&
                    ("string" != typeof c.message || c.message.match(/^OK/))) ||
                  (this.emit("debug", {
                    action: "receiveError",
                    id: s,
                    result: c,
                  }),
                  (0, o.assert)(!1, "error response", "SERVER_ERROR", {
                    request: l,
                    response: u,
                    info: { result: c },
                  })),
              this.emit("debug", {
                action: "receiveRequest",
                id: s,
                result: c,
              }),
              c.result
            );
          }
          _getTransactionPostData(e) {
            let t = {};
            for (let n in e) {
              if (f.indexOf(n) >= 0 || null == e[n]) continue;
              let s = e[n];
              if (
                ("type" !== n || 0 !== s) &&
                ("blockTag" !== n || "latest" !== s)
              ) {
                if (
                  {
                    type: !0,
                    gasLimit: !0,
                    gasPrice: !0,
                    maxFeePerGs: !0,
                    maxPriorityFeePerGas: !0,
                    nonce: !0,
                    value: !0,
                  }[n]
                )
                  s = (0, o.toQuantity)(s);
                else if ("accessList" === n)
                  s =
                    "[" +
                    (0, a.accessListify)(s)
                      .map(
                        (e) =>
                          `{address:"${
                            e.address
                          }",storageKeys:["${e.storageKeys.join('","')}"]}`
                      )
                      .join(",") +
                    "]";
                else if ("blobVersionedHashes" === n) {
                  if (0 === s.length) continue;
                  (0, o.assert)(
                    !1,
                    "Etherscan API does not support blobVersionedHashes",
                    "UNSUPPORTED_OPERATION",
                    {
                      operation: "_getTransactionPostData",
                      info: { transaction: e },
                    }
                  );
                } else s = (0, o.hexlify)(s);
                t[n] = s;
              }
            }
            return t;
          }
          _checkError(e, t, n) {
            let i = "";
            if ((0, o.isError)(t, "SERVER_ERROR")) {
              try {
                i = t.info.result.error.message;
              } catch (e) {}
              if (!i)
                try {
                  i = t.info.message;
                } catch (e) {}
            }
            if (
              ("estimateGas" === e.method &&
                !i.match(/revert/i) &&
                i.match(/insufficient funds/i) &&
                (0, o.assert)(!1, "insufficient funds", "INSUFFICIENT_FUNDS", {
                  transaction: e.transaction,
                }),
              ("call" === e.method || "estimateGas" === e.method) &&
                i.match(/execution reverted/i))
            ) {
              let n = "";
              try {
                n = t.info.result.error.data;
              } catch (e) {}
              let i = s.AbiCoder.getBuiltinCallException(
                e.method,
                e.transaction,
                n
              );
              throw ((i.info = { request: e, error: t }), i);
            }
            if (i && "broadcastTransaction" === e.method) {
              let t = a.Transaction.from(e.signedTransaction);
              i.match(/replacement/i) &&
                i.match(/underpriced/i) &&
                (0, o.assert)(
                  !1,
                  "replacement fee too low",
                  "REPLACEMENT_UNDERPRICED",
                  { transaction: t }
                ),
                i.match(/insufficient funds/) &&
                  (0, o.assert)(
                    !1,
                    "insufficient funds for intrinsic transaction cost",
                    "INSUFFICIENT_FUNDS",
                    { transaction: t }
                  ),
                i.match(
                  /same hash was already imported|transaction nonce is too low|nonce too low/
                ) &&
                  (0, o.assert)(
                    !1,
                    "nonce has already been used",
                    "NONCE_EXPIRED",
                    { transaction: t }
                  );
            }
            throw t;
          }
          async _detectNetwork() {
            return this.network;
          }
          async _perform(e) {
            switch (e.method) {
              case "chainId":
                return this.network.chainId;
              case "getBlockNumber":
                return this.fetch("proxy", { action: "eth_blockNumber" });
              case "getGasPrice":
                return this.fetch("proxy", { action: "eth_gasPrice" });
              case "getPriorityFee":
                if ("mainnet" === this.network.name) return "1000000000";
                if ("optimism" === this.network.name) return "1000000";
                throw Error("fallback onto the AbstractProvider default");
              case "getBalance":
                return this.fetch("account", {
                  action: "balance",
                  address: e.address,
                  tag: e.blockTag,
                });
              case "getTransactionCount":
                return this.fetch("proxy", {
                  action: "eth_getTransactionCount",
                  address: e.address,
                  tag: e.blockTag,
                });
              case "getCode":
                return this.fetch("proxy", {
                  action: "eth_getCode",
                  address: e.address,
                  tag: e.blockTag,
                });
              case "getStorage":
                return this.fetch("proxy", {
                  action: "eth_getStorageAt",
                  address: e.address,
                  position: e.position,
                  tag: e.blockTag,
                });
              case "broadcastTransaction":
                return this.fetch(
                  "proxy",
                  {
                    action: "eth_sendRawTransaction",
                    hex: e.signedTransaction,
                  },
                  !0
                ).catch((t) => this._checkError(e, t, e.signedTransaction));
              case "getBlock":
                if ("blockTag" in e)
                  return this.fetch("proxy", {
                    action: "eth_getBlockByNumber",
                    tag: e.blockTag,
                    boolean: e.includeTransactions ? "true" : "false",
                  });
                (0, o.assert)(
                  !1,
                  "getBlock by blockHash not supported by Etherscan",
                  "UNSUPPORTED_OPERATION",
                  { operation: "getBlock(blockHash)" }
                );
              case "getTransaction":
                return this.fetch("proxy", {
                  action: "eth_getTransactionByHash",
                  txhash: e.hash,
                });
              case "getTransactionReceipt":
                return this.fetch("proxy", {
                  action: "eth_getTransactionReceipt",
                  txhash: e.hash,
                });
              case "call": {
                if ("latest" !== e.blockTag)
                  throw Error(
                    "EtherscanProvider does not support blockTag for call"
                  );
                let t = this._getTransactionPostData(e.transaction);
                (t.module = "proxy"), (t.action = "eth_call");
                try {
                  return await this.fetch("proxy", t, !0);
                } catch (t) {
                  return this._checkError(e, t, e.transaction);
                }
              }
              case "estimateGas": {
                let t = this._getTransactionPostData(e.transaction);
                (t.module = "proxy"), (t.action = "eth_estimateGas");
                try {
                  return await this.fetch("proxy", t, !0);
                } catch (t) {
                  return this._checkError(e, t, e.transaction);
                }
              }
            }
            return super._perform(e);
          }
          async getNetwork() {
            return this.network;
          }
          async getEtherPrice() {
            return "mainnet" !== this.network.name
              ? 0
              : parseFloat(
                  (await this.fetch("stats", { action: "ethprice" })).ethusd
                );
          }
          async getContract(e) {
            var t;
            let n = this._getAddress(e);
            (t = n) && "function" == typeof t.then && (n = await n);
            try {
              let e = await this.fetch("contract", {
                  action: "getabi",
                  address: n,
                }),
                t = JSON.parse(e);
              return new i.Contract(n, t, this);
            } catch (e) {
              return null;
            }
          }
          isCommunityResource() {
            return null == this.apiKey;
          }
        }
        t.EtherscanProvider = m;
      },
      24129: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FallbackProvider = void 0);
        let s = n(42120),
          i = n(55142),
          a = n(54837),
          o = BigInt("1"),
          l = BigInt("2");
        function u() {
          return new Date().getTime();
        }
        function c(e) {
          return JSON.stringify(e, (e, t) =>
            "bigint" == typeof t ? { type: "bigint", value: t.toString() } : t
          );
        }
        let d = { stallTimeout: 400, priority: 1, weight: 1 },
          h = {
            blockNumber: -2,
            requests: 0,
            lateResponses: 0,
            errorResponses: 0,
            outOfSync: -1,
            unsupportedEvents: 0,
            rollingDuration: 0,
            score: 0,
            _network: null,
            _updateNumber: null,
            _totalTime: 0,
            _lastFatalError: null,
            _lastFatalErrorTimestamp: 0,
          };
        async function p(e, t) {
          for (
            ;
            (e.blockNumber < 0 || e.blockNumber < t) &&
            (e._updateNumber ||
              (e._updateNumber = (async () => {
                try {
                  let t = await e.provider.getBlockNumber();
                  t > e.blockNumber && (e.blockNumber = t);
                } catch (t) {
                  (e.blockNumber = -2),
                    (e._lastFatalError = t),
                    (e._lastFatalErrorTimestamp = u());
                }
                e._updateNumber = null;
              })()),
            await e._updateNumber,
            e.outOfSync++,
            !e._lastFatalError);

          );
        }
        function f(e) {
          if (null == e) return "null";
          if (Array.isArray(e)) return "[" + e.map(f).join(",") + "]";
          if ("object" == typeof e && "function" == typeof e.toJSON)
            return f(e.toJSON());
          switch (typeof e) {
            case "boolean":
            case "symbol":
              return e.toString();
            case "bigint":
            case "number":
              return BigInt(e).toString();
            case "string":
              return JSON.stringify(e);
            case "object": {
              let t = Object.keys(e);
              return (
                t.sort(),
                "{" +
                  t.map((t) => `${JSON.stringify(t)}:${f(e[t])}`).join(",") +
                  "}"
              );
            }
          }
          throw (console.log("Could not serialize", e), Error("Hmm..."));
        }
        function g(e) {
          if ("error" in e) {
            let t = e.error;
            return { tag: f(t), value: t };
          }
          let t = e.result;
          return { tag: f(t), value: t };
        }
        function m(e, t) {
          let n = new Map();
          for (let { value: e, tag: s, weight: i } of t) {
            let t = n.get(s) || { value: e, weight: 0 };
            (t.weight += i), n.set(s, t);
          }
          let s = null;
          for (let t of n.values())
            t.weight >= e && (!s || t.weight > s.weight) && (s = t);
          if (s) return s.value;
        }
        function y(e, t) {
          let n = 0,
            s = new Map(),
            i = null,
            a = [];
          for (let { value: e, tag: o, weight: l } of t)
            if (e instanceof Error) {
              let t = s.get(o) || { value: e, weight: 0 };
              (t.weight += l),
                s.set(o, t),
                (null == i || t.weight > i.weight) && (i = t);
            } else a.push(BigInt(e)), (n += l);
          if (n < e) return i && i.weight >= e ? i.value : void 0;
          a.sort((e, t) => (e < t ? -1 : t > e ? 1 : 0));
          let u = Math.floor(a.length / 2);
          return a.length % 2 ? a[u] : (a[u - 1] + a[u] + o) / l;
        }
        function b(e, t) {
          let n = m(e, t);
          if (void 0 !== n) return n;
          for (let e of t) if (e.value) return e.value;
        }
        class A extends i.AbstractProvider {
          quorum;
          eventQuorum;
          eventWorkers;
          #el;
          #eu;
          #ec;
          constructor(e, t, n) {
            super(t, n),
              (this.#el = e.map((e) =>
                e instanceof i.AbstractProvider
                  ? Object.assign({ provider: e }, d, h)
                  : Object.assign({}, d, e, h)
              )),
              (this.#eu = -2),
              (this.#ec = null),
              n && null != n.quorum
                ? (this.quorum = n.quorum)
                : (this.quorum = Math.ceil(
                    this.#el.reduce((e, t) => (e += t.weight), 0) / 2
                  )),
              (this.eventQuorum = 1),
              (this.eventWorkers = 1),
              (0, s.assertArgument)(
                this.quorum <= this.#el.reduce((e, t) => e + t.weight, 0),
                "quorum exceed provider weight",
                "quorum",
                this.quorum
              );
          }
          get providerConfigs() {
            return this.#el.map((e) => {
              let t = Object.assign({}, e);
              for (let e in t) "_" === e[0] && delete t[e];
              return t;
            });
          }
          async _detectNetwork() {
            return a.Network.from(
              (0, s.getBigInt)(await this._perform({ method: "chainId" }))
            );
          }
          async _translatePerform(e, t) {
            switch (t.method) {
              case "broadcastTransaction":
                return await e.broadcastTransaction(t.signedTransaction);
              case "call":
                return await e.call(
                  Object.assign({}, t.transaction, { blockTag: t.blockTag })
                );
              case "chainId":
                return (await e.getNetwork()).chainId;
              case "estimateGas":
                return await e.estimateGas(t.transaction);
              case "getBalance":
                return await e.getBalance(t.address, t.blockTag);
              case "getBlock": {
                let n = "blockHash" in t ? t.blockHash : t.blockTag;
                return await e.getBlock(n, t.includeTransactions);
              }
              case "getBlockNumber":
                return await e.getBlockNumber();
              case "getCode":
                return await e.getCode(t.address, t.blockTag);
              case "getGasPrice":
                return (await e.getFeeData()).gasPrice;
              case "getPriorityFee":
                return (await e.getFeeData()).maxPriorityFeePerGas;
              case "getLogs":
                return await e.getLogs(t.filter);
              case "getStorage":
                return await e.getStorage(t.address, t.position, t.blockTag);
              case "getTransaction":
                return await e.getTransaction(t.hash);
              case "getTransactionCount":
                return await e.getTransactionCount(t.address, t.blockTag);
              case "getTransactionReceipt":
                return await e.getTransactionReceipt(t.hash);
              case "getTransactionResult":
                return await e.getTransactionResult(t.hash);
            }
          }
          #ed(e) {
            let t = Array.from(e).map((e) => e.config),
              n = this.#el.slice();
            for (let e of ((function (e) {
              for (let t = e.length - 1; t > 0; t--) {
                let n = Math.floor(Math.random() * (t + 1)),
                  s = e[t];
                (e[t] = e[n]), (e[n] = s);
              }
            })(n),
            n.sort((e, t) => e.priority - t.priority),
            n))
              if (!e._lastFatalError && -1 === t.indexOf(e)) return e;
            return null;
          }
          #eh(e, t) {
            let n = this.#ed(e);
            if (null == n) return null;
            let s = {
                config: n,
                result: null,
                didBump: !1,
                perform: null,
                staller: null,
              },
              i = u();
            return (
              (s.perform = (async () => {
                try {
                  n.requests++;
                  let e = await this._translatePerform(n.provider, t);
                  s.result = { result: e };
                } catch (e) {
                  n.errorResponses++, (s.result = { error: e });
                }
                let e = u() - i;
                (n._totalTime += e),
                  (n.rollingDuration = 0.95 * n.rollingDuration + 0.05 * e),
                  (s.perform = null);
              })()),
              (s.staller = (async () => {
                var e;
                await ((e = n.stallTimeout),
                new Promise((t) => {
                  setTimeout(t, e);
                })),
                  (s.staller = null);
              })()),
              e.add(s),
              s
            );
          }
          async #ep() {
            let e = this.#ec;
            if (!e) {
              let t = [];
              this.#el.forEach((e) => {
                t.push(
                  (async () => {
                    await p(e, 0),
                      e._lastFatalError ||
                        (e._network = await e.provider.getNetwork());
                  })()
                );
              }),
                (this.#ec = e =
                  (async () => {
                    await Promise.all(t);
                    let e = null;
                    for (let t of this.#el) {
                      if (t._lastFatalError) continue;
                      let n = t._network;
                      null == e
                        ? (e = n.chainId)
                        : n.chainId !== e &&
                          (0, s.assert)(
                            !1,
                            "cannot mix providers on different networks",
                            "UNSUPPORTED_OPERATION",
                            { operation: "new FallbackProvider" }
                          );
                    }
                  })());
            }
            await e;
          }
          async #ef(e, t) {
            let n = [];
            for (let t of e)
              if (null != t.result) {
                let { tag: e, value: s } = g(t.result);
                n.push({ tag: e, value: s, weight: t.config.weight });
              }
            if (!(n.reduce((e, t) => e + t.weight, 0) < this.quorum)) {
              switch (t.method) {
                case "getBlockNumber": {
                  -2 === this.#eu &&
                    (this.#eu = Math.ceil(
                      (0, s.getNumber)(
                        y(
                          this.quorum,
                          this.#el
                            .filter((e) => !e._lastFatalError)
                            .map((e) => ({
                              value: e.blockNumber,
                              tag: (0, s.getNumber)(e.blockNumber).toString(),
                              weight: e.weight,
                            }))
                        )
                      )
                    ));
                  let e = (function (e, t) {
                    let n;
                    if (1 === e) return (0, s.getNumber)(y(e, t), "%internal");
                    let i = new Map(),
                      a = (e, t) => {
                        let n = i.get(e) || { result: e, weight: 0 };
                        (n.weight += t), i.set(e, n);
                      };
                    for (let { weight: e, value: n } of t) {
                      let t = (0, s.getNumber)(n);
                      a(t - 1, e), a(t, e), a(t + 1, e);
                    }
                    let o = 0;
                    for (let { weight: t, result: s } of i.values())
                      t >= e &&
                        (t > o || (null != n && t === o && s > n)) &&
                        ((o = t), (n = s));
                    return n;
                  })(this.quorum, n);
                  if (void 0 === e) return;
                  return e > this.#eu && (this.#eu = e), this.#eu;
                }
                case "getGasPrice":
                case "getPriorityFee":
                case "estimateGas":
                  return y(this.quorum, n);
                case "getBlock":
                  if ("blockTag" in t && "pending" === t.blockTag)
                    return b(this.quorum, n);
                  return m(this.quorum, n);
                case "call":
                case "chainId":
                case "getBalance":
                case "getTransactionCount":
                case "getCode":
                case "getStorage":
                case "getTransaction":
                case "getTransactionReceipt":
                case "getLogs":
                  return m(this.quorum, n);
                case "broadcastTransaction":
                  return b(this.quorum, n);
              }
              (0, s.assert)(!1, "unsupported method", "UNSUPPORTED_OPERATION", {
                operation: `_perform(${c(t.method)})`,
              });
            }
          }
          async #eg(e, t) {
            if (0 === e.size) throw Error("no runners?!");
            let n = [],
              i = 0;
            for (let t of e) {
              if ((t.perform && n.push(t.perform), t.staller)) {
                n.push(t.staller);
                continue;
              }
              !t.didBump && ((t.didBump = !0), i++);
            }
            let a = await this.#ef(e, t);
            if (void 0 !== a) {
              if (a instanceof Error) throw a;
              return a;
            }
            for (let n = 0; n < i; n++) this.#eh(e, t);
            return (
              (0, s.assert)(n.length > 0, "quorum not met", "SERVER_ERROR", {
                request: "%sub-requests",
                info: {
                  request: t,
                  results: Array.from(e).map((e) => c(e.result)),
                },
              }),
              await Promise.race(n),
              await this.#eg(e, t)
            );
          }
          async _perform(e) {
            if ("broadcastTransaction" === e.method) {
              let t = this.#el.map((e) => null),
                n = this.#el.map(async ({ provider: n, weight: s }, i) => {
                  try {
                    let a = await n._perform(e);
                    t[i] = Object.assign(g({ result: a }), { weight: s });
                  } catch (e) {
                    t[i] = Object.assign(g({ error: e }), { weight: s });
                  }
                });
              for (;;) {
                for (let { value: e } of t.filter((e) => null != e))
                  if (!(e instanceof Error)) return e;
                let e = m(
                  this.quorum,
                  t.filter((e) => null != e)
                );
                if ((0, s.isError)(e, "INSUFFICIENT_FUNDS")) throw e;
                let i = n.filter((e, n) => null == t[n]);
                if (0 === i.length) break;
                await Promise.race(i);
              }
              let i = b(this.quorum, t);
              if (
                ((0, s.assert)(
                  void 0 !== i,
                  "problem multi-broadcasting",
                  "SERVER_ERROR",
                  {
                    request: "%sub-requests",
                    info: { request: e, results: t.map(c) },
                  }
                ),
                i instanceof Error)
              )
                throw i;
              return i;
            }
            await this.#ep();
            let t = new Set(),
              n = 0;
            for (;;) {
              let s = this.#eh(t, e);
              if (null == s || (n += s.config.weight) >= this.quorum) break;
            }
            let i = await this.#eg(t, e);
            for (let e of t)
              e.perform && null == e.result && e.config.lateResponses++;
            return i;
          }
          async destroy() {
            for (let { provider: e } of this.#el) e.destroy();
            super.destroy();
          }
        }
        t.FallbackProvider = A;
      },
      35012: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.InfuraProvider = t.InfuraWebSocketProvider = void 0);
        let s = n(42120),
          i = n(32813),
          a = n(54837),
          o = n(32013),
          l = n(62196),
          u = "84842078b09946638c03157f83405213";
        class c extends l.WebSocketProvider {
          projectId;
          projectSecret;
          constructor(e, t) {
            let n = new d(e, t),
              i = n._getConnection();
            (0, s.assert)(
              !i.credentials,
              "INFURA WebSocket project secrets unsupported",
              "UNSUPPORTED_OPERATION",
              { operation: "InfuraProvider.getWebSocketProvider()" }
            ),
              super(
                i.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/"),
                n._network
              ),
              (0, s.defineProperties)(this, {
                projectId: n.projectId,
                projectSecret: n.projectSecret,
              });
          }
          isCommunityResource() {
            return this.projectId === u;
          }
        }
        t.InfuraWebSocketProvider = c;
        class d extends o.JsonRpcProvider {
          projectId;
          projectSecret;
          constructor(e, t, n) {
            null == e && (e = "mainnet");
            let i = a.Network.from(e);
            null == t && (t = u),
              null == n && (n = null),
              super(d.getRequest(i, t, n), i, { staticNetwork: i }),
              (0, s.defineProperties)(this, { projectId: t, projectSecret: n });
          }
          _getProvider(e) {
            try {
              return new d(e, this.projectId, this.projectSecret);
            } catch (e) {}
            return super._getProvider(e);
          }
          isCommunityResource() {
            return this.projectId === u;
          }
          static getWebSocketProvider(e, t) {
            return new c(e, t);
          }
          static getRequest(e, t, n) {
            null == t && (t = u), null == n && (n = null);
            let a = new s.FetchRequest(
              `https://${(function (e) {
                switch (e) {
                  case "mainnet":
                    return "mainnet.infura.io";
                  case "goerli":
                    return "goerli.infura.io";
                  case "sepolia":
                    return "sepolia.infura.io";
                  case "arbitrum":
                    return "arbitrum-mainnet.infura.io";
                  case "arbitrum-goerli":
                    return "arbitrum-goerli.infura.io";
                  case "arbitrum-sepolia":
                    return "arbitrum-sepolia.infura.io";
                  case "base":
                    return "base-mainnet.infura.io";
                  case "base-goerlia":
                    return "base-goerli.infura.io";
                  case "base-sepolia":
                    return "base-sepolia.infura.io";
                  case "bnb":
                    return "bnbsmartchain-mainnet.infura.io";
                  case "bnbt":
                    return "bnbsmartchain-testnet.infura.io";
                  case "linea":
                    return "linea-mainnet.infura.io";
                  case "linea-goerli":
                    return "linea-goerli.infura.io";
                  case "linea-sepolia":
                    return "linea-sepolia.infura.io";
                  case "matic":
                    return "polygon-mainnet.infura.io";
                  case "matic-amoy":
                    return "polygon-amoy.infura.io";
                  case "matic-mumbai":
                    return "polygon-mumbai.infura.io";
                  case "optimism":
                    return "optimism-mainnet.infura.io";
                  case "optimism-goerli":
                    return "optimism-goerli.infura.io";
                  case "optimism-sepolia":
                    return "optimism-sepolia.infura.io";
                }
                (0, s.assertArgument)(!1, "unsupported network", "network", e);
              })(e.name)}/v3/${t}`
            );
            return (
              (a.allowGzip = !0),
              n && a.setCredentials("", n),
              t === u &&
                (a.retryFunc = async (e, t, n) => (
                  (0, i.showThrottleMessage)("InfuraProvider"), !0
                )),
              a
            );
          }
        }
        t.InfuraProvider = d;
      },
      28306: function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.IpcSocketProvider = void 0),
          (t.IpcSocketProvider = void 0);
      },
      32013: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.JsonRpcProvider =
            t.JsonRpcApiPollingProvider =
            t.JsonRpcApiProvider =
            t.JsonRpcSigner =
              void 0);
        let s = n(93707),
          i = n(45475),
          a = n(62475),
          o = n(2290),
          l = n(42120),
          u = n(55142),
          c = n(35649),
          d = n(54837),
          h = n(21570),
          p = n(21097),
          f = "bigint,boolean,function,number,string,symbol".split(/,/g);
        function g(e) {
          if (
            null == e ||
            f.indexOf(typeof e) >= 0 ||
            "function" == typeof e.getAddress
          )
            return e;
          if (Array.isArray(e)) return e.map(g);
          if ("object" == typeof e)
            return Object.keys(e).reduce((t, n) => ((t[n] = e[n]), t), {});
          throw Error(`should not happen: ${e} (${typeof e})`);
        }
        function m(e) {
          return e ? e.toLowerCase() : e;
        }
        function y(e) {
          return e && "number" == typeof e.pollingInterval;
        }
        let b = {
          polling: !1,
          staticNetwork: null,
          batchStallTime: 10,
          batchMaxSize: 1048576,
          batchMaxCount: 100,
          cacheTimeout: 250,
          pollingInterval: 4e3,
        };
        class A extends c.AbstractSigner {
          address;
          constructor(e, t) {
            super(e),
              (t = (0, i.getAddress)(t)),
              (0, l.defineProperties)(this, { address: t });
          }
          connect(e) {
            (0, l.assert)(
              !1,
              "cannot reconnect JsonRpcSigner",
              "UNSUPPORTED_OPERATION",
              { operation: "signer.connect" }
            );
          }
          async getAddress() {
            return this.address;
          }
          async populateTransaction(e) {
            return await this.populateCall(e);
          }
          async sendUncheckedTransaction(e) {
            let t = g(e),
              n = [];
            if (t.from) {
              let s = t.from;
              n.push(
                (async () => {
                  let n = await (0, i.resolveAddress)(s, this.provider);
                  (0, l.assertArgument)(
                    null != n && n.toLowerCase() === this.address.toLowerCase(),
                    "from address mismatch",
                    "transaction",
                    e
                  ),
                    (t.from = n);
                })()
              );
            } else t.from = this.address;
            if (
              (null == t.gasLimit &&
                n.push(
                  (async () => {
                    t.gasLimit = await this.provider.estimateGas({
                      ...t,
                      from: this.address,
                    });
                  })()
                ),
              null != t.to)
            ) {
              let e = t.to;
              n.push(
                (async () => {
                  t.to = await (0, i.resolveAddress)(e, this.provider);
                })()
              );
            }
            n.length && (await Promise.all(n));
            let s = this.provider.getRpcTransaction(t);
            return this.provider.send("eth_sendTransaction", [s]);
          }
          async sendTransaction(e) {
            let t = await this.provider.getBlockNumber(),
              n = await this.sendUncheckedTransaction(e);
            return await new Promise((e, s) => {
              let i = [1e3, 100],
                a = 0,
                o = async () => {
                  try {
                    let s = await this.provider.getTransaction(n);
                    if (null != s) {
                      e(s.replaceableTransaction(t));
                      return;
                    }
                  } catch (e) {
                    if (
                      (0, l.isError)(e, "CANCELLED") ||
                      (0, l.isError)(e, "BAD_DATA") ||
                      (0, l.isError)(e, "NETWORK_ERROR") ||
                      (0, l.isError)(e, "UNSUPPORTED_OPERATION")
                    ) {
                      null == e.info && (e.info = {}),
                        (e.info.sendTransactionHash = n),
                        s(e);
                      return;
                    }
                    if (
                      (0, l.isError)(e, "INVALID_ARGUMENT") &&
                      (a++,
                      null == e.info && (e.info = {}),
                      (e.info.sendTransactionHash = n),
                      a > 10)
                    ) {
                      s(e);
                      return;
                    }
                    this.provider.emit(
                      "error",
                      (0, l.makeError)(
                        "failed to fetch transation after sending (will try again)",
                        "UNKNOWN_ERROR",
                        { error: e }
                      )
                    );
                  }
                  this.provider._setTimeout(() => {
                    o();
                  }, i.pop() || 4e3);
                };
              o();
            });
          }
          async signTransaction(e) {
            let t = g(e);
            if (t.from) {
              let n = await (0, i.resolveAddress)(t.from, this.provider);
              (0, l.assertArgument)(
                null != n && n.toLowerCase() === this.address.toLowerCase(),
                "from address mismatch",
                "transaction",
                e
              ),
                (t.from = n);
            } else t.from = this.address;
            let n = this.provider.getRpcTransaction(t);
            return await this.provider.send("eth_signTransaction", [n]);
          }
          async signMessage(e) {
            let t = "string" == typeof e ? (0, l.toUtf8Bytes)(e) : e;
            return await this.provider.send("personal_sign", [
              (0, l.hexlify)(t),
              this.address.toLowerCase(),
            ]);
          }
          async signTypedData(e, t, n) {
            let s = g(n),
              o = await a.TypedDataEncoder.resolveNames(e, t, s, async (e) => {
                let t = await (0, i.resolveAddress)(e);
                return (
                  (0, l.assertArgument)(
                    null != t,
                    "TypedData does not support null address",
                    "value",
                    e
                  ),
                  t
                );
              });
            return await this.provider.send("eth_signTypedData_v4", [
              this.address.toLowerCase(),
              JSON.stringify(
                a.TypedDataEncoder.getPayload(o.domain, t, o.value)
              ),
            ]);
          }
          async unlock(e) {
            return this.provider.send("personal_unlockAccount", [
              this.address.toLowerCase(),
              e,
              null,
            ]);
          }
          async _legacySignMessage(e) {
            let t = "string" == typeof e ? (0, l.toUtf8Bytes)(e) : e;
            return await this.provider.send("eth_sign", [
              this.address.toLowerCase(),
              (0, l.hexlify)(t),
            ]);
          }
        }
        t.JsonRpcSigner = A;
        class w extends u.AbstractProvider {
          #w;
          #em;
          #ey;
          #eb;
          #eA;
          #ew;
          #ev;
          #eE() {
            if (this.#eb) return;
            let e =
              1 === this._getOption("batchMaxCount")
                ? 0
                : this._getOption("batchStallTime");
            this.#eb = setTimeout(() => {
              this.#eb = null;
              let e = this.#ey;
              for (this.#ey = []; e.length; ) {
                let t = [e.shift()];
                for (; e.length && t.length !== this.#w.batchMaxCount; )
                  if (
                    (t.push(e.shift()),
                    JSON.stringify(t.map((e) => e.payload)).length >
                      this.#w.batchMaxSize)
                  ) {
                    e.unshift(t.pop());
                    break;
                  }
                (async () => {
                  let e =
                    1 === t.length ? t[0].payload : t.map((e) => e.payload);
                  this.emit("debug", { action: "sendRpcPayload", payload: e });
                  try {
                    let n = await this._send(e);
                    for (let {
                      resolve: e,
                      reject: s,
                      payload: i,
                    } of (this.emit("debug", {
                      action: "receiveRpcResult",
                      result: n,
                    }),
                    t)) {
                      if (this.destroyed) {
                        s(
                          (0, l.makeError)(
                            "provider destroyed; cancelled request",
                            "UNSUPPORTED_OPERATION",
                            { operation: i.method }
                          )
                        );
                        continue;
                      }
                      let t = n.filter((e) => e.id === i.id)[0];
                      if (null == t) {
                        let e = (0, l.makeError)(
                          "missing response for request",
                          "BAD_DATA",
                          { value: n, info: { payload: i } }
                        );
                        this.emit("error", e), s(e);
                        continue;
                      }
                      if ("error" in t) {
                        s(this.getRpcError(i, t));
                        continue;
                      }
                      e(t.result);
                    }
                  } catch (e) {
                    for (let { reject: n } of (this.emit("debug", {
                      action: "receiveRpcError",
                      error: e,
                    }),
                    t))
                      n(e);
                  }
                })();
              }
            }, e);
          }
          constructor(e, t) {
            super(e, t),
              (this.#em = 1),
              (this.#w = Object.assign({}, b, t || {})),
              (this.#ey = []),
              (this.#eb = null),
              (this.#ew = null),
              (this.#ev = null);
            {
              let e = null,
                t = new Promise((t) => {
                  e = t;
                });
              this.#eA = { promise: t, resolve: e };
            }
            let n = this._getOption("staticNetwork");
            "boolean" == typeof n
              ? ((0, l.assertArgument)(
                  !n || "any" !== e,
                  "staticNetwork cannot be used on special network 'any'",
                  "options",
                  t
                ),
                n && null != e && (this.#ew = d.Network.from(e)))
              : n &&
                ((0, l.assertArgument)(
                  null == e || n.matches(e),
                  "staticNetwork MUST match network object",
                  "options",
                  t
                ),
                (this.#ew = n));
          }
          _getOption(e) {
            return this.#w[e];
          }
          get _network() {
            return (
              (0, l.assert)(
                this.#ew,
                "network is not available yet",
                "NETWORK_ERROR"
              ),
              this.#ew
            );
          }
          async _perform(e) {
            if ("call" === e.method || "estimateGas" === e.method) {
              let t = e.transaction;
              if (
                t &&
                null != t.type &&
                (0, l.getBigInt)(t.type) &&
                null == t.maxFeePerGas &&
                null == t.maxPriorityFeePerGas
              ) {
                let n = await this.getFeeData();
                null == n.maxFeePerGas &&
                  null == n.maxPriorityFeePerGas &&
                  (e = Object.assign({}, e, {
                    transaction: Object.assign({}, t, { type: void 0 }),
                  }));
              }
            }
            let t = this.getRpcRequest(e);
            return null != t
              ? await this.send(t.method, t.args)
              : super._perform(e);
          }
          async _detectNetwork() {
            let e = this._getOption("staticNetwork");
            if (e) {
              if (!0 !== e) return e;
              if (this.#ew) return this.#ew;
            }
            return (
              this.#ev ||
                (this.ready
                  ? (this.#ev = (async () => {
                      try {
                        let e = d.Network.from(
                          (0, l.getBigInt)(await this.send("eth_chainId", []))
                        );
                        return (this.#ev = null), e;
                      } catch (e) {
                        throw ((this.#ev = null), e);
                      }
                    })())
                  : (this.#ev = (async () => {
                      let e;
                      let t = {
                        id: this.#em++,
                        method: "eth_chainId",
                        params: [],
                        jsonrpc: "2.0",
                      };
                      this.emit("debug", {
                        action: "sendRpcPayload",
                        payload: t,
                      });
                      try {
                        (e = (await this._send(t))[0]), (this.#ev = null);
                      } catch (e) {
                        throw (
                          ((this.#ev = null),
                          this.emit("debug", {
                            action: "receiveRpcError",
                            error: e,
                          }),
                          e)
                        );
                      }
                      if (
                        (this.emit("debug", {
                          action: "receiveRpcResult",
                          result: e,
                        }),
                        "result" in e)
                      )
                        return d.Network.from((0, l.getBigInt)(e.result));
                      throw this.getRpcError(t, e);
                    })())),
              await this.#ev
            );
          }
          _start() {
            null != this.#eA &&
              null != this.#eA.resolve &&
              (this.#eA.resolve(),
              (this.#eA = null),
              (async () => {
                for (; null == this.#ew && !this.destroyed; )
                  try {
                    this.#ew = await this._detectNetwork();
                  } catch (e) {
                    if (this.destroyed) break;
                    console.log(
                      "JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"
                    ),
                      this.emit(
                        "error",
                        (0, l.makeError)(
                          "failed to bootstrap network detection",
                          "NETWORK_ERROR",
                          {
                            event: "initial-network-discovery",
                            info: { error: e },
                          }
                        )
                      ),
                      await new Promise((e) => {
                        setTimeout(e, 1e3);
                      });
                  }
                this.#eE();
              })());
          }
          async _waitUntilReady() {
            if (null != this.#eA) return await this.#eA.promise;
          }
          _getSubscriber(e) {
            return "pending" === e.type
              ? new h.FilterIdPendingSubscriber(this)
              : "event" === e.type
              ? this._getOption("polling")
                ? new p.PollingEventSubscriber(this, e.filter)
                : new h.FilterIdEventSubscriber(this, e.filter)
              : "orphan" === e.type && "drop-log" === e.filter.orphan
              ? new u.UnmanagedSubscriber("orphan")
              : super._getSubscriber(e);
          }
          get ready() {
            return null == this.#eA;
          }
          getRpcTransaction(e) {
            let t = {};
            return (
              [
                "chainId",
                "gasLimit",
                "gasPrice",
                "type",
                "maxFeePerGas",
                "maxPriorityFeePerGas",
                "nonce",
                "value",
              ].forEach((n) => {
                if (null == e[n]) return;
                let s = n;
                "gasLimit" === n && (s = "gas"),
                  (t[s] = (0, l.toQuantity)((0, l.getBigInt)(e[n], `tx.${n}`)));
              }),
              ["from", "to", "data"].forEach((n) => {
                null != e[n] && (t[n] = (0, l.hexlify)(e[n]));
              }),
              e.accessList &&
                (t.accessList = (0, o.accessListify)(e.accessList)),
              e.blobVersionedHashes &&
                (t.blobVersionedHashes = e.blobVersionedHashes.map((e) =>
                  e.toLowerCase()
                )),
              t
            );
          }
          getRpcRequest(e) {
            switch (e.method) {
              case "chainId":
                return { method: "eth_chainId", args: [] };
              case "getBlockNumber":
                return { method: "eth_blockNumber", args: [] };
              case "getGasPrice":
                return { method: "eth_gasPrice", args: [] };
              case "getPriorityFee":
                return { method: "eth_maxPriorityFeePerGas", args: [] };
              case "getBalance":
                return {
                  method: "eth_getBalance",
                  args: [m(e.address), e.blockTag],
                };
              case "getTransactionCount":
                return {
                  method: "eth_getTransactionCount",
                  args: [m(e.address), e.blockTag],
                };
              case "getCode":
                return {
                  method: "eth_getCode",
                  args: [m(e.address), e.blockTag],
                };
              case "getStorage":
                return {
                  method: "eth_getStorageAt",
                  args: [
                    m(e.address),
                    "0x" + e.position.toString(16),
                    e.blockTag,
                  ],
                };
              case "broadcastTransaction":
                return {
                  method: "eth_sendRawTransaction",
                  args: [e.signedTransaction],
                };
              case "getBlock":
                if ("blockTag" in e)
                  return {
                    method: "eth_getBlockByNumber",
                    args: [e.blockTag, !!e.includeTransactions],
                  };
                if ("blockHash" in e)
                  return {
                    method: "eth_getBlockByHash",
                    args: [e.blockHash, !!e.includeTransactions],
                  };
                break;
              case "getTransaction":
                return { method: "eth_getTransactionByHash", args: [e.hash] };
              case "getTransactionReceipt":
                return { method: "eth_getTransactionReceipt", args: [e.hash] };
              case "call":
                return {
                  method: "eth_call",
                  args: [this.getRpcTransaction(e.transaction), e.blockTag],
                };
              case "estimateGas":
                return {
                  method: "eth_estimateGas",
                  args: [this.getRpcTransaction(e.transaction)],
                };
              case "getLogs":
                return (
                  e.filter &&
                    null != e.filter.address &&
                    (Array.isArray(e.filter.address)
                      ? (e.filter.address = e.filter.address.map(m))
                      : (e.filter.address = m(e.filter.address))),
                  { method: "eth_getLogs", args: [e.filter] }
                );
            }
            return null;
          }
          getRpcError(e, t) {
            let { method: n } = e,
              { error: i } = t;
            if ("eth_estimateGas" === n && i.message) {
              let t = i.message;
              if (!t.match(/revert/i) && t.match(/insufficient funds/i))
                return (0, l.makeError)(
                  "insufficient funds",
                  "INSUFFICIENT_FUNDS",
                  { transaction: e.params[0], info: { payload: e, error: i } }
                );
            }
            if ("eth_call" === n || "eth_estimateGas" === n) {
              let t = (function e(t) {
                  if (null == t) return null;
                  if (
                    "string" == typeof t.message &&
                    t.message.match(/revert/i) &&
                    (0, l.isHexString)(t.data)
                  )
                    return { message: t.message, data: t.data };
                  if ("object" == typeof t) {
                    for (let n in t) {
                      let s = e(t[n]);
                      if (s) return s;
                    }
                    return null;
                  }
                  if ("string" == typeof t)
                    try {
                      return e(JSON.parse(t));
                    } catch (e) {}
                  return null;
                })(i),
                a = s.AbiCoder.getBuiltinCallException(
                  "eth_call" === n ? "call" : "estimateGas",
                  e.params[0],
                  t ? t.data : null
                );
              return (a.info = { error: i, payload: e }), a;
            }
            let a = JSON.stringify(
              (function (e) {
                let t = [];
                return (
                  (function e(t, n) {
                    if (null != t) {
                      if (
                        ("string" == typeof t.message && n.push(t.message),
                        "object" == typeof t)
                      )
                        for (let s in t) e(t[s], n);
                      if ("string" == typeof t)
                        try {
                          return e(JSON.parse(t), n);
                        } catch (e) {}
                    }
                  })(e, t),
                  t
                );
              })(i)
            );
            if (
              "string" == typeof i.message &&
              i.message.match(/user denied|ethers-user-denied/i)
            )
              return (0, l.makeError)(
                "user rejected action",
                "ACTION_REJECTED",
                {
                  action:
                    {
                      eth_sign: "signMessage",
                      personal_sign: "signMessage",
                      eth_signTypedData_v4: "signTypedData",
                      eth_signTransaction: "signTransaction",
                      eth_sendTransaction: "sendTransaction",
                      eth_requestAccounts: "requestAccess",
                      wallet_requestAccounts: "requestAccess",
                    }[n] || "unknown",
                  reason: "rejected",
                  info: { payload: e, error: i },
                }
              );
            if ("eth_sendRawTransaction" === n || "eth_sendTransaction" === n) {
              let t = e.params[0];
              if (a.match(/insufficient funds|base fee exceeds gas limit/i))
                return (0, l.makeError)(
                  "insufficient funds for intrinsic transaction cost",
                  "INSUFFICIENT_FUNDS",
                  { transaction: t, info: { error: i } }
                );
              if (a.match(/nonce/i) && a.match(/too low/i))
                return (0, l.makeError)(
                  "nonce has already been used",
                  "NONCE_EXPIRED",
                  { transaction: t, info: { error: i } }
                );
              if (
                a.match(/replacement transaction/i) &&
                a.match(/underpriced/i)
              )
                return (0, l.makeError)(
                  "replacement fee too low",
                  "REPLACEMENT_UNDERPRICED",
                  { transaction: t, info: { error: i } }
                );
              if (a.match(/only replay-protected/i))
                return (0, l.makeError)(
                  "legacy pre-eip-155 transactions not supported",
                  "UNSUPPORTED_OPERATION",
                  { operation: n, info: { transaction: t, info: { error: i } } }
                );
            }
            let o = !!a.match(/the method .* does not exist/i);
            return (!o &&
              i &&
              i.details &&
              i.details.startsWith("Unauthorized method:") &&
              (o = !0),
            o)
              ? (0, l.makeError)(
                  "unsupported operation",
                  "UNSUPPORTED_OPERATION",
                  { operation: e.method, info: { error: i, payload: e } }
                )
              : (0, l.makeError)("could not coalesce error", "UNKNOWN_ERROR", {
                  error: i,
                  payload: e,
                });
          }
          send(e, t) {
            if (this.destroyed)
              return Promise.reject(
                (0, l.makeError)(
                  "provider destroyed; cancelled request",
                  "UNSUPPORTED_OPERATION",
                  { operation: e }
                )
              );
            let n = this.#em++,
              s = new Promise((s, i) => {
                this.#ey.push({
                  resolve: s,
                  reject: i,
                  payload: { method: e, params: t, id: n, jsonrpc: "2.0" },
                });
              });
            return this.#eE(), s;
          }
          async getSigner(e) {
            null == e && (e = 0);
            let t = this.send("eth_accounts", []);
            if ("number" == typeof e) {
              let n = await t;
              if (e >= n.length) throw Error("no such account");
              return new A(this, n[e]);
            }
            let { accounts: n } = await (0, l.resolveProperties)({
              network: this.getNetwork(),
              accounts: t,
            });
            for (let t of ((e = (0, i.getAddress)(e)), n))
              if ((0, i.getAddress)(t) === e) return new A(this, e);
            throw Error("invalid account");
          }
          async listAccounts() {
            return (await this.send("eth_accounts", [])).map(
              (e) => new A(this, e)
            );
          }
          destroy() {
            for (let { payload: e, reject: t } of (this.#eb &&
              (clearTimeout(this.#eb), (this.#eb = null)),
            this.#ey))
              t(
                (0, l.makeError)(
                  "provider destroyed; cancelled request",
                  "UNSUPPORTED_OPERATION",
                  { operation: e.method }
                )
              );
            (this.#ey = []), super.destroy();
          }
        }
        t.JsonRpcApiProvider = w;
        class v extends w {
          #eP;
          constructor(e, t) {
            super(e, t);
            let n = this._getOption("pollingInterval");
            null == n && (n = b.pollingInterval), (this.#eP = n);
          }
          _getSubscriber(e) {
            let t = super._getSubscriber(e);
            return y(t) && (t.pollingInterval = this.#eP), t;
          }
          get pollingInterval() {
            return this.#eP;
          }
          set pollingInterval(e) {
            if (!Number.isInteger(e) || e < 0) throw Error("invalid interval");
            (this.#eP = e),
              this._forEachSubscriber((e) => {
                y(e) && (e.pollingInterval = this.#eP);
              });
          }
        }
        t.JsonRpcApiPollingProvider = v;
        class E extends v {
          #ek;
          constructor(e, t, n) {
            null == e && (e = "http://localhost:8545"),
              super(t, n),
              "string" == typeof e
                ? (this.#ek = new l.FetchRequest(e))
                : (this.#ek = e.clone());
          }
          _getConnection() {
            return this.#ek.clone();
          }
          async send(e, t) {
            return await this._start(), await super.send(e, t);
          }
          async _send(e) {
            let t = this._getConnection();
            (t.body = JSON.stringify(e)),
              t.setHeader("content-type", "application/json");
            let n = await t.send();
            n.assertOk();
            let s = n.bodyJson;
            return Array.isArray(s) || (s = [s]), s;
          }
        }
        t.JsonRpcProvider = E;
      },
      52751: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PocketProvider = void 0);
        let s = n(42120),
          i = n(32813),
          a = n(54837),
          o = n(32013),
          l = "62e1ad51b37b8e00394bda3b";
        class u extends o.JsonRpcProvider {
          applicationId;
          applicationSecret;
          constructor(e, t, n) {
            null == e && (e = "mainnet");
            let i = a.Network.from(e);
            null == t && (t = l),
              null == n && (n = null),
              super(u.getRequest(i, t, n), i, { staticNetwork: i }),
              (0, s.defineProperties)(this, {
                applicationId: t,
                applicationSecret: n,
              });
          }
          _getProvider(e) {
            try {
              return new u(e, this.applicationId, this.applicationSecret);
            } catch (e) {}
            return super._getProvider(e);
          }
          static getRequest(e, t, n) {
            null == t && (t = l);
            let a = new s.FetchRequest(
              `https://${(function (e) {
                switch (e) {
                  case "mainnet":
                    return "eth-mainnet.gateway.pokt.network";
                  case "goerli":
                    return "eth-goerli.gateway.pokt.network";
                  case "matic":
                    return "poly-mainnet.gateway.pokt.network";
                  case "matic-mumbai":
                    return "polygon-mumbai-rpc.gateway.pokt.network";
                }
                (0, s.assertArgument)(!1, "unsupported network", "network", e);
              })(e.name)}/v1/lb/${t}`
            );
            return (
              (a.allowGzip = !0),
              n && a.setCredentials("", n),
              t === l &&
                (a.retryFunc = async (e, t, n) => (
                  (0, i.showThrottleMessage)("PocketProvider"), !0
                )),
              a
            );
          }
          isCommunityResource() {
            return this.applicationId === l;
          }
        }
        t.PocketProvider = u;
      },
      81333: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.QuickNodeProvider = void 0);
        let s = n(42120),
          i = n(32813),
          a = n(54837),
          o = n(32013),
          l = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
        class u extends o.JsonRpcProvider {
          token;
          constructor(e, t) {
            null == e && (e = "mainnet");
            let n = a.Network.from(e);
            null == t && (t = l),
              super(u.getRequest(n, t), n, { staticNetwork: n }),
              (0, s.defineProperties)(this, { token: t });
          }
          _getProvider(e) {
            try {
              return new u(e, this.token);
            } catch (e) {}
            return super._getProvider(e);
          }
          isCommunityResource() {
            return this.token === l;
          }
          static getRequest(e, t) {
            null == t && (t = l);
            let n = new s.FetchRequest(
              `https://${(function (e) {
                switch (e) {
                  case "mainnet":
                    return "ethers.quiknode.pro";
                  case "goerli":
                    return "ethers.ethereum-goerli.quiknode.pro";
                  case "sepolia":
                    return "ethers.ethereum-sepolia.quiknode.pro";
                  case "holesky":
                    return "ethers.ethereum-holesky.quiknode.pro";
                  case "arbitrum":
                    return "ethers.arbitrum-mainnet.quiknode.pro";
                  case "arbitrum-goerli":
                    return "ethers.arbitrum-goerli.quiknode.pro";
                  case "arbitrum-sepolia":
                    return "ethers.arbitrum-sepolia.quiknode.pro";
                  case "base":
                    return "ethers.base-mainnet.quiknode.pro";
                  case "base-goerli":
                    return "ethers.base-goerli.quiknode.pro";
                  case "base-spolia":
                    return "ethers.base-sepolia.quiknode.pro";
                  case "bnb":
                    return "ethers.bsc.quiknode.pro";
                  case "bnbt":
                    return "ethers.bsc-testnet.quiknode.pro";
                  case "matic":
                    return "ethers.matic.quiknode.pro";
                  case "matic-mumbai":
                    return "ethers.matic-testnet.quiknode.pro";
                  case "optimism":
                    return "ethers.optimism.quiknode.pro";
                  case "optimism-goerli":
                    return "ethers.optimism-goerli.quiknode.pro";
                  case "optimism-sepolia":
                    return "ethers.optimism-sepolia.quiknode.pro";
                  case "xdai":
                    return "ethers.xdai.quiknode.pro";
                }
                (0, s.assertArgument)(!1, "unsupported network", "network", e);
              })(e.name)}/${t}`
            );
            return (
              (n.allowGzip = !0),
              t === l &&
                (n.retryFunc = async (e, t, n) => (
                  (0, i.showThrottleMessage)("QuickNodeProvider"), !0
                )),
              n
            );
          }
        }
        t.QuickNodeProvider = u;
      },
      12394: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SocketProvider =
            t.SocketEventSubscriber =
            t.SocketPendingSubscriber =
            t.SocketBlockSubscriber =
            t.SocketSubscriber =
              void 0);
        let s = n(55142),
          i = n(42120),
          a = n(32013);
        class o {
          #eT;
          #v;
          get filter() {
            return JSON.parse(this.#v);
          }
          #ex;
          #eO;
          #eS;
          constructor(e, t) {
            (this.#eT = e),
              (this.#v = JSON.stringify(t)),
              (this.#ex = null),
              (this.#eO = null),
              (this.#eS = null);
          }
          start() {
            this.#ex = this.#eT
              .send("eth_subscribe", this.filter)
              .then((e) => (this.#eT._register(e, this), e));
          }
          stop() {
            this.#ex.then((e) => {
              this.#eT.destroyed || this.#eT.send("eth_unsubscribe", [e]);
            }),
              (this.#ex = null);
          }
          pause(e) {
            (0, i.assert)(
              e,
              "preserve logs while paused not supported by SocketSubscriber yet",
              "UNSUPPORTED_OPERATION",
              { operation: "pause(false)" }
            ),
              (this.#eO = !!e);
          }
          resume() {
            this.#eO = null;
          }
          _handleMessage(e) {
            if (null != this.#ex && null === this.#eO) {
              let t = this.#eS;
              (t =
                null == t
                  ? this._emit(this.#eT, e)
                  : t.then(async () => {
                      await this._emit(this.#eT, e);
                    })),
                (this.#eS = t.then(() => {
                  this.#eS === t && (this.#eS = null);
                }));
            }
          }
          async _emit(e, t) {
            throw Error("sub-classes must implemente this; _emit");
          }
        }
        t.SocketSubscriber = o;
        class l extends o {
          constructor(e) {
            super(e, ["newHeads"]);
          }
          async _emit(e, t) {
            e.emit("block", parseInt(t.number));
          }
        }
        t.SocketBlockSubscriber = l;
        class u extends o {
          constructor(e) {
            super(e, ["newPendingTransactions"]);
          }
          async _emit(e, t) {
            e.emit("pending", t);
          }
        }
        t.SocketPendingSubscriber = u;
        class c extends o {
          #eC;
          get logFilter() {
            return JSON.parse(this.#eC);
          }
          constructor(e, t) {
            super(e, ["logs", t]), (this.#eC = JSON.stringify(t));
          }
          async _emit(e, t) {
            e.emit(this.logFilter, e._wrapLog(t, e._network));
          }
        }
        t.SocketEventSubscriber = c;
        class d extends a.JsonRpcApiProvider {
          #eB;
          #R;
          #eN;
          constructor(e, t) {
            let n = Object.assign({}, null != t ? t : {});
            (0, i.assertArgument)(
              null == n.batchMaxCount || 1 === n.batchMaxCount,
              "sockets-based providers do not support batches",
              "options.batchMaxCount",
              t
            ),
              (n.batchMaxCount = 1),
              null == n.staticNetwork && (n.staticNetwork = !0),
              super(e, n),
              (this.#eB = new Map()),
              (this.#R = new Map()),
              (this.#eN = new Map());
          }
          _getSubscriber(e) {
            switch (e.type) {
              case "close":
                return new s.UnmanagedSubscriber("close");
              case "block":
                return new l(this);
              case "pending":
                return new u(this);
              case "event":
                return new c(this, e.filter);
              case "orphan":
                if ("drop-log" === e.filter.orphan)
                  return new s.UnmanagedSubscriber("drop-log");
            }
            return super._getSubscriber(e);
          }
          _register(e, t) {
            this.#R.set(e, t);
            let n = this.#eN.get(e);
            if (n) {
              for (let e of n) t._handleMessage(e);
              this.#eN.delete(e);
            }
          }
          async _send(e) {
            (0, i.assertArgument)(
              !Array.isArray(e),
              "WebSocket does not support batch send",
              "payload",
              e
            );
            let t = new Promise((t, n) => {
              this.#eB.set(e.id, { payload: e, resolve: t, reject: n });
            });
            return (
              await this._waitUntilReady(),
              await this._write(JSON.stringify(e)),
              [await t]
            );
          }
          async _processMessage(e) {
            let t = JSON.parse(e);
            if (t && "object" == typeof t && "id" in t) {
              let e = this.#eB.get(t.id);
              if (null == e) {
                this.emit(
                  "error",
                  (0, i.makeError)(
                    "received result for unknown id",
                    "UNKNOWN_ERROR",
                    { reasonCode: "UNKNOWN_ID", result: t }
                  )
                );
                return;
              }
              this.#eB.delete(t.id), e.resolve(t);
            } else if (t && "eth_subscription" === t.method) {
              let e = t.params.subscription,
                n = this.#R.get(e);
              if (n) n._handleMessage(t.params.result);
              else {
                let n = this.#eN.get(e);
                null == n && ((n = []), this.#eN.set(e, n)),
                  n.push(t.params.result);
              }
            } else {
              this.emit(
                "error",
                (0, i.makeError)(
                  "received unexpected message",
                  "UNKNOWN_ERROR",
                  { reasonCode: "UNEXPECTED_MESSAGE", result: t }
                )
              );
              return;
            }
          }
          async _write(e) {
            throw Error("sub-classes must override this");
          }
        }
        t.SocketProvider = d;
      },
      62196: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.WebSocketProvider = void 0);
        let s = n(19817),
          i = n(12394);
        class a extends i.SocketProvider {
          #ek;
          #eR;
          get websocket() {
            if (null == this.#eR) throw Error("websocket closed");
            return this.#eR;
          }
          constructor(e, t, n) {
            super(t, n),
              "string" == typeof e
                ? ((this.#ek = () => new s.WebSocket(e)),
                  (this.#eR = this.#ek()))
                : "function" == typeof e
                ? ((this.#ek = e), (this.#eR = e()))
                : ((this.#ek = null), (this.#eR = e)),
              (this.websocket.onopen = async () => {
                try {
                  await this._start(), this.resume();
                } catch (e) {
                  console.log("failed to start WebsocketProvider", e);
                }
              }),
              (this.websocket.onmessage = (e) => {
                this._processMessage(e.data);
              });
          }
          async _write(e) {
            this.websocket.send(e);
          }
          async destroy() {
            null != this.#eR && (this.#eR.close(), (this.#eR = null)),
              super.destroy();
          }
        }
        t.WebSocketProvider = a;
      },
      37143: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TransactionResponse =
            t.TransactionReceipt =
            t.Log =
            t.Block =
            t.copyRequest =
            t.FeeData =
              void 0);
        let s = n(42120),
          i = n(2290),
          a = BigInt(0);
        function o(e) {
          return null == e ? null : e;
        }
        function l(e) {
          return null == e ? null : e.toString();
        }
        class u {
          gasPrice;
          maxFeePerGas;
          maxPriorityFeePerGas;
          constructor(e, t, n) {
            (0, s.defineProperties)(this, {
              gasPrice: o(e),
              maxFeePerGas: o(t),
              maxPriorityFeePerGas: o(n),
            });
          }
          toJSON() {
            let {
              gasPrice: e,
              maxFeePerGas: t,
              maxPriorityFeePerGas: n,
            } = this;
            return {
              _type: "FeeData",
              gasPrice: l(e),
              maxFeePerGas: l(t),
              maxPriorityFeePerGas: l(n),
            };
          }
        }
        (t.FeeData = u),
          (t.copyRequest = function (e) {
            let t = {};
            for (let n of (e.to && (t.to = e.to),
            e.from && (t.from = e.from),
            e.data && (t.data = (0, s.hexlify)(e.data)),
            "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(
              /,/
            )))
              n in e &&
                null != e[n] &&
                (t[n] = (0, s.getBigInt)(e[n], `request.${n}`));
            for (let n of "type,nonce".split(/,/))
              n in e &&
                null != e[n] &&
                (t[n] = (0, s.getNumber)(e[n], `request.${n}`));
            return (
              e.accessList &&
                (t.accessList = (0, i.accessListify)(e.accessList)),
              "blockTag" in e && (t.blockTag = e.blockTag),
              "enableCcipRead" in e && (t.enableCcipRead = !!e.enableCcipRead),
              "customData" in e && (t.customData = e.customData),
              "blobVersionedHashes" in e &&
                e.blobVersionedHashes &&
                (t.blobVersionedHashes = e.blobVersionedHashes.slice()),
              "kzg" in e && (t.kzg = e.kzg),
              "blobs" in e &&
                e.blobs &&
                (t.blobs = e.blobs.map((e) =>
                  (0, s.isBytesLike)(e)
                    ? (0, s.hexlify)(e)
                    : Object.assign({}, e)
                )),
              t
            );
          });
        class c {
          provider;
          number;
          hash;
          timestamp;
          parentHash;
          parentBeaconBlockRoot;
          nonce;
          difficulty;
          gasLimit;
          gasUsed;
          stateRoot;
          receiptsRoot;
          blobGasUsed;
          excessBlobGas;
          miner;
          prevRandao;
          extraData;
          baseFeePerGas;
          #eI;
          constructor(e, t) {
            (this.#eI = e.transactions.map((e) =>
              "string" != typeof e ? new p(e, t) : e
            )),
              (0, s.defineProperties)(this, {
                provider: t,
                hash: o(e.hash),
                number: e.number,
                timestamp: e.timestamp,
                parentHash: e.parentHash,
                parentBeaconBlockRoot: e.parentBeaconBlockRoot,
                nonce: e.nonce,
                difficulty: e.difficulty,
                gasLimit: e.gasLimit,
                gasUsed: e.gasUsed,
                blobGasUsed: e.blobGasUsed,
                excessBlobGas: e.excessBlobGas,
                miner: e.miner,
                prevRandao: o(e.prevRandao),
                extraData: e.extraData,
                baseFeePerGas: o(e.baseFeePerGas),
                stateRoot: e.stateRoot,
                receiptsRoot: e.receiptsRoot,
              });
          }
          get transactions() {
            return this.#eI.map((e) => ("string" == typeof e ? e : e.hash));
          }
          get prefetchedTransactions() {
            let e = this.#eI.slice();
            return 0 === e.length
              ? []
              : ((0, s.assert)(
                  "object" == typeof e[0],
                  "transactions were not prefetched with block request",
                  "UNSUPPORTED_OPERATION",
                  { operation: "transactionResponses()" }
                ),
                e);
          }
          toJSON() {
            let {
              baseFeePerGas: e,
              difficulty: t,
              extraData: n,
              gasLimit: s,
              gasUsed: i,
              hash: a,
              miner: o,
              prevRandao: u,
              nonce: c,
              number: d,
              parentHash: h,
              parentBeaconBlockRoot: p,
              stateRoot: f,
              receiptsRoot: g,
              timestamp: m,
              transactions: y,
            } = this;
            return {
              _type: "Block",
              baseFeePerGas: l(e),
              difficulty: l(t),
              extraData: n,
              gasLimit: l(s),
              gasUsed: l(i),
              blobGasUsed: l(this.blobGasUsed),
              excessBlobGas: l(this.excessBlobGas),
              hash: a,
              miner: o,
              prevRandao: u,
              nonce: c,
              number: d,
              parentHash: h,
              timestamp: m,
              parentBeaconBlockRoot: p,
              stateRoot: f,
              receiptsRoot: g,
              transactions: y,
            };
          }
          [Symbol.iterator]() {
            let e = 0,
              t = this.transactions;
            return {
              next: () =>
                e < this.length
                  ? { value: t[e++], done: !1 }
                  : { value: void 0, done: !0 },
            };
          }
          get length() {
            return this.#eI.length;
          }
          get date() {
            return null == this.timestamp
              ? null
              : new Date(1e3 * this.timestamp);
          }
          async getTransaction(e) {
            let t;
            if ("number" == typeof e) t = this.#eI[e];
            else {
              let n = e.toLowerCase();
              for (let e of this.#eI) {
                if ("string" == typeof e) {
                  if (e !== n) continue;
                  t = e;
                  break;
                }
                if (e.hash === n) {
                  t = e;
                  break;
                }
              }
            }
            if (null == t) throw Error("no such tx");
            return "string" == typeof t
              ? await this.provider.getTransaction(t)
              : t;
          }
          getPrefetchedTransaction(e) {
            let t = this.prefetchedTransactions;
            if ("number" == typeof e) return t[e];
            for (let n of ((e = e.toLowerCase()), t))
              if (n.hash === e) return n;
            (0, s.assertArgument)(
              !1,
              "no matching transaction",
              "indexOrHash",
              e
            );
          }
          isMined() {
            return !!this.hash;
          }
          isLondon() {
            return !!this.baseFeePerGas;
          }
          orphanedEvent() {
            if (!this.isMined()) throw Error("");
            return {
              orphan: "drop-block",
              hash: this.hash,
              number: this.number,
            };
          }
        }
        t.Block = c;
        class d {
          provider;
          transactionHash;
          blockHash;
          blockNumber;
          removed;
          address;
          data;
          topics;
          index;
          transactionIndex;
          constructor(e, t) {
            this.provider = t;
            let n = Object.freeze(e.topics.slice());
            (0, s.defineProperties)(this, {
              transactionHash: e.transactionHash,
              blockHash: e.blockHash,
              blockNumber: e.blockNumber,
              removed: e.removed,
              address: e.address,
              data: e.data,
              topics: n,
              index: e.index,
              transactionIndex: e.transactionIndex,
            });
          }
          toJSON() {
            let {
              address: e,
              blockHash: t,
              blockNumber: n,
              data: s,
              index: i,
              removed: a,
              topics: o,
              transactionHash: l,
              transactionIndex: u,
            } = this;
            return {
              _type: "log",
              address: e,
              blockHash: t,
              blockNumber: n,
              data: s,
              index: i,
              removed: a,
              topics: o,
              transactionHash: l,
              transactionIndex: u,
            };
          }
          async getBlock() {
            let e = await this.provider.getBlock(this.blockHash);
            return (
              (0, s.assert)(
                !!e,
                "failed to find transaction",
                "UNKNOWN_ERROR",
                {}
              ),
              e
            );
          }
          async getTransaction() {
            let e = await this.provider.getTransaction(this.transactionHash);
            return (
              (0, s.assert)(
                !!e,
                "failed to find transaction",
                "UNKNOWN_ERROR",
                {}
              ),
              e
            );
          }
          async getTransactionReceipt() {
            let e = await this.provider.getTransactionReceipt(
              this.transactionHash
            );
            return (
              (0, s.assert)(
                !!e,
                "failed to find transaction receipt",
                "UNKNOWN_ERROR",
                {}
              ),
              e
            );
          }
          removedEvent() {
            return {
              orphan: "drop-log",
              log: {
                transactionHash: this.transactionHash,
                blockHash: this.blockHash,
                blockNumber: this.blockNumber,
                address: this.address,
                data: this.data,
                topics: Object.freeze(this.topics.slice()),
                index: this.index,
              },
            };
          }
        }
        t.Log = d;
        class h {
          provider;
          to;
          from;
          contractAddress;
          hash;
          index;
          blockHash;
          blockNumber;
          logsBloom;
          gasUsed;
          blobGasUsed;
          cumulativeGasUsed;
          gasPrice;
          blobGasPrice;
          type;
          status;
          root;
          #eM;
          constructor(e, t) {
            this.#eM = Object.freeze(e.logs.map((e) => new d(e, t)));
            let n = a;
            null != e.effectiveGasPrice
              ? (n = e.effectiveGasPrice)
              : null != e.gasPrice && (n = e.gasPrice),
              (0, s.defineProperties)(this, {
                provider: t,
                to: e.to,
                from: e.from,
                contractAddress: e.contractAddress,
                hash: e.hash,
                index: e.index,
                blockHash: e.blockHash,
                blockNumber: e.blockNumber,
                logsBloom: e.logsBloom,
                gasUsed: e.gasUsed,
                cumulativeGasUsed: e.cumulativeGasUsed,
                blobGasUsed: e.blobGasUsed,
                gasPrice: n,
                blobGasPrice: e.blobGasPrice,
                type: e.type,
                status: e.status,
                root: e.root,
              });
          }
          get logs() {
            return this.#eM;
          }
          toJSON() {
            let {
              to: e,
              from: t,
              contractAddress: n,
              hash: s,
              index: i,
              blockHash: a,
              blockNumber: o,
              logsBloom: u,
              logs: c,
              status: d,
              root: h,
            } = this;
            return {
              _type: "TransactionReceipt",
              blockHash: a,
              blockNumber: o,
              contractAddress: n,
              cumulativeGasUsed: l(this.cumulativeGasUsed),
              from: t,
              gasPrice: l(this.gasPrice),
              blobGasUsed: l(this.blobGasUsed),
              blobGasPrice: l(this.blobGasPrice),
              gasUsed: l(this.gasUsed),
              hash: s,
              index: i,
              logs: c,
              logsBloom: u,
              root: h,
              status: d,
              to: e,
            };
          }
          get length() {
            return this.logs.length;
          }
          [Symbol.iterator]() {
            let e = 0;
            return {
              next: () =>
                e < this.length
                  ? { value: this.logs[e++], done: !1 }
                  : { value: void 0, done: !0 },
            };
          }
          get fee() {
            return this.gasUsed * this.gasPrice;
          }
          async getBlock() {
            let e = await this.provider.getBlock(this.blockHash);
            if (null == e) throw Error("TODO");
            return e;
          }
          async getTransaction() {
            let e = await this.provider.getTransaction(this.hash);
            if (null == e) throw Error("TODO");
            return e;
          }
          async getResult() {
            return await this.provider.getTransactionResult(this.hash);
          }
          async confirmations() {
            return (
              (await this.provider.getBlockNumber()) - this.blockNumber + 1
            );
          }
          removedEvent() {
            return g(this);
          }
          reorderedEvent(e) {
            return (
              (0, s.assert)(
                !e || e.isMined(),
                "unmined 'other' transction cannot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "reorderedEvent(other)" }
              ),
              f(this, e)
            );
          }
        }
        t.TransactionReceipt = h;
        class p {
          provider;
          blockNumber;
          blockHash;
          index;
          hash;
          type;
          to;
          from;
          nonce;
          gasLimit;
          gasPrice;
          maxPriorityFeePerGas;
          maxFeePerGas;
          maxFeePerBlobGas;
          data;
          value;
          chainId;
          signature;
          accessList;
          blobVersionedHashes;
          #eL;
          constructor(e, t) {
            (this.provider = t),
              (this.blockNumber = null != e.blockNumber ? e.blockNumber : null),
              (this.blockHash = null != e.blockHash ? e.blockHash : null),
              (this.hash = e.hash),
              (this.index = e.index),
              (this.type = e.type),
              (this.from = e.from),
              (this.to = e.to || null),
              (this.gasLimit = e.gasLimit),
              (this.nonce = e.nonce),
              (this.data = e.data),
              (this.value = e.value),
              (this.gasPrice = e.gasPrice),
              (this.maxPriorityFeePerGas =
                null != e.maxPriorityFeePerGas ? e.maxPriorityFeePerGas : null),
              (this.maxFeePerGas =
                null != e.maxFeePerGas ? e.maxFeePerGas : null),
              (this.maxFeePerBlobGas =
                null != e.maxFeePerBlobGas ? e.maxFeePerBlobGas : null),
              (this.chainId = e.chainId),
              (this.signature = e.signature),
              (this.accessList = null != e.accessList ? e.accessList : null),
              (this.blobVersionedHashes =
                null != e.blobVersionedHashes ? e.blobVersionedHashes : null),
              (this.#eL = -1);
          }
          toJSON() {
            let {
              blockNumber: e,
              blockHash: t,
              index: n,
              hash: s,
              type: i,
              to: a,
              from: o,
              nonce: u,
              data: c,
              signature: d,
              accessList: h,
              blobVersionedHashes: p,
            } = this;
            return {
              _type: "TransactionResponse",
              accessList: h,
              blockNumber: e,
              blockHash: t,
              blobVersionedHashes: p,
              chainId: l(this.chainId),
              data: c,
              from: o,
              gasLimit: l(this.gasLimit),
              gasPrice: l(this.gasPrice),
              hash: s,
              maxFeePerGas: l(this.maxFeePerGas),
              maxPriorityFeePerGas: l(this.maxPriorityFeePerGas),
              maxFeePerBlobGas: l(this.maxFeePerBlobGas),
              nonce: u,
              signature: d,
              to: a,
              index: n,
              type: i,
              value: l(this.value),
            };
          }
          async getBlock() {
            let e = this.blockNumber;
            if (null == e) {
              let t = await this.getTransaction();
              t && (e = t.blockNumber);
            }
            if (null == e) return null;
            let t = this.provider.getBlock(e);
            if (null == t) throw Error("TODO");
            return t;
          }
          async getTransaction() {
            return this.provider.getTransaction(this.hash);
          }
          async confirmations() {
            if (null == this.blockNumber) {
              let { tx: e, blockNumber: t } = await (0, s.resolveProperties)({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber(),
              });
              return null == e || null == e.blockNumber
                ? 0
                : t - e.blockNumber + 1;
            }
            return (
              (await this.provider.getBlockNumber()) - this.blockNumber + 1
            );
          }
          async wait(e, t) {
            let n = null == e ? 1 : e,
              i = null == t ? 0 : t,
              o = this.#eL,
              l = -1,
              u = -1 === o,
              c = async () => {
                if (u) return null;
                let { blockNumber: e, nonce: t } = await (0,
                s.resolveProperties)({
                  blockNumber: this.provider.getBlockNumber(),
                  nonce: this.provider.getTransactionCount(this.from),
                });
                if (t < this.nonce) {
                  o = e;
                  return;
                }
                if (u) return null;
                let i = await this.getTransaction();
                if (!i || null == i.blockNumber)
                  for (
                    -1 === l && (l = o - 3) < this.#eL && (l = this.#eL);
                    l <= e;

                  ) {
                    if (u) return null;
                    let t = await this.provider.getBlock(l, !0);
                    if (null == t) break;
                    for (let e of t) if (e === this.hash) return;
                    for (let i = 0; i < t.length; i++) {
                      let l = await t.getTransaction(i);
                      if (l.from === this.from && l.nonce === this.nonce) {
                        if (u) return null;
                        let t = await this.provider.getTransactionReceipt(
                          l.hash
                        );
                        if (null == t || e - t.blockNumber + 1 < n) return;
                        let i = "replaced";
                        l.data === this.data &&
                        l.to === this.to &&
                        l.value === this.value
                          ? (i = "repriced")
                          : "0x" === l.data &&
                            l.from === l.to &&
                            l.value === a &&
                            (i = "cancelled"),
                          (0, s.assert)(
                            !1,
                            "transaction was replaced",
                            "TRANSACTION_REPLACED",
                            {
                              cancelled: "replaced" === i || "cancelled" === i,
                              reason: i,
                              replacement: l.replaceableTransaction(o),
                              hash: l.hash,
                              receipt: t,
                            }
                          );
                      }
                    }
                    l++;
                  }
              },
              d = (e) => {
                if (null == e || 0 !== e.status) return e;
                (0, s.assert)(
                  !1,
                  "transaction execution reverted",
                  "CALL_EXCEPTION",
                  {
                    action: "sendTransaction",
                    data: null,
                    reason: null,
                    invocation: null,
                    revert: null,
                    transaction: { to: e.to, from: e.from, data: "" },
                    receipt: e,
                  }
                );
              },
              h = await this.provider.getTransactionReceipt(this.hash);
            if (0 === n) return d(h);
            if (h) {
              if ((await h.confirmations()) >= n) return d(h);
            } else if ((await c(), 0 === n)) return null;
            let p = new Promise((e, t) => {
              let a = [],
                l = () => {
                  a.forEach((e) => e());
                };
              if (
                (a.push(() => {
                  u = !0;
                }),
                i > 0)
              ) {
                let e = setTimeout(() => {
                  l(),
                    t(
                      (0, s.makeError)(
                        "wait for transaction timeout",
                        "TIMEOUT"
                      )
                    );
                }, i);
                a.push(() => {
                  clearTimeout(e);
                });
              }
              let h = async (s) => {
                if ((await s.confirmations()) >= n) {
                  l();
                  try {
                    e(d(s));
                  } catch (e) {
                    t(e);
                  }
                }
              };
              if (
                (a.push(() => {
                  this.provider.off(this.hash, h);
                }),
                this.provider.on(this.hash, h),
                o >= 0)
              ) {
                let e = async () => {
                  try {
                    await c();
                  } catch (e) {
                    if ((0, s.isError)(e, "TRANSACTION_REPLACED")) {
                      l(), t(e);
                      return;
                    }
                  }
                  u || this.provider.once("block", e);
                };
                a.push(() => {
                  this.provider.off("block", e);
                }),
                  this.provider.once("block", e);
              }
            });
            return await p;
          }
          isMined() {
            return null != this.blockHash;
          }
          isLegacy() {
            return 0 === this.type;
          }
          isBerlin() {
            return 1 === this.type;
          }
          isLondon() {
            return 2 === this.type;
          }
          isCancun() {
            return 3 === this.type;
          }
          removedEvent() {
            return (
              (0, s.assert)(
                this.isMined(),
                "unmined transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              g(this)
            );
          }
          reorderedEvent(e) {
            return (
              (0, s.assert)(
                this.isMined(),
                "unmined transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              (0, s.assert)(
                !e || e.isMined(),
                "unmined 'other' transaction canot be orphaned",
                "UNSUPPORTED_OPERATION",
                { operation: "removeEvent()" }
              ),
              f(this, e)
            );
          }
          replaceableTransaction(e) {
            (0, s.assertArgument)(
              Number.isInteger(e) && e >= 0,
              "invalid startBlock",
              "startBlock",
              e
            );
            let t = new p(this, this.provider);
            return (t.#eL = e), t;
          }
        }
        function f(e, t) {
          return { orphan: "reorder-transaction", tx: e, other: t };
        }
        function g(e) {
          return { orphan: "drop-transaction", tx: e };
        }
        t.TransactionResponse = p;
      },
      22992: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NonceManager = void 0);
        let s = n(42120),
          i = n(35649);
        class a extends i.AbstractSigner {
          signer;
          #e_;
          #eF;
          constructor(e) {
            super(e.provider),
              (0, s.defineProperties)(this, { signer: e }),
              (this.#e_ = null),
              (this.#eF = 0);
          }
          async getAddress() {
            return this.signer.getAddress();
          }
          connect(e) {
            return new a(this.signer.connect(e));
          }
          async getNonce(e) {
            if ("pending" === e) {
              null == this.#e_ && (this.#e_ = super.getNonce("pending"));
              let e = this.#eF;
              return (await this.#e_) + e;
            }
            return super.getNonce(e);
          }
          increment() {
            this.#eF++;
          }
          reset() {
            (this.#eF = 0), (this.#e_ = null);
          }
          async sendTransaction(e) {
            let t = this.getNonce("pending");
            return (
              this.increment(),
              ((e = await this.signer.populateTransaction(e)).nonce = await t),
              await this.signer.sendTransaction(e)
            );
          }
          signTransaction(e) {
            return this.signer.signTransaction(e);
          }
          signMessage(e) {
            return this.signer.signMessage(e);
          }
          signTypedData(e, t, n) {
            return this.signer.signTypedData(e, t, n);
          }
        }
        t.NonceManager = a;
      },
      21570: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FilterIdPendingSubscriber =
            t.FilterIdEventSubscriber =
            t.FilterIdSubscriber =
              void 0);
        let s = n(42120),
          i = n(21097);
        class a {
          #eT;
          #eD;
          #eU;
          #ej;
          #ew;
          #eH;
          constructor(e) {
            (this.#eT = e),
              (this.#eD = null),
              (this.#eU = this.#e$.bind(this)),
              (this.#ej = !1),
              (this.#ew = null),
              (this.#eH = !1);
          }
          _subscribe(e) {
            throw Error("subclasses must override this");
          }
          _emitResults(e, t) {
            throw Error("subclasses must override this");
          }
          _recover(e) {
            throw Error("subclasses must override this");
          }
          async #e$(e) {
            try {
              null == this.#eD && (this.#eD = this._subscribe(this.#eT));
              let e = null;
              try {
                e = await this.#eD;
              } catch (e) {
                if (
                  !(0, s.isError)(e, "UNSUPPORTED_OPERATION") ||
                  "eth_newFilter" !== e.operation
                )
                  throw e;
              }
              if (null == e) {
                (this.#eD = null),
                  this.#eT._recoverSubscriber(this, this._recover(this.#eT));
                return;
              }
              let t = await this.#eT.getNetwork();
              if ((this.#ew || (this.#ew = t), this.#ew.chainId !== t.chainId))
                throw Error("chaid changed");
              if (this.#eH) return;
              let n = await this.#eT.send("eth_getFilterChanges", [e]);
              await this._emitResults(this.#eT, n);
            } catch (e) {
              console.log("@TODO", e);
            }
            this.#eT.once("block", this.#eU);
          }
          #eG() {
            let e = this.#eD;
            e &&
              ((this.#eD = null),
              e.then((e) => {
                this.#eT.destroyed || this.#eT.send("eth_uninstallFilter", [e]);
              }));
          }
          start() {
            this.#ej || ((this.#ej = !0), this.#e$(-2));
          }
          stop() {
            this.#ej &&
              ((this.#ej = !1),
              (this.#eH = !0),
              this.#eG(),
              this.#eT.off("block", this.#eU));
          }
          pause(e) {
            e && this.#eG(), this.#eT.off("block", this.#eU);
          }
          resume() {
            this.start();
          }
        }
        t.FilterIdSubscriber = a;
        class o extends a {
          #eK;
          constructor(e, t) {
            super(e), (this.#eK = JSON.parse(JSON.stringify(t)));
          }
          _recover(e) {
            return new i.PollingEventSubscriber(e, this.#eK);
          }
          async _subscribe(e) {
            return await e.send("eth_newFilter", [this.#eK]);
          }
          async _emitResults(e, t) {
            for (let n of t) e.emit(this.#eK, e._wrapLog(n, e._network));
          }
        }
        t.FilterIdEventSubscriber = o;
        class l extends a {
          async _subscribe(e) {
            return await e.send("eth_newPendingTransactionFilter", []);
          }
          async _emitResults(e, t) {
            for (let n of t) e.emit("pending", n);
          }
        }
        t.FilterIdPendingSubscriber = l;
      },
      21097: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PollingEventSubscriber =
            t.PollingTransactionSubscriber =
            t.PollingOrphanSubscriber =
            t.PollingBlockTagSubscriber =
            t.OnBlockSubscriber =
            t.PollingBlockSubscriber =
            t.getPollingSubscriber =
              void 0);
        let s = n(42120);
        function i(e) {
          return JSON.parse(JSON.stringify(e));
        }
        t.getPollingSubscriber = function (e, t) {
          return "block" === t
            ? new a(e)
            : (0, s.isHexString)(t, 32)
            ? new c(e, t)
            : void (0, s.assert)(
                !1,
                "unsupported polling event",
                "UNSUPPORTED_OPERATION",
                { operation: "getPollingSubscriber", info: { event: t } }
              );
        };
        class a {
          #eT;
          #eU;
          #eV;
          #ez;
          constructor(e) {
            (this.#eT = e),
              (this.#eU = null),
              (this.#eV = 4e3),
              (this.#ez = -2);
          }
          get pollingInterval() {
            return this.#eV;
          }
          set pollingInterval(e) {
            this.#eV = e;
          }
          async #e$() {
            try {
              let e = await this.#eT.getBlockNumber();
              if (-2 === this.#ez) {
                this.#ez = e;
                return;
              }
              if (e !== this.#ez) {
                for (let t = this.#ez + 1; t <= e; t++) {
                  if (null == this.#eU) return;
                  await this.#eT.emit("block", t);
                }
                this.#ez = e;
              }
            } catch (e) {}
            null != this.#eU &&
              (this.#eU = this.#eT._setTimeout(this.#e$.bind(this), this.#eV));
          }
          start() {
            this.#eU ||
              ((this.#eU = this.#eT._setTimeout(this.#e$.bind(this), this.#eV)),
              this.#e$());
          }
          stop() {
            this.#eU && (this.#eT._clearTimeout(this.#eU), (this.#eU = null));
          }
          pause(e) {
            this.stop(), e && (this.#ez = -2);
          }
          resume() {
            this.start();
          }
        }
        t.PollingBlockSubscriber = a;
        class o {
          #eT;
          #e$;
          #ej;
          constructor(e) {
            (this.#eT = e),
              (this.#ej = !1),
              (this.#e$ = (e) => {
                this._poll(e, this.#eT);
              });
          }
          async _poll(e, t) {
            throw Error("sub-classes must override this");
          }
          start() {
            this.#ej ||
              ((this.#ej = !0), this.#e$(-2), this.#eT.on("block", this.#e$));
          }
          stop() {
            this.#ej && ((this.#ej = !1), this.#eT.off("block", this.#e$));
          }
          pause(e) {
            this.stop();
          }
          resume() {
            this.start();
          }
        }
        t.OnBlockSubscriber = o;
        class l extends o {
          #eJ;
          #eQ;
          constructor(e, t) {
            super(e), (this.#eJ = t), (this.#eQ = -2);
          }
          pause(e) {
            e && (this.#eQ = -2), super.pause(e);
          }
          async _poll(e, t) {
            let n = await t.getBlock(this.#eJ);
            null != n &&
              (-2 === this.#eQ
                ? (this.#eQ = n.number)
                : n.number > this.#eQ &&
                  (t.emit(this.#eJ, n.number), (this.#eQ = n.number)));
          }
        }
        t.PollingBlockTagSubscriber = l;
        class u extends o {
          #v;
          constructor(e, t) {
            super(e), (this.#v = i(t));
          }
          async _poll(e, t) {
            throw Error("@TODO");
          }
        }
        t.PollingOrphanSubscriber = u;
        class c extends o {
          #eq;
          constructor(e, t) {
            super(e), (this.#eq = t);
          }
          async _poll(e, t) {
            let n = await t.getTransactionReceipt(this.#eq);
            n && t.emit(this.#eq, n);
          }
        }
        t.PollingTransactionSubscriber = c;
        class d {
          #eT;
          #v;
          #eU;
          #ej;
          #ez;
          constructor(e, t) {
            (this.#eT = e),
              (this.#v = i(t)),
              (this.#eU = this.#e$.bind(this)),
              (this.#ej = !1),
              (this.#ez = -2);
          }
          async #e$(e) {
            if (-2 === this.#ez) return;
            let t = i(this.#v);
            (t.fromBlock = this.#ez + 1), (t.toBlock = e);
            let n = await this.#eT.getLogs(t);
            if (0 === n.length) {
              this.#ez < e - 60 && (this.#ez = e - 60);
              return;
            }
            for (let e of n)
              this.#eT.emit(this.#v, e), (this.#ez = e.blockNumber);
          }
          start() {
            this.#ej ||
              ((this.#ej = !0),
              -2 === this.#ez &&
                this.#eT.getBlockNumber().then((e) => {
                  this.#ez = e;
                }),
              this.#eT.on("block", this.#eU));
          }
          stop() {
            this.#ej && ((this.#ej = !1), this.#eT.off("block", this.#eU));
          }
          pause(e) {
            this.stop(), e && (this.#ez = -2);
          }
          resume() {
            this.start();
          }
        }
        t.PollingEventSubscriber = d;
      },
      19817: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.WebSocket = void 0);
        let s = (function () {
          if ("undefined" != typeof self) return self;
          if ("undefined" != typeof window) return window;
          if (void 0 !== n.g) return n.g;
          throw Error("unable to locate global object");
        })().WebSocket;
        t.WebSocket = s;
      },
      484: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.accessListify = void 0);
        let s = n(45475),
          i = n(42120);
        function a(e, t) {
          return {
            address: (0, s.getAddress)(e),
            storageKeys: t.map(
              (e, t) => (
                (0, i.assertArgument)(
                  (0, i.isHexString)(e, 32),
                  "invalid slot",
                  `storageKeys[${t}]`,
                  e
                ),
                e.toLowerCase()
              )
            ),
          };
        }
        t.accessListify = function (e) {
          if (Array.isArray(e))
            return e.map((t, n) =>
              Array.isArray(t)
                ? ((0, i.assertArgument)(
                    2 === t.length,
                    "invalid slot set",
                    `value[${n}]`,
                    t
                  ),
                  a(t[0], t[1]))
                : ((0, i.assertArgument)(
                    null != t && "object" == typeof t,
                    "invalid address-slot set",
                    "value",
                    e
                  ),
                  a(t.address, t.storageKeys))
            );
          (0, i.assertArgument)(
            null != e && "object" == typeof e,
            "invalid access list",
            "value",
            e
          );
          let t = Object.keys(e).map((t) => {
            let n = e[t].reduce((e, t) => ((e[t] = !0), e), {});
            return a(t, Object.keys(n).sort());
          });
          return t.sort((e, t) => e.address.localeCompare(t.address)), t;
        };
      },
      17782: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.recoverAddress = t.computeAddress = void 0);
        let s = n(45475),
          i = n(96965);
        function a(e) {
          let t;
          return (
            (t =
              "string" == typeof e
                ? i.SigningKey.computePublicKey(e, !1)
                : e.publicKey),
            (0, s.getAddress)(
              (0, i.keccak256)("0x" + t.substring(4)).substring(26)
            )
          );
        }
        (t.computeAddress = a),
          (t.recoverAddress = function (e, t) {
            return a(i.SigningKey.recoverPublicKey(e, t));
          });
      },
      2290: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Transaction =
            t.recoverAddress =
            t.computeAddress =
            t.accessListify =
              void 0);
        var s = n(484);
        Object.defineProperty(t, "accessListify", {
          enumerable: !0,
          get: function () {
            return s.accessListify;
          },
        });
        var i = n(17782);
        Object.defineProperty(t, "computeAddress", {
          enumerable: !0,
          get: function () {
            return i.computeAddress;
          },
        }),
          Object.defineProperty(t, "recoverAddress", {
            enumerable: !0,
            get: function () {
              return i.recoverAddress;
            },
          });
        var a = n(31541);
        Object.defineProperty(t, "Transaction", {
          enumerable: !0,
          get: function () {
            return a.Transaction;
          },
        });
      },
      31541: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Transaction = void 0);
        let s = n(45475),
          i = n(23223),
          a = n(96965),
          o = n(42120),
          l = n(484),
          u = n(17782),
          c = BigInt(0),
          d = BigInt(2),
          h = BigInt(27),
          p = BigInt(28),
          f = BigInt(35),
          g = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
          );
        function m(e, t) {
          let n = e.toString(16);
          for (; n.length < 2; ) n = "0" + n;
          return "0x" + (n += (0, a.sha256)(t).substring(4));
        }
        function y(e) {
          return "0x" === e ? null : (0, s.getAddress)(e);
        }
        function b(e, t) {
          try {
            return (0, l.accessListify)(e);
          } catch (n) {
            (0, o.assertArgument)(!1, n.message, t, e);
          }
        }
        function A(e, t) {
          return "0x" === e ? 0 : (0, o.getNumber)(e, t);
        }
        function w(e, t) {
          if ("0x" === e) return c;
          let n = (0, o.getBigInt)(e, t);
          return (
            (0, o.assertArgument)(n <= g, "value exceeds uint size", t, n), n
          );
        }
        function v(e, t) {
          let n = (0, o.getBigInt)(e, "value"),
            s = (0, o.toBeArray)(n);
          return (
            (0, o.assertArgument)(
              s.length <= 32,
              "value too large",
              `tx.${t}`,
              n
            ),
            s
          );
        }
        function E(e) {
          return (0, l.accessListify)(e).map((e) => [e.address, e.storageKeys]);
        }
        function P(e, t) {
          let n;
          try {
            if (((n = A(t[0], "yParity")), 0 !== n && 1 !== n))
              throw Error("bad yParity");
          } catch (e) {
            (0, o.assertArgument)(!1, "invalid yParity", "yParity", t[0]);
          }
          let s = (0, o.zeroPadValue)(t[1], 32),
            i = (0, o.zeroPadValue)(t[2], 32),
            l = a.Signature.from({ r: s, s: i, yParity: n });
          e.signature = l;
        }
        class k {
          #eW;
          #eY;
          #r;
          #eZ;
          #eX;
          #e0;
          #e1;
          #e2;
          #e3;
          #er;
          #e4;
          #e6;
          #e5;
          #e8;
          #e7;
          #e9;
          get type() {
            return this.#eW;
          }
          set type(e) {
            switch (e) {
              case null:
                this.#eW = null;
                break;
              case 0:
              case "legacy":
                this.#eW = 0;
                break;
              case 1:
              case "berlin":
              case "eip-2930":
                this.#eW = 1;
                break;
              case 2:
              case "london":
              case "eip-1559":
                this.#eW = 2;
                break;
              case 3:
              case "cancun":
              case "eip-4844":
                this.#eW = 3;
                break;
              default:
                (0, o.assertArgument)(
                  !1,
                  "unsupported transaction type",
                  "type",
                  e
                );
            }
          }
          get typeName() {
            switch (this.type) {
              case 0:
                return "legacy";
              case 1:
                return "eip-2930";
              case 2:
                return "eip-1559";
              case 3:
                return "eip-4844";
            }
            return null;
          }
          get to() {
            let e = this.#eY;
            return null == e && 3 === this.type ? i.ZeroAddress : e;
          }
          set to(e) {
            this.#eY = null == e ? null : (0, s.getAddress)(e);
          }
          get nonce() {
            return this.#eZ;
          }
          set nonce(e) {
            this.#eZ = (0, o.getNumber)(e, "value");
          }
          get gasLimit() {
            return this.#eX;
          }
          set gasLimit(e) {
            this.#eX = (0, o.getBigInt)(e);
          }
          get gasPrice() {
            let e = this.#e0;
            return null == e && (0 === this.type || 1 === this.type) ? c : e;
          }
          set gasPrice(e) {
            this.#e0 = null == e ? null : (0, o.getBigInt)(e, "gasPrice");
          }
          get maxPriorityFeePerGas() {
            let e = this.#e1;
            return null == e
              ? 2 === this.type || 3 === this.type
                ? c
                : null
              : e;
          }
          set maxPriorityFeePerGas(e) {
            this.#e1 =
              null == e ? null : (0, o.getBigInt)(e, "maxPriorityFeePerGas");
          }
          get maxFeePerGas() {
            let e = this.#e2;
            return null == e
              ? 2 === this.type || 3 === this.type
                ? c
                : null
              : e;
          }
          set maxFeePerGas(e) {
            this.#e2 = null == e ? null : (0, o.getBigInt)(e, "maxFeePerGas");
          }
          get data() {
            return this.#r;
          }
          set data(e) {
            this.#r = (0, o.hexlify)(e);
          }
          get value() {
            return this.#e3;
          }
          set value(e) {
            this.#e3 = (0, o.getBigInt)(e, "value");
          }
          get chainId() {
            return this.#er;
          }
          set chainId(e) {
            this.#er = (0, o.getBigInt)(e);
          }
          get signature() {
            return this.#e4 || null;
          }
          set signature(e) {
            this.#e4 = null == e ? null : a.Signature.from(e);
          }
          get accessList() {
            let e = this.#e6 || null;
            return null == e
              ? 1 === this.type || 2 === this.type || 3 === this.type
                ? []
                : null
              : e;
          }
          set accessList(e) {
            this.#e6 = null == e ? null : (0, l.accessListify)(e);
          }
          get maxFeePerBlobGas() {
            let e = this.#e5;
            return null == e && 3 === this.type ? c : e;
          }
          set maxFeePerBlobGas(e) {
            this.#e5 =
              null == e ? null : (0, o.getBigInt)(e, "maxFeePerBlobGas");
          }
          get blobVersionedHashes() {
            let e = this.#e8;
            return null == e && 3 === this.type ? [] : e;
          }
          set blobVersionedHashes(e) {
            if (null != e) {
              (0, o.assertArgument)(
                Array.isArray(e),
                "blobVersionedHashes must be an Array",
                "value",
                e
              ),
                (e = e.slice());
              for (let t = 0; t < e.length; t++)
                (0, o.assertArgument)(
                  (0, o.isHexString)(e[t], 32),
                  "invalid blobVersionedHash",
                  `value[${t}]`,
                  e[t]
                );
            }
            this.#e8 = e;
          }
          get blobs() {
            return null == this.#e9
              ? null
              : this.#e9.map((e) => Object.assign({}, e));
          }
          set blobs(e) {
            if (null == e) {
              this.#e9 = null;
              return;
            }
            let t = [],
              n = [];
            for (let s = 0; s < e.length; s++) {
              let i = e[s];
              if ((0, o.isBytesLike)(i)) {
                (0, o.assert)(
                  this.#e7,
                  "adding a raw blob requires a KZG library",
                  "UNSUPPORTED_OPERATION",
                  { operation: "set blobs()" }
                );
                let e = (0, o.getBytes)(i);
                if (
                  ((0, o.assertArgument)(
                    e.length <= 131072,
                    "blob is too large",
                    `blobs[${s}]`,
                    i
                  ),
                  131072 !== e.length)
                ) {
                  let t = new Uint8Array(131072);
                  t.set(e), (e = t);
                }
                let a = this.#e7.blobToKzgCommitment(e),
                  l = (0, o.hexlify)(this.#e7.computeBlobKzgProof(e, a));
                t.push({
                  data: (0, o.hexlify)(e),
                  commitment: (0, o.hexlify)(a),
                  proof: l,
                }),
                  n.push(m(1, a));
              } else {
                let e = (0, o.hexlify)(i.commitment);
                t.push({
                  data: (0, o.hexlify)(i.data),
                  commitment: e,
                  proof: (0, o.hexlify)(i.proof),
                }),
                  n.push(m(1, e));
              }
            }
            (this.#e9 = t), (this.#e8 = n);
          }
          get kzg() {
            return this.#e7;
          }
          set kzg(e) {
            this.#e7 = e;
          }
          constructor() {
            (this.#eW = null),
              (this.#eY = null),
              (this.#eZ = 0),
              (this.#eX = c),
              (this.#e0 = null),
              (this.#e1 = null),
              (this.#e2 = null),
              (this.#r = "0x"),
              (this.#e3 = c),
              (this.#er = c),
              (this.#e4 = null),
              (this.#e6 = null),
              (this.#e5 = null),
              (this.#e8 = null),
              (this.#e9 = null),
              (this.#e7 = null);
          }
          get hash() {
            return null == this.signature
              ? null
              : (0, a.keccak256)(this.#te(!0, !1));
          }
          get unsignedHash() {
            return (0, a.keccak256)(this.unsignedSerialized);
          }
          get from() {
            return null == this.signature
              ? null
              : (0, u.recoverAddress)(this.unsignedHash, this.signature);
          }
          get fromPublicKey() {
            return null == this.signature
              ? null
              : a.SigningKey.recoverPublicKey(
                  this.unsignedHash,
                  this.signature
                );
          }
          isSigned() {
            return null != this.signature;
          }
          #te(e, t) {
            (0, o.assert)(
              !e || null != this.signature,
              "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized",
              "UNSUPPORTED_OPERATION",
              { operation: ".serialized" }
            );
            let n = e ? this.signature : null;
            switch (this.inferType()) {
              case 0:
                return (function (e, t) {
                  let n = [
                      v(e.nonce, "nonce"),
                      v(e.gasPrice || 0, "gasPrice"),
                      v(e.gasLimit, "gasLimit"),
                      e.to || "0x",
                      v(e.value, "value"),
                      e.data,
                    ],
                    s = c;
                  if (e.chainId != c)
                    (s = (0, o.getBigInt)(e.chainId, "tx.chainId")),
                      (0, o.assertArgument)(
                        !t || null == t.networkV || t.legacyChainId === s,
                        "tx.chainId/sig.v mismatch",
                        "sig",
                        t
                      );
                  else if (e.signature) {
                    let t = e.signature.legacyChainId;
                    null != t && (s = t);
                  }
                  if (!t)
                    return (
                      s !== c &&
                        (n.push((0, o.toBeArray)(s)),
                        n.push("0x"),
                        n.push("0x")),
                      (0, o.encodeRlp)(n)
                    );
                  let i = BigInt(27 + t.yParity);
                  return (
                    s !== c
                      ? (i = a.Signature.getChainIdV(s, t.v))
                      : BigInt(t.v) !== i &&
                        (0, o.assertArgument)(
                          !1,
                          "tx.chainId/sig.v mismatch",
                          "sig",
                          t
                        ),
                    n.push((0, o.toBeArray)(i)),
                    n.push((0, o.toBeArray)(t.r)),
                    n.push((0, o.toBeArray)(t.s)),
                    (0, o.encodeRlp)(n)
                  );
                })(this, n);
              case 1:
                return (function (e, t) {
                  let n = [
                    v(e.chainId, "chainId"),
                    v(e.nonce, "nonce"),
                    v(e.gasPrice || 0, "gasPrice"),
                    v(e.gasLimit, "gasLimit"),
                    e.to || "0x",
                    v(e.value, "value"),
                    e.data,
                    E(e.accessList || []),
                  ];
                  return (
                    t &&
                      (n.push(v(t.yParity, "recoveryParam")),
                      n.push((0, o.toBeArray)(t.r)),
                      n.push((0, o.toBeArray)(t.s))),
                    (0, o.concat)(["0x01", (0, o.encodeRlp)(n)])
                  );
                })(this, n);
              case 2:
                return (function (e, t) {
                  let n = [
                    v(e.chainId, "chainId"),
                    v(e.nonce, "nonce"),
                    v(e.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
                    v(e.maxFeePerGas || 0, "maxFeePerGas"),
                    v(e.gasLimit, "gasLimit"),
                    e.to || "0x",
                    v(e.value, "value"),
                    e.data,
                    E(e.accessList || []),
                  ];
                  return (
                    t &&
                      (n.push(v(t.yParity, "yParity")),
                      n.push((0, o.toBeArray)(t.r)),
                      n.push((0, o.toBeArray)(t.s))),
                    (0, o.concat)(["0x02", (0, o.encodeRlp)(n)])
                  );
                })(this, n);
              case 3:
                return (function (e, t, n) {
                  let s = [
                    v(e.chainId, "chainId"),
                    v(e.nonce, "nonce"),
                    v(e.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
                    v(e.maxFeePerGas || 0, "maxFeePerGas"),
                    v(e.gasLimit, "gasLimit"),
                    e.to || i.ZeroAddress,
                    v(e.value, "value"),
                    e.data,
                    E(e.accessList || []),
                    v(e.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
                    (function (e, t) {
                      (0, o.assertArgument)(
                        Array.isArray(e),
                        `invalid ${t}`,
                        "value",
                        e
                      );
                      for (let t = 0; t < e.length; t++)
                        (0, o.assertArgument)(
                          (0, o.isHexString)(e[t], 32),
                          "invalid ${ param } hash",
                          `value[${t}]`,
                          e[t]
                        );
                      return e;
                    })(e.blobVersionedHashes || [], "blobVersionedHashes"),
                  ];
                  return t &&
                    (s.push(v(t.yParity, "yParity")),
                    s.push((0, o.toBeArray)(t.r)),
                    s.push((0, o.toBeArray)(t.s)),
                    n)
                    ? (0, o.concat)([
                        "0x03",
                        (0, o.encodeRlp)([
                          s,
                          n.map((e) => e.data),
                          n.map((e) => e.commitment),
                          n.map((e) => e.proof),
                        ]),
                      ])
                    : (0, o.concat)(["0x03", (0, o.encodeRlp)(s)]);
                })(this, n, t ? this.blobs : null);
            }
            (0, o.assert)(
              !1,
              "unsupported transaction type",
              "UNSUPPORTED_OPERATION",
              { operation: ".serialized" }
            );
          }
          get serialized() {
            return this.#te(!0, !0);
          }
          get unsignedSerialized() {
            return this.#te(!1, !1);
          }
          inferType() {
            let e = this.inferTypes();
            return e.indexOf(2) >= 0 ? 2 : e.pop();
          }
          inferTypes() {
            let e = null != this.gasPrice,
              t =
                null != this.maxFeePerGas || null != this.maxPriorityFeePerGas,
              n = null != this.accessList,
              s = null != this.#e5 || this.#e8;
            null != this.maxFeePerGas &&
              null != this.maxPriorityFeePerGas &&
              (0, o.assert)(
                this.maxFeePerGas >= this.maxPriorityFeePerGas,
                "priorityFee cannot be more than maxFee",
                "BAD_DATA",
                { value: this }
              ),
              (0, o.assert)(
                !t || (0 !== this.type && 1 !== this.type),
                "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas",
                "BAD_DATA",
                { value: this }
              ),
              (0, o.assert)(
                0 !== this.type || !n,
                "legacy transaction cannot have accessList",
                "BAD_DATA",
                { value: this }
              );
            let i = [];
            return (
              null != this.type
                ? i.push(this.type)
                : t
                ? i.push(2)
                : e
                ? (i.push(1), n || i.push(0))
                : n
                ? (i.push(1), i.push(2))
                : ((s && this.to) || (i.push(0), i.push(1), i.push(2)),
                  i.push(3)),
              i.sort(),
              i
            );
          }
          isLegacy() {
            return 0 === this.type;
          }
          isBerlin() {
            return 1 === this.type;
          }
          isLondon() {
            return 2 === this.type;
          }
          isCancun() {
            return 3 === this.type;
          }
          clone() {
            return k.from(this);
          }
          toJSON() {
            let e = (e) => (null == e ? null : e.toString());
            return {
              type: this.type,
              to: this.to,
              data: this.data,
              nonce: this.nonce,
              gasLimit: e(this.gasLimit),
              gasPrice: e(this.gasPrice),
              maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
              maxFeePerGas: e(this.maxFeePerGas),
              value: e(this.value),
              chainId: e(this.chainId),
              sig: this.signature ? this.signature.toJSON() : null,
              accessList: this.accessList,
            };
          }
          static from(e) {
            if (null == e) return new k();
            if ("string" == typeof e) {
              let t = (0, o.getBytes)(e);
              if (t[0] >= 127)
                return k.from(
                  (function (e) {
                    let t = (0, o.decodeRlp)(e);
                    (0, o.assertArgument)(
                      Array.isArray(t) && (9 === t.length || 6 === t.length),
                      "invalid field count for legacy transaction",
                      "data",
                      e
                    );
                    let n = {
                      type: 0,
                      nonce: A(t[0], "nonce"),
                      gasPrice: w(t[1], "gasPrice"),
                      gasLimit: w(t[2], "gasLimit"),
                      to: y(t[3]),
                      value: w(t[4], "value"),
                      data: (0, o.hexlify)(t[5]),
                      chainId: c,
                    };
                    if (6 === t.length) return n;
                    let s = w(t[6], "v"),
                      i = w(t[7], "r"),
                      l = w(t[8], "s");
                    if (i === c && l === c) n.chainId = s;
                    else {
                      let e = (s - f) / d;
                      e < c && (e = c),
                        (n.chainId = e),
                        (0, o.assertArgument)(
                          e !== c || s === h || s === p,
                          "non-canonical legacy v",
                          "v",
                          t[6]
                        ),
                        (n.signature = a.Signature.from({
                          r: (0, o.zeroPadValue)(t[7], 32),
                          s: (0, o.zeroPadValue)(t[8], 32),
                          v: s,
                        }));
                    }
                    return n;
                  })(t)
                );
              switch (t[0]) {
                case 1:
                  return k.from(
                    (function (e) {
                      let t = (0, o.decodeRlp)((0, o.getBytes)(e).slice(1));
                      (0, o.assertArgument)(
                        Array.isArray(t) && (8 === t.length || 11 === t.length),
                        "invalid field count for transaction type: 1",
                        "data",
                        (0, o.hexlify)(e)
                      );
                      let n = {
                        type: 1,
                        chainId: w(t[0], "chainId"),
                        nonce: A(t[1], "nonce"),
                        gasPrice: w(t[2], "gasPrice"),
                        gasLimit: w(t[3], "gasLimit"),
                        to: y(t[4]),
                        value: w(t[5], "value"),
                        data: (0, o.hexlify)(t[6]),
                        accessList: b(t[7], "accessList"),
                      };
                      return 8 === t.length || P(n, t.slice(8)), n;
                    })(t)
                  );
                case 2:
                  return k.from(
                    (function (e) {
                      let t = (0, o.decodeRlp)((0, o.getBytes)(e).slice(1));
                      (0, o.assertArgument)(
                        Array.isArray(t) && (9 === t.length || 12 === t.length),
                        "invalid field count for transaction type: 2",
                        "data",
                        (0, o.hexlify)(e)
                      );
                      let n = {
                        type: 2,
                        chainId: w(t[0], "chainId"),
                        nonce: A(t[1], "nonce"),
                        maxPriorityFeePerGas: w(t[2], "maxPriorityFeePerGas"),
                        maxFeePerGas: w(t[3], "maxFeePerGas"),
                        gasPrice: null,
                        gasLimit: w(t[4], "gasLimit"),
                        to: y(t[5]),
                        value: w(t[6], "value"),
                        data: (0, o.hexlify)(t[7]),
                        accessList: b(t[8], "accessList"),
                      };
                      return 9 === t.length || P(n, t.slice(9)), n;
                    })(t)
                  );
                case 3:
                  return k.from(
                    (function (e) {
                      let t = (0, o.decodeRlp)((0, o.getBytes)(e).slice(1)),
                        n = "3",
                        s = null;
                      if (4 === t.length && Array.isArray(t[0])) {
                        n = "3 (network format)";
                        let e = t[1],
                          i = t[2],
                          a = t[3];
                        (0, o.assertArgument)(
                          Array.isArray(e),
                          "invalid network format: blobs not an array",
                          "fields[1]",
                          e
                        ),
                          (0, o.assertArgument)(
                            Array.isArray(i),
                            "invalid network format: commitments not an array",
                            "fields[2]",
                            i
                          ),
                          (0, o.assertArgument)(
                            Array.isArray(a),
                            "invalid network format: proofs not an array",
                            "fields[3]",
                            a
                          ),
                          (0, o.assertArgument)(
                            e.length === i.length,
                            "invalid network format: blobs/commitments length mismatch",
                            "fields",
                            t
                          ),
                          (0, o.assertArgument)(
                            e.length === a.length,
                            "invalid network format: blobs/proofs length mismatch",
                            "fields",
                            t
                          ),
                          (s = []);
                        for (let n = 0; n < t[1].length; n++)
                          s.push({ data: e[n], commitment: i[n], proof: a[n] });
                        t = t[0];
                      }
                      (0, o.assertArgument)(
                        Array.isArray(t) &&
                          (11 === t.length || 14 === t.length),
                        `invalid field count for transaction type: ${n}`,
                        "data",
                        (0, o.hexlify)(e)
                      );
                      let i = {
                        type: 3,
                        chainId: w(t[0], "chainId"),
                        nonce: A(t[1], "nonce"),
                        maxPriorityFeePerGas: w(t[2], "maxPriorityFeePerGas"),
                        maxFeePerGas: w(t[3], "maxFeePerGas"),
                        gasPrice: null,
                        gasLimit: w(t[4], "gasLimit"),
                        to: y(t[5]),
                        value: w(t[6], "value"),
                        data: (0, o.hexlify)(t[7]),
                        accessList: b(t[8], "accessList"),
                        maxFeePerBlobGas: w(t[9], "maxFeePerBlobGas"),
                        blobVersionedHashes: t[10],
                      };
                      s && (i.blobs = s),
                        (0, o.assertArgument)(
                          null != i.to,
                          `invalid address for transaction type: ${n}`,
                          "data",
                          e
                        ),
                        (0, o.assertArgument)(
                          Array.isArray(i.blobVersionedHashes),
                          "invalid blobVersionedHashes: must be an array",
                          "data",
                          e
                        );
                      for (let t = 0; t < i.blobVersionedHashes.length; t++)
                        (0, o.assertArgument)(
                          (0, o.isHexString)(i.blobVersionedHashes[t], 32),
                          `invalid blobVersionedHash at index ${t}: must be length 32`,
                          "data",
                          e
                        );
                      return 11 === t.length || P(i, t.slice(11)), i;
                    })(t)
                  );
              }
              (0, o.assert)(
                !1,
                "unsupported transaction type",
                "UNSUPPORTED_OPERATION",
                { operation: "from" }
              );
            }
            let t = new k();
            return (
              null != e.type && (t.type = e.type),
              null != e.to && (t.to = e.to),
              null != e.nonce && (t.nonce = e.nonce),
              null != e.gasLimit && (t.gasLimit = e.gasLimit),
              null != e.gasPrice && (t.gasPrice = e.gasPrice),
              null != e.maxPriorityFeePerGas &&
                (t.maxPriorityFeePerGas = e.maxPriorityFeePerGas),
              null != e.maxFeePerGas && (t.maxFeePerGas = e.maxFeePerGas),
              null != e.maxFeePerBlobGas &&
                (t.maxFeePerBlobGas = e.maxFeePerBlobGas),
              null != e.data && (t.data = e.data),
              null != e.value && (t.value = e.value),
              null != e.chainId && (t.chainId = e.chainId),
              null != e.signature &&
                (t.signature = a.Signature.from(e.signature)),
              null != e.accessList && (t.accessList = e.accessList),
              null != e.blobVersionedHashes &&
                (t.blobVersionedHashes = e.blobVersionedHashes),
              null != e.kzg && (t.kzg = e.kzg),
              null != e.blobs && (t.blobs = e.blobs),
              null != e.hash &&
                ((0, o.assertArgument)(
                  t.isSigned(),
                  "unsigned transaction cannot define '.hash'",
                  "tx",
                  e
                ),
                (0, o.assertArgument)(
                  t.hash === e.hash,
                  "hash mismatch",
                  "tx",
                  e
                )),
              null != e.from &&
                ((0, o.assertArgument)(
                  t.isSigned(),
                  "unsigned transaction cannot define '.from'",
                  "tx",
                  e
                ),
                (0, o.assertArgument)(
                  t.from.toLowerCase() === (e.from || "").toLowerCase(),
                  "from mismatch",
                  "tx",
                  e
                )),
              t
            );
          }
        }
        t.Transaction = k;
      },
      20349: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decodeBase58 = t.encodeBase58 = void 0);
        let s = n(86239),
          i = n(21766),
          a = n(90358),
          o = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
          l = null,
          u = BigInt(0),
          c = BigInt(58);
        (t.encodeBase58 = function (e) {
          let t = (0, s.getBytes)(e),
            n = (0, a.toBigInt)(t),
            i = "";
          for (; n; ) (i = o[Number(n % c)] + i), (n /= c);
          for (let e = 0; e < t.length && !t[e]; e++) i = o[0] + i;
          return i;
        }),
          (t.decodeBase58 = function (e) {
            let t = u;
            for (let n = 0; n < e.length; n++)
              (t *= c),
                (t += (function (e) {
                  if (null == l) {
                    l = {};
                    for (let e = 0; e < o.length; e++) l[o[e]] = BigInt(e);
                  }
                  let t = l[e];
                  return (
                    (0, i.assertArgument)(
                      null != t,
                      "invalid base58 value",
                      "letter",
                      e
                    ),
                    t
                  );
                })(e[n]));
            return t;
          });
      },
      66446: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.encodeBase64 = t.decodeBase64 = void 0);
        let s = n(86239);
        (t.decodeBase64 = function (e) {
          let t = new Uint8Array((e = atob(e)).length);
          for (let n = 0; n < e.length; n++) t[n] = e.charCodeAt(n);
          return (0, s.getBytes)(t);
        }),
          (t.encodeBase64 = function (e) {
            let t = (0, s.getBytes)(e),
              n = "";
            for (let e = 0; e < t.length; e++) n += String.fromCharCode(t[e]);
            return btoa(n);
          });
      },
      86239: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.zeroPadBytes =
            t.zeroPadValue =
            t.stripZerosLeft =
            t.dataSlice =
            t.dataLength =
            t.concat =
            t.hexlify =
            t.isBytesLike =
            t.isHexString =
            t.getBytesCopy =
            t.getBytes =
              void 0);
        let s = n(21766);
        function i(e, t, n) {
          if (e instanceof Uint8Array) return n ? new Uint8Array(e) : e;
          if ("string" == typeof e && e.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
            let t = new Uint8Array((e.length - 2) / 2),
              n = 2;
            for (let s = 0; s < t.length; s++)
              (t[s] = parseInt(e.substring(n, n + 2), 16)), (n += 2);
            return t;
          }
          (0, s.assertArgument)(!1, "invalid BytesLike value", t || "value", e);
        }
        function a(e, t) {
          return i(e, t, !1);
        }
        function o(e, t) {
          return (
            !!("string" == typeof e && e.match(/^0x[0-9A-Fa-f]*$/)) &&
            ("number" != typeof t || e.length === 2 + 2 * t) &&
            (!0 !== t || e.length % 2 == 0)
          );
        }
        (t.getBytes = a),
          (t.getBytesCopy = function (e, t) {
            return i(e, t, !0);
          }),
          (t.isHexString = o),
          (t.isBytesLike = function (e) {
            return o(e, !0) || e instanceof Uint8Array;
          });
        let l = "0123456789abcdef";
        function u(e) {
          let t = a(e),
            n = "0x";
          for (let e = 0; e < t.length; e++) {
            let s = t[e];
            n += l[(240 & s) >> 4] + l[15 & s];
          }
          return n;
        }
        function c(e, t, n) {
          let i = a(e);
          (0, s.assert)(
            t >= i.length,
            "padding exceeds data length",
            "BUFFER_OVERRUN",
            { buffer: new Uint8Array(i), length: t, offset: t + 1 }
          );
          let o = new Uint8Array(t);
          return o.fill(0), n ? o.set(i, t - i.length) : o.set(i, 0), u(o);
        }
        (t.hexlify = u),
          (t.concat = function (e) {
            return "0x" + e.map((e) => u(e).substring(2)).join("");
          }),
          (t.dataLength = function (e) {
            return o(e, !0) ? (e.length - 2) / 2 : a(e).length;
          }),
          (t.dataSlice = function (e, t, n) {
            let i = a(e);
            return (
              null != n &&
                n > i.length &&
                (0, s.assert)(
                  !1,
                  "cannot slice beyond data bounds",
                  "BUFFER_OVERRUN",
                  { buffer: i, length: i.length, offset: n }
                ),
              u(i.slice(null == t ? 0 : t, null == n ? i.length : n))
            );
          }),
          (t.stripZerosLeft = function (e) {
            let t = u(e).substring(2);
            for (; t.startsWith("00"); ) t = t.substring(2);
            return "0x" + t;
          }),
          (t.zeroPadValue = function (e, t) {
            return c(e, t, !0);
          }),
          (t.zeroPadBytes = function (e, t) {
            return c(e, t, !1);
          });
      },
      21766: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.assertPrivate =
            t.assertNormalize =
            t.assertArgumentCount =
            t.assertArgument =
            t.assert =
            t.makeError =
            t.isCallException =
            t.isError =
              void 0);
        let s = n(79406),
          i = n(39290);
        function a(e) {
          if (null == e) return "null";
          if (Array.isArray(e)) return "[ " + e.map(a).join(", ") + " ]";
          if (e instanceof Uint8Array) {
            let t = "0123456789abcdef",
              n = "0x";
            for (let s = 0; s < e.length; s++) n += t[e[s] >> 4] + t[15 & e[s]];
            return n;
          }
          if ("object" == typeof e && "function" == typeof e.toJSON)
            return a(e.toJSON());
          switch (typeof e) {
            case "boolean":
            case "symbol":
            case "number":
              return e.toString();
            case "bigint":
              return BigInt(e).toString();
            case "string":
              return JSON.stringify(e);
            case "object": {
              let t = Object.keys(e);
              return (
                t.sort(),
                "{ " + t.map((t) => `${a(t)}: ${a(e[t])}`).join(", ") + " }"
              );
            }
          }
          return "[ COULD NOT SERIALIZE ]";
        }
        function o(e, t) {
          return e && e.code === t;
        }
        function l(e, t, n) {
          let o,
            l = e;
          {
            let i = [];
            if (n) {
              if ("message" in n || "code" in n || "name" in n)
                throw Error(`value will overwrite populated values: ${a(n)}`);
              for (let e in n) {
                if ("shortMessage" === e) continue;
                let t = n[e];
                i.push(e + "=" + a(t));
              }
            }
            i.push(`code=${t}`),
              i.push(`version=${s.version}`),
              i.length && (e += " (" + i.join(", ") + ")");
          }
          switch (t) {
            case "INVALID_ARGUMENT":
              o = TypeError(e);
              break;
            case "NUMERIC_FAULT":
            case "BUFFER_OVERRUN":
              o = RangeError(e);
              break;
            default:
              o = Error(e);
          }
          return (
            (0, i.defineProperties)(o, { code: t }),
            n && Object.assign(o, n),
            null == o.shortMessage &&
              (0, i.defineProperties)(o, { shortMessage: l }),
            o
          );
        }
        function u(e, t, n, s) {
          if (!e) throw l(t, n, s);
        }
        (t.isError = o),
          (t.isCallException = function (e) {
            return o(e, "CALL_EXCEPTION");
          }),
          (t.makeError = l),
          (t.assert = u),
          (t.assertArgument = function (e, t, n, s) {
            u(e, t, "INVALID_ARGUMENT", { argument: n, value: s });
          }),
          (t.assertArgumentCount = function (e, t, n) {
            null == n && (n = ""),
              n && (n = ": " + n),
              u(e >= t, "missing argument" + n, "MISSING_ARGUMENT", {
                count: e,
                expectedCount: t,
              }),
              u(e <= t, "too many arguments" + n, "UNEXPECTED_ARGUMENT", {
                count: e,
                expectedCount: t,
              });
          });
        let c = ["NFD", "NFC", "NFKD", "NFKC"].reduce((e, t) => {
          try {
            if ("test" !== "test".normalize(t)) throw Error("bad");
            if ("NFD" === t) {
              let e = String.fromCharCode(233).normalize("NFD"),
                t = String.fromCharCode(101, 769);
              if (e !== t) throw Error("broken");
            }
            e.push(t);
          } catch (e) {}
          return e;
        }, []);
        (t.assertNormalize = function (e) {
          u(
            c.indexOf(e) >= 0,
            "platform missing String.prototype.normalize",
            "UNSUPPORTED_OPERATION",
            { operation: "String.prototype.normalize", info: { form: e } }
          );
        }),
          (t.assertPrivate = function (e, t, n) {
            if ((null == n && (n = ""), e !== t)) {
              let e = n,
                t = "new";
              n && ((e += "."), (t += " " + n)),
                u(
                  !1,
                  `private constructor; use ${e}from* methods`,
                  "UNSUPPORTED_OPERATION",
                  { operation: t }
                );
            }
          });
      },
      52203: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EventPayload = void 0);
        let s = n(39290);
        class i {
          filter;
          emitter;
          #tt;
          constructor(e, t, n) {
            (this.#tt = t),
              (0, s.defineProperties)(this, { emitter: e, filter: n });
          }
          async removeListener() {
            null != this.#tt && (await this.emitter.off(this.filter, this.#tt));
          }
        }
        t.EventPayload = i;
      },
      93654: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FetchResponse = t.FetchRequest = t.FetchCancelSignal = void 0);
        let s = n(66446),
          i = n(86239),
          a = n(21766),
          o = n(39290),
          l = n(82119),
          u = n(93040),
          c = (0, u.createGetUrl)(),
          d = RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
          h = RegExp("^ipfs://(ipfs/)?(.*)$", "i"),
          p = !1;
        async function f(e, t) {
          try {
            var n;
            let t = e.match(d);
            if (!t) throw Error("invalid data");
            return new v(
              200,
              "OK",
              { "content-type": t[1] || "text/plain" },
              t[2]
                ? (0, s.decodeBase64)(t[3])
                : ((n = t[3]),
                  (0, l.toUtf8Bytes)(
                    n.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) =>
                      String.fromCharCode(parseInt(t, 16))
                    )
                  ))
            );
          } catch (t) {
            return new v(
              599,
              "BAD REQUEST (invalid data: URI)",
              {},
              null,
              new w(e)
            );
          }
        }
        function g(e) {
          return async function (t, n) {
            try {
              let n = t.match(h);
              if (!n) throw Error("invalid link");
              return new w(`${e}${n[2]}`);
            } catch (e) {
              return new v(
                599,
                "BAD REQUEST (invalid IPFS URI)",
                {},
                null,
                new w(t)
              );
            }
          };
        }
        let m = { data: f, ipfs: g("https://gateway.ipfs.io/ipfs/") },
          y = new WeakMap();
        class b {
          #tr;
          #tn;
          constructor(e) {
            (this.#tr = []),
              (this.#tn = !1),
              y.set(e, () => {
                if (!this.#tn) {
                  for (let e of ((this.#tn = !0), this.#tr))
                    setTimeout(() => {
                      e();
                    }, 0);
                  this.#tr = [];
                }
              });
          }
          addListener(e) {
            (0, a.assert)(
              !this.#tn,
              "singal already cancelled",
              "UNSUPPORTED_OPERATION",
              { operation: "fetchCancelSignal.addCancelListener" }
            ),
              this.#tr.push(e);
          }
          get cancelled() {
            return this.#tn;
          }
          checkSignal() {
            (0, a.assert)(!this.cancelled, "cancelled", "CANCELLED", {});
          }
        }
        function A(e) {
          if (null == e) throw Error("missing signal; should not happen");
          return e.checkSignal(), e;
        }
        t.FetchCancelSignal = b;
        class w {
          #ts;
          #ti;
          #ta;
          #to;
          #tl;
          #es;
          #tu;
          #tc;
          #td;
          #th;
          #tp;
          #tf;
          #tg;
          #tm;
          #ty;
          get url() {
            return this.#es;
          }
          set url(e) {
            this.#es = String(e);
          }
          get body() {
            return null == this.#tu ? null : new Uint8Array(this.#tu);
          }
          set body(e) {
            if (null == e) (this.#tu = void 0), (this.#tc = void 0);
            else if ("string" == typeof e)
              (this.#tu = (0, l.toUtf8Bytes)(e)), (this.#tc = "text/plain");
            else if (e instanceof Uint8Array)
              (this.#tu = e), (this.#tc = "application/octet-stream");
            else if ("object" == typeof e)
              (this.#tu = (0, l.toUtf8Bytes)(JSON.stringify(e))),
                (this.#tc = "application/json");
            else throw Error("invalid body");
          }
          hasBody() {
            return null != this.#tu;
          }
          get method() {
            return this.#to ? this.#to : this.hasBody() ? "POST" : "GET";
          }
          set method(e) {
            null == e && (e = ""), (this.#to = String(e).toUpperCase());
          }
          get headers() {
            let e = Object.assign({}, this.#ta);
            return (
              this.#td &&
                (e.authorization = `Basic ${(0, s.encodeBase64)(
                  (0, l.toUtf8Bytes)(this.#td)
                )}`),
              this.allowGzip && (e["accept-encoding"] = "gzip"),
              null == e["content-type"] &&
                this.#tc &&
                (e["content-type"] = this.#tc),
              this.body && (e["content-length"] = String(this.body.length)),
              e
            );
          }
          getHeader(e) {
            return this.headers[e.toLowerCase()];
          }
          setHeader(e, t) {
            this.#ta[String(e).toLowerCase()] = String(t);
          }
          clearHeaders() {
            this.#ta = {};
          }
          [Symbol.iterator]() {
            let e = this.headers,
              t = Object.keys(e),
              n = 0;
            return {
              next: () => {
                if (n < t.length) {
                  let s = t[n++];
                  return { value: [s, e[s]], done: !1 };
                }
                return { value: void 0, done: !0 };
              },
            };
          }
          get credentials() {
            return this.#td || null;
          }
          setCredentials(e, t) {
            (0, a.assertArgument)(
              !e.match(/:/),
              "invalid basic authentication username",
              "username",
              "[REDACTED]"
            ),
              (this.#td = `${e}:${t}`);
          }
          get allowGzip() {
            return this.#ti;
          }
          set allowGzip(e) {
            this.#ti = !!e;
          }
          get allowInsecureAuthentication() {
            return !!this.#ts;
          }
          set allowInsecureAuthentication(e) {
            this.#ts = !!e;
          }
          get timeout() {
            return this.#tl;
          }
          set timeout(e) {
            (0, a.assertArgument)(
              e >= 0,
              "timeout must be non-zero",
              "timeout",
              e
            ),
              (this.#tl = e);
          }
          get preflightFunc() {
            return this.#th || null;
          }
          set preflightFunc(e) {
            this.#th = e;
          }
          get processFunc() {
            return this.#tp || null;
          }
          set processFunc(e) {
            this.#tp = e;
          }
          get retryFunc() {
            return this.#tf || null;
          }
          set retryFunc(e) {
            this.#tf = e;
          }
          get getUrlFunc() {
            return this.#ty || c;
          }
          set getUrlFunc(e) {
            this.#ty = e;
          }
          constructor(e) {
            (this.#es = String(e)),
              (this.#ts = !1),
              (this.#ti = !0),
              (this.#ta = {}),
              (this.#to = ""),
              (this.#tl = 3e5),
              (this.#tm = { slotInterval: 250, maxAttempts: 12 }),
              (this.#ty = null);
          }
          toString() {
            return `<FetchRequest method=${JSON.stringify(
              this.method
            )} url=${JSON.stringify(this.url)} headers=${JSON.stringify(
              this.headers
            )} body=${this.#tu ? (0, i.hexlify)(this.#tu) : "null"}>`;
          }
          setThrottleParams(e) {
            null != e.slotInterval && (this.#tm.slotInterval = e.slotInterval),
              null != e.maxAttempts && (this.#tm.maxAttempts = e.maxAttempts);
          }
          async #tb(e, t, n, s, i) {
            if (e >= this.#tm.maxAttempts)
              return i.makeServerError("exceeded maximum retry limit");
            (0, a.assert)(E() <= t, "timeout", "TIMEOUT", {
              operation: "request.send",
              reason: "timeout",
              request: s,
            }),
              n > 0 && (await new Promise((e) => setTimeout(e, n)));
            let o = this.clone(),
              l = (o.url.split(":")[0] || "").toLowerCase();
            if (l in m) {
              let e = await m[l](o.url, A(s.#tg));
              if (e instanceof v) {
                let t = e;
                if (this.processFunc) {
                  A(s.#tg);
                  try {
                    t = await this.processFunc(o, t);
                  } catch (e) {
                    (null == e.throttle || "number" != typeof e.stall) &&
                      t
                        .makeServerError("error in post-processing function", e)
                        .assertOk();
                  }
                }
                return t;
              }
              o = e;
            }
            this.preflightFunc && (o = await this.preflightFunc(o));
            let u = await this.getUrlFunc(o, A(s.#tg)),
              c = new v(u.statusCode, u.statusMessage, u.headers, u.body, s);
            if (301 === c.statusCode || 302 === c.statusCode) {
              try {
                let n = c.headers.location || "";
                return o.redirect(n).#tb(e + 1, t, 0, s, c);
              } catch (e) {}
              return c;
            }
            if (
              429 === c.statusCode &&
              (null == this.retryFunc || (await this.retryFunc(o, c, e)))
            ) {
              let n = c.headers["retry-after"],
                i =
                  this.#tm.slotInterval *
                  Math.trunc(Math.random() * Math.pow(2, e));
              return (
                "string" == typeof n &&
                  n.match(/^[1-9][0-9]*$/) &&
                  (i = parseInt(n)),
                o.clone().#tb(e + 1, t, i, s, c)
              );
            }
            if (this.processFunc) {
              A(s.#tg);
              try {
                c = await this.processFunc(o, c);
              } catch (i) {
                (null == i.throttle || "number" != typeof i.stall) &&
                  c
                    .makeServerError("error in post-processing function", i)
                    .assertOk();
                let n =
                  this.#tm.slotInterval *
                  Math.trunc(Math.random() * Math.pow(2, e));
                return (
                  i.stall >= 0 && (n = i.stall),
                  o.clone().#tb(e + 1, t, n, s, c)
                );
              }
            }
            return c;
          }
          send() {
            return (
              (0, a.assert)(
                null == this.#tg,
                "request already sent",
                "UNSUPPORTED_OPERATION",
                { operation: "fetchRequest.send" }
              ),
              (this.#tg = new b(this)),
              this.#tb(
                0,
                E() + this.timeout,
                0,
                this,
                new v(0, "", {}, null, this)
              )
            );
          }
          cancel() {
            (0, a.assert)(
              null != this.#tg,
              "request has not been sent",
              "UNSUPPORTED_OPERATION",
              { operation: "fetchRequest.cancel" }
            );
            let e = y.get(this);
            if (!e) throw Error("missing signal; should not happen");
            e();
          }
          redirect(e) {
            let t = this.url.split(":")[0].toLowerCase(),
              n = e.split(":")[0].toLowerCase();
            (0, a.assert)(
              "GET" === this.method &&
                ("https" !== t || "http" !== n) &&
                e.match(/^https?:/),
              "unsupported redirect",
              "UNSUPPORTED_OPERATION",
              {
                operation: `redirect(${this.method} ${JSON.stringify(
                  this.url
                )} => ${JSON.stringify(e)})`,
              }
            );
            let s = new w(e);
            return (
              (s.method = "GET"),
              (s.allowGzip = this.allowGzip),
              (s.timeout = this.timeout),
              (s.#ta = Object.assign({}, this.#ta)),
              this.#tu && (s.#tu = new Uint8Array(this.#tu)),
              (s.#tc = this.#tc),
              s
            );
          }
          clone() {
            let e = new w(this.url);
            return (
              (e.#to = this.#to),
              this.#tu && (e.#tu = this.#tu),
              (e.#tc = this.#tc),
              (e.#ta = Object.assign({}, this.#ta)),
              (e.#td = this.#td),
              this.allowGzip && (e.allowGzip = !0),
              (e.timeout = this.timeout),
              this.allowInsecureAuthentication &&
                (e.allowInsecureAuthentication = !0),
              (e.#th = this.#th),
              (e.#tp = this.#tp),
              (e.#tf = this.#tf),
              (e.#tm = Object.assign({}, this.#tm)),
              (e.#ty = this.#ty),
              e
            );
          }
          static lockConfig() {
            p = !0;
          }
          static getGateway(e) {
            return m[e.toLowerCase()] || null;
          }
          static registerGateway(e, t) {
            if ("http" === (e = e.toLowerCase()) || "https" === e)
              throw Error(`cannot intercept ${e}; use registerGetUrl`);
            if (p) throw Error("gateways locked");
            m[e] = t;
          }
          static registerGetUrl(e) {
            if (p) throw Error("gateways locked");
            c = e;
          }
          static createGetUrlFunc(e) {
            return (0, u.createGetUrl)(e);
          }
          static createDataGateway() {
            return f;
          }
          static createIpfsGatewayFunc(e) {
            return g(e);
          }
        }
        t.FetchRequest = w;
        class v {
          #tA;
          #tw;
          #ta;
          #tu;
          #ea;
          #tv;
          toString() {
            return `<FetchResponse status=${this.statusCode} body=${
              this.#tu ? (0, i.hexlify)(this.#tu) : "null"
            }>`;
          }
          get statusCode() {
            return this.#tA;
          }
          get statusMessage() {
            return this.#tw;
          }
          get headers() {
            return Object.assign({}, this.#ta);
          }
          get body() {
            return null == this.#tu ? null : new Uint8Array(this.#tu);
          }
          get bodyText() {
            try {
              return null == this.#tu ? "" : (0, l.toUtf8String)(this.#tu);
            } catch (e) {
              (0, a.assert)(
                !1,
                "response body is not valid UTF-8 data",
                "UNSUPPORTED_OPERATION",
                { operation: "bodyText", info: { response: this } }
              );
            }
          }
          get bodyJson() {
            try {
              return JSON.parse(this.bodyText);
            } catch (e) {
              (0, a.assert)(
                !1,
                "response body is not valid JSON",
                "UNSUPPORTED_OPERATION",
                { operation: "bodyJson", info: { response: this } }
              );
            }
          }
          [Symbol.iterator]() {
            let e = this.headers,
              t = Object.keys(e),
              n = 0;
            return {
              next: () => {
                if (n < t.length) {
                  let s = t[n++];
                  return { value: [s, e[s]], done: !1 };
                }
                return { value: void 0, done: !0 };
              },
            };
          }
          constructor(e, t, n, s, i) {
            (this.#tA = e),
              (this.#tw = t),
              (this.#ta = Object.keys(n).reduce(
                (e, t) => ((e[t.toLowerCase()] = String(n[t])), e),
                {}
              )),
              (this.#tu = null == s ? null : new Uint8Array(s)),
              (this.#ea = i || null),
              (this.#tv = { message: "" });
          }
          makeServerError(e, t) {
            let n;
            e
              ? (n = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})`)
              : ((e = `${this.statusCode} ${this.statusMessage}`),
                (n = `CLIENT ESCALATED SERVER ERROR (${e})`));
            let s = new v(599, n, this.headers, this.body, this.#ea || void 0);
            return (s.#tv = { message: e, error: t }), s;
          }
          throwThrottleError(e, t) {
            null == t
              ? (t = -1)
              : (0, a.assertArgument)(
                  Number.isInteger(t) && t >= 0,
                  "invalid stall timeout",
                  "stall",
                  t
                );
            let n = Error(e || "throttling requests");
            throw ((0, o.defineProperties)(n, { stall: t, throttle: !0 }), n);
          }
          getHeader(e) {
            return this.headers[e.toLowerCase()];
          }
          hasBody() {
            return null != this.#tu;
          }
          get request() {
            return this.#ea;
          }
          ok() {
            return (
              "" === this.#tv.message &&
              this.statusCode >= 200 &&
              this.statusCode < 300
            );
          }
          assertOk() {
            if (this.ok()) return;
            let { message: e, error: t } = this.#tv;
            "" === e &&
              (e = `server response ${this.statusCode} ${this.statusMessage}`);
            let n = null;
            this.request && (n = this.request.url);
            let s = null;
            try {
              this.#tu && (s = (0, l.toUtf8String)(this.#tu));
            } catch (e) {}
            (0, a.assert)(!1, e, "SERVER_ERROR", {
              request: this.request || "unknown request",
              response: this,
              error: t,
              info: {
                requestUrl: n,
                responseBody: s,
                responseStatus: `${this.statusCode} ${this.statusMessage}`,
              },
            });
          }
        }
        function E() {
          return new Date().getTime();
        }
        t.FetchResponse = v;
      },
      76539: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FixedNumber = void 0);
        let s = n(86239),
          i = n(21766),
          a = n(90358),
          o = n(39290),
          l = BigInt(-1),
          u = BigInt(0),
          c = BigInt(1),
          d = BigInt(5),
          h = {},
          p = "0000";
        for (; p.length < 80; ) p += p;
        function f(e) {
          let t = p;
          for (; t.length < e; ) t += t;
          return BigInt("1" + t.substring(0, e));
        }
        function g(e, t, n) {
          let s = BigInt(t.width);
          if (t.signed) {
            let t = c << (s - c);
            (0, i.assert)(
              null == n || (e >= -t && e < t),
              "overflow",
              "NUMERIC_FAULT",
              { operation: n, fault: "overflow", value: e }
            ),
              (e =
                e > u
                  ? (0, a.fromTwos)((0, a.mask)(e, s), s)
                  : -(0, a.fromTwos)((0, a.mask)(-e, s), s));
          } else {
            let t = c << s;
            (0, i.assert)(
              null == n || (e >= 0 && e < t),
              "overflow",
              "NUMERIC_FAULT",
              { operation: n, fault: "overflow", value: e }
            ),
              (e = ((e % t) + t) % t & (t - c));
          }
          return e;
        }
        function m(e) {
          "number" == typeof e && (e = `fixed128x${e}`);
          let t = !0,
            n = 128,
            s = 18;
          if ("string" == typeof e) {
            if ("fixed" === e);
            else if ("ufixed" === e) t = !1;
            else {
              let a = e.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
              (0, i.assertArgument)(a, "invalid fixed format", "format", e),
                (t = "u" !== a[1]),
                (n = parseInt(a[2])),
                (s = parseInt(a[3]));
            }
          } else if (e) {
            let a = e,
              o = (e, t, n) =>
                null == a[e]
                  ? n
                  : ((0, i.assertArgument)(
                      typeof a[e] === t,
                      "invalid fixed format (" + e + " not " + t + ")",
                      "format." + e,
                      a[e]
                    ),
                    a[e]);
            (t = o("signed", "boolean", t)),
              (n = o("width", "number", n)),
              (s = o("decimals", "number", s));
          }
          (0, i.assertArgument)(
            n % 8 == 0,
            "invalid FixedNumber width (not byte aligned)",
            "format.width",
            n
          ),
            (0, i.assertArgument)(
              s <= 80,
              "invalid FixedNumber decimals (too large)",
              "format.decimals",
              s
            );
          let a = (t ? "" : "u") + "fixed" + String(n) + "x" + String(s);
          return { signed: t, width: n, decimals: s, name: a };
        }
        class y {
          format;
          #tE;
          #tP;
          #tk;
          _value;
          constructor(e, t, n) {
            (0, i.assertPrivate)(e, h, "FixedNumber"),
              (this.#tP = t),
              (this.#tE = n);
            let s = (function (e, t) {
              let n = "";
              e < u && ((n = "-"), (e *= l));
              let s = e.toString();
              if (0 === t) return n + s;
              for (; s.length <= t; ) s = p + s;
              let i = s.length - t;
              for (
                s = s.substring(0, i) + "." + s.substring(i);
                "0" === s[0] && "." !== s[1];

              )
                s = s.substring(1);
              for (; "0" === s[s.length - 1] && "." !== s[s.length - 2]; )
                s = s.substring(0, s.length - 1);
              return n + s;
            })(t, n.decimals);
            (0, o.defineProperties)(this, { format: n.name, _value: s }),
              (this.#tk = f(n.decimals));
          }
          get signed() {
            return this.#tE.signed;
          }
          get width() {
            return this.#tE.width;
          }
          get decimals() {
            return this.#tE.decimals;
          }
          get value() {
            return this.#tP;
          }
          #tT(e) {
            (0, i.assertArgument)(
              this.format === e.format,
              "incompatible format; use fixedNumber.toFormat",
              "other",
              e
            );
          }
          #tx(e, t) {
            return new y(h, (e = g(e, this.#tE, t)), this.#tE);
          }
          #tO(e, t) {
            return this.#tT(e), this.#tx(this.#tP + e.#tP, t);
          }
          addUnsafe(e) {
            return this.#tO(e);
          }
          add(e) {
            return this.#tO(e, "add");
          }
          #tS(e, t) {
            return this.#tT(e), this.#tx(this.#tP - e.#tP, t);
          }
          subUnsafe(e) {
            return this.#tS(e);
          }
          sub(e) {
            return this.#tS(e, "sub");
          }
          #tC(e, t) {
            return this.#tT(e), this.#tx((this.#tP * e.#tP) / this.#tk, t);
          }
          mulUnsafe(e) {
            return this.#tC(e);
          }
          mul(e) {
            return this.#tC(e, "mul");
          }
          mulSignal(e) {
            this.#tT(e);
            let t = this.#tP * e.#tP;
            return (
              (0, i.assert)(
                t % this.#tk === u,
                "precision lost during signalling mul",
                "NUMERIC_FAULT",
                { operation: "mulSignal", fault: "underflow", value: this }
              ),
              this.#tx(t / this.#tk, "mulSignal")
            );
          }
          #tB(e, t) {
            return (
              (0, i.assert)(e.#tP !== u, "division by zero", "NUMERIC_FAULT", {
                operation: "div",
                fault: "divide-by-zero",
                value: this,
              }),
              this.#tT(e),
              this.#tx((this.#tP * this.#tk) / e.#tP, t)
            );
          }
          divUnsafe(e) {
            return this.#tB(e);
          }
          div(e) {
            return this.#tB(e, "div");
          }
          divSignal(e) {
            (0, i.assert)(e.#tP !== u, "division by zero", "NUMERIC_FAULT", {
              operation: "div",
              fault: "divide-by-zero",
              value: this,
            }),
              this.#tT(e);
            let t = this.#tP * this.#tk;
            return (
              (0, i.assert)(
                t % e.#tP === u,
                "precision lost during signalling div",
                "NUMERIC_FAULT",
                { operation: "divSignal", fault: "underflow", value: this }
              ),
              this.#tx(t / e.#tP, "divSignal")
            );
          }
          cmp(e) {
            let t = this.value,
              n = e.value,
              s = this.decimals - e.decimals;
            return (s > 0 ? (n *= f(s)) : s < 0 && (t *= f(-s)), t < n)
              ? -1
              : t > n
              ? 1
              : 0;
          }
          eq(e) {
            return 0 === this.cmp(e);
          }
          lt(e) {
            return 0 > this.cmp(e);
          }
          lte(e) {
            return 0 >= this.cmp(e);
          }
          gt(e) {
            return this.cmp(e) > 0;
          }
          gte(e) {
            return this.cmp(e) >= 0;
          }
          floor() {
            let e = this.#tP;
            return (
              this.#tP < u && (e -= this.#tk - c),
              (e = (this.#tP / this.#tk) * this.#tk),
              this.#tx(e, "floor")
            );
          }
          ceiling() {
            let e = this.#tP;
            return (
              this.#tP > u && (e += this.#tk - c),
              (e = (this.#tP / this.#tk) * this.#tk),
              this.#tx(e, "ceiling")
            );
          }
          round(e) {
            if ((null == e && (e = 0), e >= this.decimals)) return this;
            let t = this.decimals - e,
              n = d * f(t - 1),
              s = this.value + n,
              i = f(t);
            return (
              g((s = (s / i) * i), this.#tE, "round"), new y(h, s, this.#tE)
            );
          }
          isZero() {
            return this.#tP === u;
          }
          isNegative() {
            return this.#tP < u;
          }
          toString() {
            return this._value;
          }
          toUnsafeFloat() {
            return parseFloat(this.toString());
          }
          toFormat(e) {
            return y.fromString(this.toString(), e);
          }
          static fromValue(e, t, n) {
            let s = null == t ? 0 : (0, a.getNumber)(t),
              o = m(n),
              l = (0, a.getBigInt)(e, "value"),
              c = s - o.decimals;
            if (c > 0) {
              let t = f(c);
              (0, i.assert)(
                l % t === u,
                "value loses precision for format",
                "NUMERIC_FAULT",
                { operation: "fromValue", fault: "underflow", value: e }
              ),
                (l /= t);
            } else c < 0 && (l *= f(-c));
            return g(l, o, "fromValue"), new y(h, l, o);
          }
          static fromString(e, t) {
            let n = e.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
            (0, i.assertArgument)(
              n && n[2].length + n[3].length > 0,
              "invalid FixedNumber string value",
              "value",
              e
            );
            let s = m(t),
              a = n[2] || "0",
              o = n[3] || "";
            for (; o.length < s.decimals; ) o += p;
            (0, i.assert)(
              o.substring(s.decimals).match(/^0*$/),
              "too many decimals for format",
              "NUMERIC_FAULT",
              { operation: "fromString", fault: "underflow", value: e }
            ),
              (o = o.substring(0, s.decimals));
            let l = BigInt(n[1] + a + o);
            return g(l, s, "fromString"), new y(h, l, s);
          }
          static fromBytes(e, t) {
            let n = (0, a.toBigInt)((0, s.getBytes)(e, "value")),
              i = m(t);
            return (
              i.signed && (n = (0, a.fromTwos)(n, i.width)),
              g(n, i, "fromBytes"),
              new y(h, n, i)
            );
          }
        }
        t.FixedNumber = y;
      },
      93040: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getUrl = t.createGetUrl = void 0);
        let s = n(21766);
        function i(e) {
          return async function (e, t) {
            let n;
            (0, s.assert)(
              null == t || !t.cancelled,
              "request cancelled before sending",
              "CANCELLED"
            );
            let i = e.url.split(":")[0].toLowerCase();
            (0, s.assert)(
              "http" === i || "https" === i,
              `unsupported protocol ${i}`,
              "UNSUPPORTED_OPERATION",
              { info: { protocol: i }, operation: "request" }
            ),
              (0, s.assert)(
                "https" === i ||
                  !e.credentials ||
                  e.allowInsecureAuthentication,
                "insecure authorized connections unsupported",
                "UNSUPPORTED_OPERATION",
                { operation: "request" }
              );
            let a = null,
              o = new AbortController(),
              l = setTimeout(() => {
                (a = (0, s.makeError)("request timeout", "TIMEOUT")), o.abort();
              }, e.timeout);
            t &&
              t.addListener(() => {
                (a = (0, s.makeError)("request cancelled", "CANCELLED")),
                  o.abort();
              });
            let u = {
              method: e.method,
              headers: new Headers(Array.from(e)),
              body: e.body || void 0,
              signal: o.signal,
            };
            try {
              n = await fetch(e.url, u);
            } catch (e) {
              if ((clearTimeout(l), a)) throw a;
              throw e;
            }
            clearTimeout(l);
            let c = {};
            n.headers.forEach((e, t) => {
              c[t.toLowerCase()] = e;
            });
            let d = await n.arrayBuffer(),
              h = null == d ? null : new Uint8Array(d);
            return {
              statusCode: n.status,
              statusMessage: n.statusText,
              headers: c,
              body: h,
            };
          };
        }
        t.createGetUrl = i;
        let a = i({});
        async function o(e, t) {
          return a(e, t);
        }
        t.getUrl = o;
      },
      42120: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.toUtf8String =
            t.toUtf8CodePoints =
            t.toUtf8Bytes =
            t.parseUnits =
            t.formatUnits =
            t.parseEther =
            t.formatEther =
            t.encodeRlp =
            t.decodeRlp =
            t.defineProperties =
            t.resolveProperties =
            t.toQuantity =
            t.toBeArray =
            t.toBeHex =
            t.toNumber =
            t.toBigInt =
            t.getUint =
            t.getNumber =
            t.getBigInt =
            t.mask =
            t.toTwos =
            t.fromTwos =
            t.FixedNumber =
            t.FetchCancelSignal =
            t.FetchResponse =
            t.FetchRequest =
            t.EventPayload =
            t.makeError =
            t.assertNormalize =
            t.assertPrivate =
            t.assertArgumentCount =
            t.assertArgument =
            t.assert =
            t.isError =
            t.isCallException =
            t.zeroPadBytes =
            t.zeroPadValue =
            t.stripZerosLeft =
            t.dataSlice =
            t.dataLength =
            t.concat =
            t.hexlify =
            t.isBytesLike =
            t.isHexString =
            t.getBytesCopy =
            t.getBytes =
            t.encodeBase64 =
            t.decodeBase64 =
            t.encodeBase58 =
            t.decodeBase58 =
              void 0),
          (t.uuidV4 = t.Utf8ErrorFuncs = void 0);
        var s = n(20349);
        Object.defineProperty(t, "decodeBase58", {
          enumerable: !0,
          get: function () {
            return s.decodeBase58;
          },
        }),
          Object.defineProperty(t, "encodeBase58", {
            enumerable: !0,
            get: function () {
              return s.encodeBase58;
            },
          });
        var i = n(66446);
        Object.defineProperty(t, "decodeBase64", {
          enumerable: !0,
          get: function () {
            return i.decodeBase64;
          },
        }),
          Object.defineProperty(t, "encodeBase64", {
            enumerable: !0,
            get: function () {
              return i.encodeBase64;
            },
          });
        var a = n(86239);
        Object.defineProperty(t, "getBytes", {
          enumerable: !0,
          get: function () {
            return a.getBytes;
          },
        }),
          Object.defineProperty(t, "getBytesCopy", {
            enumerable: !0,
            get: function () {
              return a.getBytesCopy;
            },
          }),
          Object.defineProperty(t, "isHexString", {
            enumerable: !0,
            get: function () {
              return a.isHexString;
            },
          }),
          Object.defineProperty(t, "isBytesLike", {
            enumerable: !0,
            get: function () {
              return a.isBytesLike;
            },
          }),
          Object.defineProperty(t, "hexlify", {
            enumerable: !0,
            get: function () {
              return a.hexlify;
            },
          }),
          Object.defineProperty(t, "concat", {
            enumerable: !0,
            get: function () {
              return a.concat;
            },
          }),
          Object.defineProperty(t, "dataLength", {
            enumerable: !0,
            get: function () {
              return a.dataLength;
            },
          }),
          Object.defineProperty(t, "dataSlice", {
            enumerable: !0,
            get: function () {
              return a.dataSlice;
            },
          }),
          Object.defineProperty(t, "stripZerosLeft", {
            enumerable: !0,
            get: function () {
              return a.stripZerosLeft;
            },
          }),
          Object.defineProperty(t, "zeroPadValue", {
            enumerable: !0,
            get: function () {
              return a.zeroPadValue;
            },
          }),
          Object.defineProperty(t, "zeroPadBytes", {
            enumerable: !0,
            get: function () {
              return a.zeroPadBytes;
            },
          });
        var o = n(21766);
        Object.defineProperty(t, "isCallException", {
          enumerable: !0,
          get: function () {
            return o.isCallException;
          },
        }),
          Object.defineProperty(t, "isError", {
            enumerable: !0,
            get: function () {
              return o.isError;
            },
          }),
          Object.defineProperty(t, "assert", {
            enumerable: !0,
            get: function () {
              return o.assert;
            },
          }),
          Object.defineProperty(t, "assertArgument", {
            enumerable: !0,
            get: function () {
              return o.assertArgument;
            },
          }),
          Object.defineProperty(t, "assertArgumentCount", {
            enumerable: !0,
            get: function () {
              return o.assertArgumentCount;
            },
          }),
          Object.defineProperty(t, "assertPrivate", {
            enumerable: !0,
            get: function () {
              return o.assertPrivate;
            },
          }),
          Object.defineProperty(t, "assertNormalize", {
            enumerable: !0,
            get: function () {
              return o.assertNormalize;
            },
          }),
          Object.defineProperty(t, "makeError", {
            enumerable: !0,
            get: function () {
              return o.makeError;
            },
          });
        var l = n(52203);
        Object.defineProperty(t, "EventPayload", {
          enumerable: !0,
          get: function () {
            return l.EventPayload;
          },
        });
        var u = n(93654);
        Object.defineProperty(t, "FetchRequest", {
          enumerable: !0,
          get: function () {
            return u.FetchRequest;
          },
        }),
          Object.defineProperty(t, "FetchResponse", {
            enumerable: !0,
            get: function () {
              return u.FetchResponse;
            },
          }),
          Object.defineProperty(t, "FetchCancelSignal", {
            enumerable: !0,
            get: function () {
              return u.FetchCancelSignal;
            },
          });
        var c = n(76539);
        Object.defineProperty(t, "FixedNumber", {
          enumerable: !0,
          get: function () {
            return c.FixedNumber;
          },
        });
        var d = n(90358);
        Object.defineProperty(t, "fromTwos", {
          enumerable: !0,
          get: function () {
            return d.fromTwos;
          },
        }),
          Object.defineProperty(t, "toTwos", {
            enumerable: !0,
            get: function () {
              return d.toTwos;
            },
          }),
          Object.defineProperty(t, "mask", {
            enumerable: !0,
            get: function () {
              return d.mask;
            },
          }),
          Object.defineProperty(t, "getBigInt", {
            enumerable: !0,
            get: function () {
              return d.getBigInt;
            },
          }),
          Object.defineProperty(t, "getNumber", {
            enumerable: !0,
            get: function () {
              return d.getNumber;
            },
          }),
          Object.defineProperty(t, "getUint", {
            enumerable: !0,
            get: function () {
              return d.getUint;
            },
          }),
          Object.defineProperty(t, "toBigInt", {
            enumerable: !0,
            get: function () {
              return d.toBigInt;
            },
          }),
          Object.defineProperty(t, "toNumber", {
            enumerable: !0,
            get: function () {
              return d.toNumber;
            },
          }),
          Object.defineProperty(t, "toBeHex", {
            enumerable: !0,
            get: function () {
              return d.toBeHex;
            },
          }),
          Object.defineProperty(t, "toBeArray", {
            enumerable: !0,
            get: function () {
              return d.toBeArray;
            },
          }),
          Object.defineProperty(t, "toQuantity", {
            enumerable: !0,
            get: function () {
              return d.toQuantity;
            },
          });
        var h = n(39290);
        Object.defineProperty(t, "resolveProperties", {
          enumerable: !0,
          get: function () {
            return h.resolveProperties;
          },
        }),
          Object.defineProperty(t, "defineProperties", {
            enumerable: !0,
            get: function () {
              return h.defineProperties;
            },
          });
        var p = n(14978);
        Object.defineProperty(t, "decodeRlp", {
          enumerable: !0,
          get: function () {
            return p.decodeRlp;
          },
        });
        var f = n(49122);
        Object.defineProperty(t, "encodeRlp", {
          enumerable: !0,
          get: function () {
            return f.encodeRlp;
          },
        });
        var g = n(88680);
        Object.defineProperty(t, "formatEther", {
          enumerable: !0,
          get: function () {
            return g.formatEther;
          },
        }),
          Object.defineProperty(t, "parseEther", {
            enumerable: !0,
            get: function () {
              return g.parseEther;
            },
          }),
          Object.defineProperty(t, "formatUnits", {
            enumerable: !0,
            get: function () {
              return g.formatUnits;
            },
          }),
          Object.defineProperty(t, "parseUnits", {
            enumerable: !0,
            get: function () {
              return g.parseUnits;
            },
          });
        var m = n(82119);
        Object.defineProperty(t, "toUtf8Bytes", {
          enumerable: !0,
          get: function () {
            return m.toUtf8Bytes;
          },
        }),
          Object.defineProperty(t, "toUtf8CodePoints", {
            enumerable: !0,
            get: function () {
              return m.toUtf8CodePoints;
            },
          }),
          Object.defineProperty(t, "toUtf8String", {
            enumerable: !0,
            get: function () {
              return m.toUtf8String;
            },
          }),
          Object.defineProperty(t, "Utf8ErrorFuncs", {
            enumerable: !0,
            get: function () {
              return m.Utf8ErrorFuncs;
            },
          });
        var y = n(4824);
        Object.defineProperty(t, "uuidV4", {
          enumerable: !0,
          get: function () {
            return y.uuidV4;
          },
        });
      },
      90358: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.toQuantity =
            t.toBeArray =
            t.toBeHex =
            t.toNumber =
            t.getNumber =
            t.toBigInt =
            t.getUint =
            t.getBigInt =
            t.mask =
            t.toTwos =
            t.fromTwos =
              void 0);
        let s = n(86239),
          i = n(21766),
          a = BigInt(0),
          o = BigInt(1);
        function l(e, t) {
          switch (typeof e) {
            case "bigint":
              return e;
            case "number":
              return (
                (0, i.assertArgument)(
                  Number.isInteger(e),
                  "underflow",
                  t || "value",
                  e
                ),
                (0, i.assertArgument)(
                  e >= -9007199254740991 && e <= 9007199254740991,
                  "overflow",
                  t || "value",
                  e
                ),
                BigInt(e)
              );
            case "string":
              try {
                if ("" === e) throw Error("empty string");
                if ("-" === e[0] && "-" !== e[1])
                  return -BigInt(e.substring(1));
                return BigInt(e);
              } catch (n) {
                (0, i.assertArgument)(
                  !1,
                  `invalid BigNumberish string: ${n.message}`,
                  t || "value",
                  e
                );
              }
          }
          (0, i.assertArgument)(
            !1,
            "invalid BigNumberish value",
            t || "value",
            e
          );
        }
        function u(e, t) {
          let n = l(e, t);
          return (
            (0, i.assert)(
              n >= a,
              "unsigned value cannot be negative",
              "NUMERIC_FAULT",
              { fault: "overflow", operation: "getUint", value: e }
            ),
            n
          );
        }
        (t.fromTwos = function (e, t) {
          let n = u(e, "value"),
            s = BigInt(h(t, "width"));
          return ((0, i.assert)(n >> s === a, "overflow", "NUMERIC_FAULT", {
            operation: "fromTwos",
            fault: "overflow",
            value: e,
          }),
          n >> (s - o))
            ? -((~n & ((o << s) - o)) + o)
            : n;
        }),
          (t.toTwos = function (e, t) {
            let n = l(e, "value"),
              s = BigInt(h(t, "width")),
              u = o << (s - o);
            return n < a
              ? ((n = -n),
                (0, i.assert)(n <= u, "too low", "NUMERIC_FAULT", {
                  operation: "toTwos",
                  fault: "overflow",
                  value: e,
                }),
                (~n & ((o << s) - o)) + o)
              : ((0, i.assert)(n < u, "too high", "NUMERIC_FAULT", {
                  operation: "toTwos",
                  fault: "overflow",
                  value: e,
                }),
                n);
          }),
          (t.mask = function (e, t) {
            return u(e, "value") & ((o << BigInt(h(t, "bits"))) - o);
          }),
          (t.getBigInt = l),
          (t.getUint = u);
        let c = "0123456789abcdef";
        function d(e) {
          if (e instanceof Uint8Array) {
            let t = "0x0";
            for (let n of e) t += c[n >> 4] + c[15 & n];
            return BigInt(t);
          }
          return l(e);
        }
        function h(e, t) {
          switch (typeof e) {
            case "bigint":
              return (
                (0, i.assertArgument)(
                  e >= -9007199254740991 && e <= 9007199254740991,
                  "overflow",
                  t || "value",
                  e
                ),
                Number(e)
              );
            case "number":
              return (
                (0, i.assertArgument)(
                  Number.isInteger(e),
                  "underflow",
                  t || "value",
                  e
                ),
                (0, i.assertArgument)(
                  e >= -9007199254740991 && e <= 9007199254740991,
                  "overflow",
                  t || "value",
                  e
                ),
                e
              );
            case "string":
              try {
                if ("" === e) throw Error("empty string");
                return h(BigInt(e), t);
              } catch (n) {
                (0, i.assertArgument)(
                  !1,
                  `invalid numeric string: ${n.message}`,
                  t || "value",
                  e
                );
              }
          }
          (0, i.assertArgument)(!1, "invalid numeric value", t || "value", e);
        }
        function p(e) {
          let t = u(e, "value");
          if (t === a) return new Uint8Array([]);
          let n = t.toString(16);
          n.length % 2 && (n = "0" + n);
          let s = new Uint8Array(n.length / 2);
          for (let e = 0; e < s.length; e++) {
            let t = 2 * e;
            s[e] = parseInt(n.substring(t, t + 2), 16);
          }
          return s;
        }
        (t.toBigInt = d),
          (t.getNumber = h),
          (t.toNumber = function (e) {
            return h(d(e));
          }),
          (t.toBeHex = function (e, t) {
            let n = u(e, "value").toString(16);
            if (null == t) n.length % 2 && (n = "0" + n);
            else {
              let s = h(t, "width");
              for (
                (0, i.assert)(
                  2 * s >= n.length,
                  `value exceeds width (${s} bytes)`,
                  "NUMERIC_FAULT",
                  { operation: "toBeHex", fault: "overflow", value: e }
                );
                n.length < 2 * s;

              )
                n = "0" + n;
            }
            return "0x" + n;
          }),
          (t.toBeArray = p),
          (t.toQuantity = function (e) {
            let t = (0, s.hexlify)((0, s.isBytesLike)(e) ? e : p(e)).substring(
              2
            );
            for (; t.startsWith("0"); ) t = t.substring(1);
            return "" === t && (t = "0"), "0x" + t;
          });
      },
      39290: function (e, t) {
        "use strict";
        async function n(e) {
          let t = Object.keys(e);
          return (
            await Promise.all(t.map((t) => Promise.resolve(e[t])))
          ).reduce((e, n, s) => ((e[t[s]] = n), e), {});
        }
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.defineProperties = t.resolveProperties = void 0),
          (t.resolveProperties = n),
          (t.defineProperties = function (e, t, n) {
            for (let s in t) {
              let i = t[s],
                a = n ? n[s] : null;
              a &&
                (function (e, t, n) {
                  let s = t.split("|").map((e) => e.trim());
                  for (let n = 0; n < s.length; n++)
                    switch (t) {
                      case "any":
                        return;
                      case "bigint":
                      case "boolean":
                      case "number":
                      case "string":
                        if (typeof e === t) return;
                    }
                  let i = Error(`invalid value for type ${t}`);
                  throw (
                    ((i.code = "INVALID_ARGUMENT"),
                    (i.argument = `value.${n}`),
                    (i.value = e),
                    i)
                  );
                })(i, a, s),
                Object.defineProperty(e, s, {
                  enumerable: !0,
                  value: i,
                  writable: !1,
                });
            }
          });
      },
      14978: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decodeRlp = void 0);
        let s = n(86239),
          i = n(21766),
          a = n(86239);
        function o(e, t, n) {
          let s = 0;
          for (let i = 0; i < n; i++) s = 256 * s + e[t + i];
          return s;
        }
        function l(e, t, n, s) {
          let a = [];
          for (; n < t + 1 + s; ) {
            let o = u(e, n);
            a.push(o.result),
              (n += o.consumed),
              (0, i.assert)(
                n <= t + 1 + s,
                "child data too short",
                "BUFFER_OVERRUN",
                { buffer: e, length: s, offset: t }
              );
          }
          return { consumed: 1 + s, result: a };
        }
        function u(e, t) {
          (0, i.assert)(0 !== e.length, "data too short", "BUFFER_OVERRUN", {
            buffer: e,
            length: 0,
            offset: 1,
          });
          let n = (t) => {
            (0, i.assert)(
              t <= e.length,
              "data short segment too short",
              "BUFFER_OVERRUN",
              { buffer: e, length: e.length, offset: t }
            );
          };
          if (e[t] >= 248) {
            let s = e[t] - 247;
            n(t + 1 + s);
            let i = o(e, t + 1, s);
            return n(t + 1 + s + i), l(e, t, t + 1 + s, s + i);
          }
          if (e[t] >= 192) {
            let s = e[t] - 192;
            return n(t + 1 + s), l(e, t, t + 1, s);
          }
          if (e[t] >= 184) {
            let i = e[t] - 183;
            n(t + 1 + i);
            let a = o(e, t + 1, i);
            n(t + 1 + i + a);
            let l = (0, s.hexlify)(e.slice(t + 1 + i, t + 1 + i + a));
            return { consumed: 1 + i + a, result: l };
          }
          if (e[t] >= 128) {
            let i = e[t] - 128;
            n(t + 1 + i);
            let a = (0, s.hexlify)(e.slice(t + 1, t + 1 + i));
            return { consumed: 1 + i, result: a };
          }
          return {
            consumed: 1,
            result: (function (e) {
              let t = e.toString(16);
              for (; t.length < 2; ) t = "0" + t;
              return "0x" + t;
            })(e[t]),
          };
        }
        t.decodeRlp = function (e) {
          let t = (0, a.getBytes)(e, "data"),
            n = u(t, 0);
          return (
            (0, i.assertArgument)(
              n.consumed === t.length,
              "unexpected junk after rlp payload",
              "data",
              e
            ),
            n.result
          );
        };
      },
      49122: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.encodeRlp = void 0);
        let s = n(86239);
        function i(e) {
          let t = [];
          for (; e; ) t.unshift(255 & e), (e >>= 8);
          return t;
        }
        let a = "0123456789abcdef";
        t.encodeRlp = function (e) {
          let t = "0x";
          for (let n of (function e(t) {
            if (Array.isArray(t)) {
              let n = [];
              if (
                (t.forEach(function (t) {
                  n = n.concat(e(t));
                }),
                n.length <= 55)
              )
                return n.unshift(192 + n.length), n;
              let s = i(n.length);
              return s.unshift(247 + s.length), s.concat(n);
            }
            let n = Array.prototype.slice.call((0, s.getBytes)(t, "object"));
            if (1 === n.length && n[0] <= 127) return n;
            if (n.length <= 55) return n.unshift(128 + n.length), n;
            let a = i(n.length);
            return a.unshift(183 + a.length), a.concat(n);
          })(e))
            t += a[n >> 4] + a[15 & n];
          return t;
        };
      },
      88680: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.parseEther =
            t.formatEther =
            t.parseUnits =
            t.formatUnits =
              void 0);
        let s = n(21766),
          i = n(76539),
          a = n(90358),
          o = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
        function l(e, t) {
          let n = 18;
          if ("string" == typeof t) {
            let e = o.indexOf(t);
            (0, s.assertArgument)(e >= 0, "invalid unit", "unit", t),
              (n = 3 * e);
          } else null != t && (n = (0, a.getNumber)(t, "unit"));
          return i.FixedNumber.fromValue(e, n, {
            decimals: n,
            width: 512,
          }).toString();
        }
        function u(e, t) {
          (0, s.assertArgument)(
            "string" == typeof e,
            "value must be a string",
            "value",
            e
          );
          let n = 18;
          if ("string" == typeof t) {
            let e = o.indexOf(t);
            (0, s.assertArgument)(e >= 0, "invalid unit", "unit", t),
              (n = 3 * e);
          } else null != t && (n = (0, a.getNumber)(t, "unit"));
          return i.FixedNumber.fromString(e, { decimals: n, width: 512 }).value;
        }
        (t.formatUnits = l),
          (t.parseUnits = u),
          (t.formatEther = function (e) {
            return l(e, 18);
          }),
          (t.parseEther = function (e) {
            return u(e, 18);
          });
      },
      82119: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.toUtf8CodePoints =
            t.toUtf8String =
            t.toUtf8Bytes =
            t.Utf8ErrorFuncs =
              void 0);
        let s = n(86239),
          i = n(21766);
        function a(e, t, n, s, i) {
          if ("BAD_PREFIX" === e || "UNEXPECTED_CONTINUE" === e) {
            let e = 0;
            for (let s = t + 1; s < n.length && n[s] >> 6 == 2; s++) e++;
            return e;
          }
          return "OVERRUN" === e ? n.length - t - 1 : 0;
        }
        function o(e, n) {
          null == n && (n = t.Utf8ErrorFuncs.error);
          let i = (0, s.getBytes)(e, "bytes"),
            a = [],
            o = 0;
          for (; o < i.length; ) {
            let e = i[o++];
            if (e >> 7 == 0) {
              a.push(e);
              continue;
            }
            let t = null,
              s = null;
            if ((224 & e) == 192) (t = 1), (s = 127);
            else if ((240 & e) == 224) (t = 2), (s = 2047);
            else if ((248 & e) == 240) (t = 3), (s = 65535);
            else {
              (192 & e) == 128
                ? (o += n("UNEXPECTED_CONTINUE", o - 1, i, a))
                : (o += n("BAD_PREFIX", o - 1, i, a));
              continue;
            }
            if (o - 1 + t >= i.length) {
              o += n("OVERRUN", o - 1, i, a);
              continue;
            }
            let l = e & ((1 << (8 - t - 1)) - 1);
            for (let e = 0; e < t; e++) {
              let e = i[o];
              if ((192 & e) != 128) {
                (o += n("MISSING_CONTINUE", o, i, a)), (l = null);
                break;
              }
              (l = (l << 6) | (63 & e)), o++;
            }
            if (null !== l) {
              if (l > 1114111) {
                o += n("OUT_OF_RANGE", o - 1 - t, i, a, l);
                continue;
              }
              if (l >= 55296 && l <= 57343) {
                o += n("UTF16_SURROGATE", o - 1 - t, i, a, l);
                continue;
              }
              if (l <= s) {
                o += n("OVERLONG", o - 1 - t, i, a, l);
                continue;
              }
              a.push(l);
            }
          }
          return a;
        }
        function l(e, t) {
          (0, i.assertArgument)(
            "string" == typeof e,
            "invalid string value",
            "str",
            e
          ),
            null != t && ((0, i.assertNormalize)(t), (e = e.normalize(t)));
          let n = [];
          for (let t = 0; t < e.length; t++) {
            let s = e.charCodeAt(t);
            if (s < 128) n.push(s);
            else if (s < 2048) n.push((s >> 6) | 192), n.push((63 & s) | 128);
            else if ((64512 & s) == 55296) {
              t++;
              let a = e.charCodeAt(t);
              (0, i.assertArgument)(
                t < e.length && (64512 & a) == 56320,
                "invalid surrogate pair",
                "str",
                e
              );
              let o = 65536 + ((1023 & s) << 10) + (1023 & a);
              n.push((o >> 18) | 240),
                n.push(((o >> 12) & 63) | 128),
                n.push(((o >> 6) & 63) | 128),
                n.push((63 & o) | 128);
            } else
              n.push((s >> 12) | 224),
                n.push(((s >> 6) & 63) | 128),
                n.push((63 & s) | 128);
          }
          return new Uint8Array(n);
        }
        (t.Utf8ErrorFuncs = Object.freeze({
          error: function (e, t, n, s, a) {
            (0, i.assertArgument)(
              !1,
              `invalid codepoint at offset ${t}; ${e}`,
              "bytes",
              n
            );
          },
          ignore: a,
          replace: function (e, t, n, s, o) {
            return "OVERLONG" === e
              ? ((0, i.assertArgument)(
                  "number" == typeof o,
                  "invalid bad code point for replacement",
                  "badCodepoint",
                  o
                ),
                s.push(o),
                0)
              : (s.push(65533), a(e, t, n, s, o));
          },
        })),
          (t.toUtf8Bytes = l),
          (t.toUtf8String = function (e, t) {
            return o(e, t)
              .map((e) =>
                e <= 65535
                  ? String.fromCharCode(e)
                  : String.fromCharCode(
                      (((e -= 65536) >> 10) & 1023) + 55296,
                      (1023 & e) + 56320
                    )
              )
              .join("");
          }),
          (t.toUtf8CodePoints = function (e, t) {
            return o(l(e, t));
          });
      },
      4824: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.uuidV4 = void 0);
        let s = n(86239);
        t.uuidV4 = function (e) {
          let t = (0, s.getBytes)(e, "randomBytes");
          (t[6] = (15 & t[6]) | 64), (t[8] = (63 & t[8]) | 128);
          let n = (0, s.hexlify)(t);
          return [
            n.substring(2, 10),
            n.substring(10, 14),
            n.substring(14, 18),
            n.substring(18, 22),
            n.substring(22, 34),
          ].join("-");
        };
      },
      85662: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseWallet = void 0);
        let s = n(45475),
          i = n(62475),
          a = n(4878),
          o = n(2290),
          l = n(42120);
        class u extends a.AbstractSigner {
          address;
          #tN;
          constructor(e, t) {
            super(t),
              (0, l.assertArgument)(
                e && "function" == typeof e.sign,
                "invalid private key",
                "privateKey",
                "[ REDACTED ]"
              ),
              (this.#tN = e);
            let n = (0, o.computeAddress)(this.signingKey.publicKey);
            (0, l.defineProperties)(this, { address: n });
          }
          get signingKey() {
            return this.#tN;
          }
          get privateKey() {
            return this.signingKey.privateKey;
          }
          async getAddress() {
            return this.address;
          }
          connect(e) {
            return new u(this.#tN, e);
          }
          async signTransaction(e) {
            e = (0, a.copyRequest)(e);
            let { to: t, from: n } = await (0, l.resolveProperties)({
              to: e.to ? (0, s.resolveAddress)(e.to, this.provider) : void 0,
              from: e.from
                ? (0, s.resolveAddress)(e.from, this.provider)
                : void 0,
            });
            null != t && (e.to = t),
              null != n && (e.from = n),
              null != e.from &&
                ((0, l.assertArgument)(
                  (0, s.getAddress)(e.from) === this.address,
                  "transaction from address mismatch",
                  "tx.from",
                  e.from
                ),
                delete e.from);
            let i = o.Transaction.from(e);
            return (
              (i.signature = this.signingKey.sign(i.unsignedHash)), i.serialized
            );
          }
          async signMessage(e) {
            return this.signMessageSync(e);
          }
          signMessageSync(e) {
            return this.signingKey.sign((0, i.hashMessage)(e)).serialized;
          }
          async signTypedData(e, t, n) {
            let s = await i.TypedDataEncoder.resolveNames(
              e,
              t,
              n,
              async (e) => {
                (0, l.assert)(
                  null != this.provider,
                  "cannot resolve ENS names without a provider",
                  "UNSUPPORTED_OPERATION",
                  { operation: "resolveName", info: { name: e } }
                );
                let t = await this.provider.resolveName(e);
                return (
                  (0, l.assert)(
                    null != t,
                    "unconfigured ENS name",
                    "UNCONFIGURED_NAME",
                    { value: e }
                  ),
                  t
                );
              }
            );
            return this.signingKey.sign(
              i.TypedDataEncoder.hash(s.domain, t, s.value)
            ).serialized;
          }
        }
        t.BaseWallet = u;
      },
      90483: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getIndexedAccountPath =
            t.getAccountPath =
            t.HDNodeVoidWallet =
            t.HDNodeWallet =
            t.defaultPath =
              void 0);
        let s = n(96965),
          i = n(4878),
          a = n(2290),
          o = n(42120),
          l = n(10847),
          u = n(85662),
          c = n(40075),
          d = n(10630);
        t.defaultPath = "m/44'/60'/0'/0/0";
        let h = new Uint8Array([
            66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100,
          ]),
          p = BigInt(
            "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
          );
        function f(e, t) {
          let n = "";
          for (; e; )
            (n = "0123456789abcdef"[e % 16] + n), (e = Math.trunc(e / 16));
          for (; n.length < 2 * t; ) n = "0" + n;
          return "0x" + n;
        }
        function g(e) {
          let t = (0, o.getBytes)(e),
            n = (0, o.dataSlice)((0, s.sha256)((0, s.sha256)(t)), 0, 4),
            i = (0, o.concat)([t, n]);
          return (0, o.encodeBase58)(i);
        }
        let m = {};
        function y(e, t, n, i) {
          let a = new Uint8Array(37);
          2147483648 & e
            ? ((0, o.assert)(
                null != i,
                "cannot derive child of neutered node",
                "UNSUPPORTED_OPERATION",
                { operation: "deriveChild" }
              ),
              a.set((0, o.getBytes)(i), 1))
            : a.set((0, o.getBytes)(n));
          for (let t = 24; t >= 0; t -= 8)
            a[33 + (t >> 3)] = (e >> (24 - t)) & 255;
          let l = (0, o.getBytes)((0, s.computeHmac)("sha512", t, a));
          return { IL: l.slice(0, 32), IR: l.slice(32) };
        }
        function b(e, t) {
          let n = t.split("/");
          (0, o.assertArgument)(n.length > 0, "invalid path", "path", t),
            "m" === n[0] &&
              ((0, o.assertArgument)(
                0 === e.depth,
                `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${e.depth}`,
                "path",
                t
              ),
              n.shift());
          let s = e;
          for (let e = 0; e < n.length; e++) {
            let t = n[e];
            if (t.match(/^[0-9]+'$/)) {
              let n = parseInt(t.substring(0, t.length - 1));
              (0, o.assertArgument)(
                n < 2147483648,
                "invalid path index",
                `path[${e}]`,
                t
              ),
                (s = s.deriveChild(2147483648 + n));
            } else if (t.match(/^[0-9]+$/)) {
              let n = parseInt(t);
              (0, o.assertArgument)(
                n < 2147483648,
                "invalid path index",
                `path[${e}]`,
                t
              ),
                (s = s.deriveChild(n));
            } else
              (0, o.assertArgument)(
                !1,
                "invalid path component",
                `path[${e}]`,
                t
              );
          }
          return s;
        }
        class A extends u.BaseWallet {
          publicKey;
          fingerprint;
          parentFingerprint;
          mnemonic;
          chainCode;
          path;
          index;
          depth;
          constructor(e, t, n, i, a, l, u, c, d) {
            super(t, d),
              (0, o.assertPrivate)(e, m, "HDNodeWallet"),
              (0, o.defineProperties)(this, {
                publicKey: t.compressedPublicKey,
              });
            let h = (0, o.dataSlice)(
              (0, s.ripemd160)((0, s.sha256)(this.publicKey)),
              0,
              4
            );
            (0, o.defineProperties)(this, {
              parentFingerprint: n,
              fingerprint: h,
              chainCode: i,
              path: a,
              index: l,
              depth: u,
            }),
              (0, o.defineProperties)(this, { mnemonic: c });
          }
          connect(e) {
            return new A(
              m,
              this.signingKey,
              this.parentFingerprint,
              this.chainCode,
              this.path,
              this.index,
              this.depth,
              this.mnemonic,
              e
            );
          }
          #tR() {
            let e = { address: this.address, privateKey: this.privateKey },
              t = this.mnemonic;
            return (
              this.path &&
                t &&
                "en" === t.wordlist.locale &&
                "" === t.password &&
                (e.mnemonic = {
                  path: this.path,
                  locale: "en",
                  entropy: t.entropy,
                }),
              e
            );
          }
          async encrypt(e, t) {
            return await (0, d.encryptKeystoreJson)(this.#tR(), e, {
              progressCallback: t,
            });
          }
          encryptSync(e) {
            return (0, d.encryptKeystoreJsonSync)(this.#tR(), e);
          }
          get extendedKey() {
            return (
              (0, o.assert)(
                this.depth < 256,
                "Depth too deep",
                "UNSUPPORTED_OPERATION",
                { operation: "extendedKey" }
              ),
              g(
                (0, o.concat)([
                  "0x0488ADE4",
                  f(this.depth, 1),
                  this.parentFingerprint,
                  f(this.index, 4),
                  this.chainCode,
                  (0, o.concat)(["0x00", this.privateKey]),
                ])
              )
            );
          }
          hasPath() {
            return null != this.path;
          }
          neuter() {
            return new w(
              m,
              this.address,
              this.publicKey,
              this.parentFingerprint,
              this.chainCode,
              this.path,
              this.index,
              this.depth,
              this.provider
            );
          }
          deriveChild(e) {
            let t = (0, o.getNumber)(e, "index");
            (0, o.assertArgument)(t <= 4294967295, "invalid index", "index", t);
            let n = this.path;
            n && ((n += "/" + (2147483647 & t)), 2147483648 & t && (n += "'"));
            let { IR: i, IL: a } = y(
              t,
              this.chainCode,
              this.publicKey,
              this.privateKey
            );
            return new A(
              m,
              new s.SigningKey(
                (0, o.toBeHex)(
                  ((0, o.toBigInt)(a) + BigInt(this.privateKey)) % p,
                  32
                )
              ),
              this.fingerprint,
              (0, o.hexlify)(i),
              n,
              t,
              this.depth + 1,
              this.mnemonic,
              this.provider
            );
          }
          derivePath(e) {
            return b(this, e);
          }
          static #tI(e, t) {
            (0, o.assertArgument)(
              (0, o.isBytesLike)(e),
              "invalid seed",
              "seed",
              "[REDACTED]"
            );
            let n = (0, o.getBytes)(e, "seed");
            (0, o.assertArgument)(
              n.length >= 16 && n.length <= 64,
              "invalid seed",
              "seed",
              "[REDACTED]"
            );
            let i = (0, o.getBytes)((0, s.computeHmac)("sha512", h, n));
            return new A(
              m,
              new s.SigningKey((0, o.hexlify)(i.slice(0, 32))),
              "0x00000000",
              (0, o.hexlify)(i.slice(32)),
              "m",
              0,
              0,
              t,
              null
            );
          }
          static fromExtendedKey(e) {
            let t = (0, o.toBeArray)((0, o.decodeBase58)(e));
            (0, o.assertArgument)(
              82 === t.length || g(t.slice(0, 78)) === e,
              "invalid extended key",
              "extendedKey",
              "[ REDACTED ]"
            );
            let n = t[4],
              i = (0, o.hexlify)(t.slice(5, 9)),
              l = parseInt((0, o.hexlify)(t.slice(9, 13)).substring(2), 16),
              u = (0, o.hexlify)(t.slice(13, 45)),
              c = t.slice(45, 78);
            switch ((0, o.hexlify)(t.slice(0, 4))) {
              case "0x0488b21e":
              case "0x043587cf": {
                let e = (0, o.hexlify)(c);
                return new w(
                  m,
                  (0, a.computeAddress)(e),
                  e,
                  i,
                  u,
                  null,
                  l,
                  n,
                  null
                );
              }
              case "0x0488ade4":
              case "0x04358394 ":
                if (0 !== c[0]) break;
                return new A(
                  m,
                  new s.SigningKey(c.slice(1)),
                  i,
                  u,
                  null,
                  l,
                  n,
                  null,
                  null
                );
            }
            (0, o.assertArgument)(
              !1,
              "invalid extended key prefix",
              "extendedKey",
              "[ REDACTED ]"
            );
          }
          static createRandom(e, n, i) {
            null == e && (e = ""),
              null == n && (n = t.defaultPath),
              null == i && (i = l.LangEn.wordlist());
            let a = c.Mnemonic.fromEntropy((0, s.randomBytes)(16), e, i);
            return A.#tI(a.computeSeed(), a).derivePath(n);
          }
          static fromMnemonic(e, n) {
            return (
              n || (n = t.defaultPath), A.#tI(e.computeSeed(), e).derivePath(n)
            );
          }
          static fromPhrase(e, n, s, i) {
            null == n && (n = ""),
              null == s && (s = t.defaultPath),
              null == i && (i = l.LangEn.wordlist());
            let a = c.Mnemonic.fromPhrase(e, n, i);
            return A.#tI(a.computeSeed(), a).derivePath(s);
          }
          static fromSeed(e) {
            return A.#tI(e, null);
          }
        }
        t.HDNodeWallet = A;
        class w extends i.VoidSigner {
          publicKey;
          fingerprint;
          parentFingerprint;
          chainCode;
          path;
          index;
          depth;
          constructor(e, t, n, i, a, l, u, c, d) {
            super(t, d),
              (0, o.assertPrivate)(e, m, "HDNodeVoidWallet"),
              (0, o.defineProperties)(this, { publicKey: n });
            let h = (0, o.dataSlice)((0, s.ripemd160)((0, s.sha256)(n)), 0, 4);
            (0, o.defineProperties)(this, {
              publicKey: n,
              fingerprint: h,
              parentFingerprint: i,
              chainCode: a,
              path: l,
              index: u,
              depth: c,
            });
          }
          connect(e) {
            return new w(
              m,
              this.address,
              this.publicKey,
              this.parentFingerprint,
              this.chainCode,
              this.path,
              this.index,
              this.depth,
              e
            );
          }
          get extendedKey() {
            return (
              (0, o.assert)(
                this.depth < 256,
                "Depth too deep",
                "UNSUPPORTED_OPERATION",
                { operation: "extendedKey" }
              ),
              g(
                (0, o.concat)([
                  "0x0488B21E",
                  f(this.depth, 1),
                  this.parentFingerprint,
                  f(this.index, 4),
                  this.chainCode,
                  this.publicKey,
                ])
              )
            );
          }
          hasPath() {
            return null != this.path;
          }
          deriveChild(e) {
            let t = (0, o.getNumber)(e, "index");
            (0, o.assertArgument)(t <= 4294967295, "invalid index", "index", t);
            let n = this.path;
            n && ((n += "/" + (2147483647 & t)), 2147483648 & t && (n += "'"));
            let { IR: i, IL: l } = y(t, this.chainCode, this.publicKey, null),
              u = s.SigningKey.addPoints(l, this.publicKey, !0);
            return new w(
              m,
              (0, a.computeAddress)(u),
              u,
              this.fingerprint,
              (0, o.hexlify)(i),
              n,
              t,
              this.depth + 1,
              this.provider
            );
          }
          derivePath(e) {
            return b(this, e);
          }
        }
        (t.HDNodeVoidWallet = w),
          (t.getAccountPath = function (e) {
            let t = (0, o.getNumber)(e, "index");
            return (
              (0, o.assertArgument)(
                t >= 0 && t < 2147483648,
                "invalid account index",
                "index",
                t
              ),
              `m/44'/60'/${t}'/0/0`
            );
          }),
          (t.getIndexedAccountPath = function (e) {
            let t = (0, o.getNumber)(e, "index");
            return (
              (0, o.assertArgument)(
                t >= 0 && t < 2147483648,
                "invalid account index",
                "index",
                t
              ),
              `m/44'/60'/0'/0/${t}`
            );
          });
      },
      91602: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Wallet =
            t.Mnemonic =
            t.encryptKeystoreJsonSync =
            t.encryptKeystoreJson =
            t.decryptKeystoreJson =
            t.decryptKeystoreJsonSync =
            t.isKeystoreJson =
            t.decryptCrowdsaleJson =
            t.isCrowdsaleJson =
            t.HDNodeVoidWallet =
            t.HDNodeWallet =
            t.getIndexedAccountPath =
            t.getAccountPath =
            t.defaultPath =
            t.BaseWallet =
              void 0);
        var s = n(85662);
        Object.defineProperty(t, "BaseWallet", {
          enumerable: !0,
          get: function () {
            return s.BaseWallet;
          },
        });
        var i = n(90483);
        Object.defineProperty(t, "defaultPath", {
          enumerable: !0,
          get: function () {
            return i.defaultPath;
          },
        }),
          Object.defineProperty(t, "getAccountPath", {
            enumerable: !0,
            get: function () {
              return i.getAccountPath;
            },
          }),
          Object.defineProperty(t, "getIndexedAccountPath", {
            enumerable: !0,
            get: function () {
              return i.getIndexedAccountPath;
            },
          }),
          Object.defineProperty(t, "HDNodeWallet", {
            enumerable: !0,
            get: function () {
              return i.HDNodeWallet;
            },
          }),
          Object.defineProperty(t, "HDNodeVoidWallet", {
            enumerable: !0,
            get: function () {
              return i.HDNodeVoidWallet;
            },
          });
        var a = n(78668);
        Object.defineProperty(t, "isCrowdsaleJson", {
          enumerable: !0,
          get: function () {
            return a.isCrowdsaleJson;
          },
        }),
          Object.defineProperty(t, "decryptCrowdsaleJson", {
            enumerable: !0,
            get: function () {
              return a.decryptCrowdsaleJson;
            },
          });
        var o = n(10630);
        Object.defineProperty(t, "isKeystoreJson", {
          enumerable: !0,
          get: function () {
            return o.isKeystoreJson;
          },
        }),
          Object.defineProperty(t, "decryptKeystoreJsonSync", {
            enumerable: !0,
            get: function () {
              return o.decryptKeystoreJsonSync;
            },
          }),
          Object.defineProperty(t, "decryptKeystoreJson", {
            enumerable: !0,
            get: function () {
              return o.decryptKeystoreJson;
            },
          }),
          Object.defineProperty(t, "encryptKeystoreJson", {
            enumerable: !0,
            get: function () {
              return o.encryptKeystoreJson;
            },
          }),
          Object.defineProperty(t, "encryptKeystoreJsonSync", {
            enumerable: !0,
            get: function () {
              return o.encryptKeystoreJsonSync;
            },
          });
        var l = n(40075);
        Object.defineProperty(t, "Mnemonic", {
          enumerable: !0,
          get: function () {
            return l.Mnemonic;
          },
        });
        var u = n(6389);
        Object.defineProperty(t, "Wallet", {
          enumerable: !0,
          get: function () {
            return u.Wallet;
          },
        });
      },
      78668: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decryptCrowdsaleJson = t.isCrowdsaleJson = void 0);
        let s = n(93260),
          i = n(45475),
          a = n(96965),
          o = n(62475),
          l = n(42120),
          u = n(57668);
        (t.isCrowdsaleJson = function (e) {
          try {
            if (JSON.parse(e).encseed) return !0;
          } catch (e) {}
          return !1;
        }),
          (t.decryptCrowdsaleJson = function (e, t) {
            let n = JSON.parse(e),
              c = (0, u.getPassword)(t),
              d = (0, i.getAddress)((0, u.spelunk)(n, "ethaddr:string!")),
              h = (0, u.looseArrayify)((0, u.spelunk)(n, "encseed:string!"));
            (0, l.assertArgument)(
              h && h.length % 16 == 0,
              "invalid encseed",
              "json",
              e
            );
            let p = (0, l.getBytes)(
                (0, a.pbkdf2)(c, c, 2e3, 32, "sha256")
              ).slice(0, 16),
              f = h.slice(0, 16),
              g = h.slice(16),
              m = new s.CBC(p, f),
              y = (0, s.pkcs7Strip)((0, l.getBytes)(m.decrypt(g))),
              b = "";
            for (let e = 0; e < y.length; e++) b += String.fromCharCode(y[e]);
            return { address: d, privateKey: (0, o.id)(b) };
          });
      },
      10630: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.encryptKeystoreJson =
            t.encryptKeystoreJsonSync =
            t.decryptKeystoreJson =
            t.decryptKeystoreJsonSync =
            t.isKeystoreJson =
              void 0);
        let s = n(93260),
          i = n(45475),
          a = n(96965),
          o = n(2290),
          l = n(42120),
          u = n(57668),
          c = n(79406),
          d = "m/44'/60'/0'/0/0";
        function h(e, t) {
          let n = (0, l.getBytes)(t),
            c = (0, u.spelunk)(e, "crypto.ciphertext:data!"),
            h = (0, l.hexlify)(
              (0, a.keccak256)((0, l.concat)([n.slice(16, 32), c]))
            ).substring(2);
          (0, l.assertArgument)(
            h === (0, u.spelunk)(e, "crypto.mac:string!").toLowerCase(),
            "incorrect password",
            "password",
            "[ REDACTED ]"
          );
          let p = (function (e, t, n) {
              if ("aes-128-ctr" === (0, u.spelunk)(e, "crypto.cipher:string")) {
                let i = (0, u.spelunk)(e, "crypto.cipherparams.iv:data!"),
                  a = new s.CTR(t, i);
                return (0, l.hexlify)(a.decrypt(n));
              }
              (0, l.assert)(!1, "unsupported cipher", "UNSUPPORTED_OPERATION", {
                operation: "decrypt",
              });
            })(e, n.slice(0, 16), c),
            f = (0, o.computeAddress)(p);
          if (e.address) {
            let t = e.address.toLowerCase();
            t.startsWith("0x") || (t = "0x" + t),
              (0, l.assertArgument)(
                (0, i.getAddress)(t) === f,
                "keystore address/privateKey mismatch",
                "address",
                e.address
              );
          }
          let g = { address: f, privateKey: p };
          if ("0.1" === (0, u.spelunk)(e, "x-ethers.version:string")) {
            let t = n.slice(32, 64),
              i = (0, u.spelunk)(e, "x-ethers.mnemonicCiphertext:data!"),
              a = (0, u.spelunk)(e, "x-ethers.mnemonicCounter:data!"),
              o = new s.CTR(t, a);
            g.mnemonic = {
              path: (0, u.spelunk)(e, "x-ethers.path:string") || d,
              locale: (0, u.spelunk)(e, "x-ethers.locale:string") || "en",
              entropy: (0, l.hexlify)((0, l.getBytes)(o.decrypt(i))),
            };
          }
          return g;
        }
        function p(e) {
          let t = (0, u.spelunk)(e, "crypto.kdf:string");
          if (t && "string" == typeof t) {
            if ("scrypt" === t.toLowerCase()) {
              let n = (0, u.spelunk)(e, "crypto.kdfparams.salt:data!"),
                s = (0, u.spelunk)(e, "crypto.kdfparams.n:int!"),
                i = (0, u.spelunk)(e, "crypto.kdfparams.r:int!"),
                a = (0, u.spelunk)(e, "crypto.kdfparams.p:int!");
              (0, l.assertArgument)(
                s > 0 && (s & (s - 1)) == 0,
                "invalid kdf.N",
                "kdf.N",
                s
              ),
                (0, l.assertArgument)(i > 0 && a > 0, "invalid kdf", "kdf", t);
              let o = (0, u.spelunk)(e, "crypto.kdfparams.dklen:int!");
              return (
                (0, l.assertArgument)(
                  32 === o,
                  "invalid kdf.dklen",
                  "kdf.dflen",
                  o
                ),
                { name: "scrypt", salt: n, N: s, r: i, p: a, dkLen: 64 }
              );
            }
            if ("pbkdf2" === t.toLowerCase()) {
              let t = (0, u.spelunk)(e, "crypto.kdfparams.salt:data!"),
                n = (0, u.spelunk)(e, "crypto.kdfparams.prf:string!"),
                s = n.split("-").pop();
              (0, l.assertArgument)(
                "sha256" === s || "sha512" === s,
                "invalid kdf.pdf",
                "kdf.pdf",
                n
              );
              let i = (0, u.spelunk)(e, "crypto.kdfparams.c:int!"),
                a = (0, u.spelunk)(e, "crypto.kdfparams.dklen:int!");
              return (
                (0, l.assertArgument)(
                  32 === a,
                  "invalid kdf.dklen",
                  "kdf.dklen",
                  a
                ),
                { name: "pbkdf2", salt: t, count: i, dkLen: a, algorithm: s }
              );
            }
          }
          (0, l.assertArgument)(
            !1,
            "unsupported key-derivation function",
            "kdf",
            t
          );
        }
        function f(e) {
          return new Promise((t) => {
            setTimeout(() => {
              t();
            }, e);
          });
        }
        async function g(e, t, n) {
          let s = JSON.parse(e),
            i = (0, u.getPassword)(t),
            o = p(s);
          if ("pbkdf2" === o.name) {
            n && (n(0), await f(0));
            let { salt: e, count: t, dkLen: l, algorithm: u } = o,
              c = (0, a.pbkdf2)(i, e, t, l, u);
            return n && (n(1), await f(0)), h(s, c);
          }
          (0, l.assert)(
            "scrypt" === o.name,
            "cannot be reached",
            "UNKNOWN_ERROR",
            { params: o }
          );
          let { salt: c, N: d, r: g, p: m, dkLen: y } = o;
          return h(s, await (0, a.scrypt)(i, c, d, g, m, y, n));
        }
        function m(e) {
          let t =
              null != e.salt
                ? (0, l.getBytes)(e.salt, "options.salt")
                : (0, a.randomBytes)(32),
            n = 131072,
            s = 8,
            i = 1;
          return (
            e.scrypt &&
              (e.scrypt.N && (n = e.scrypt.N),
              e.scrypt.r && (s = e.scrypt.r),
              e.scrypt.p && (i = e.scrypt.p)),
            (0, l.assertArgument)(
              "number" == typeof n &&
                n > 0 &&
                Number.isSafeInteger(n) &&
                (BigInt(n) & BigInt(n - 1)) === BigInt(0),
              "invalid scrypt N parameter",
              "options.N",
              n
            ),
            (0, l.assertArgument)(
              "number" == typeof s && s > 0 && Number.isSafeInteger(s),
              "invalid scrypt r parameter",
              "options.r",
              s
            ),
            (0, l.assertArgument)(
              "number" == typeof i && i > 0 && Number.isSafeInteger(i),
              "invalid scrypt p parameter",
              "options.p",
              i
            ),
            { name: "scrypt", dkLen: 32, salt: t, N: n, r: s, p: i }
          );
        }
        function y(e, t, n, i) {
          let o = (0, l.getBytes)(n.privateKey, "privateKey"),
            h =
              null != i.iv
                ? (0, l.getBytes)(i.iv, "options.iv")
                : (0, a.randomBytes)(16);
          (0, l.assertArgument)(
            16 === h.length,
            "invalid options.iv length",
            "options.iv",
            i.iv
          );
          let p =
            null != i.uuid
              ? (0, l.getBytes)(i.uuid, "options.uuid")
              : (0, a.randomBytes)(16);
          (0, l.assertArgument)(
            16 === p.length,
            "invalid options.uuid length",
            "options.uuid",
            i.iv
          );
          let f = e.slice(0, 16),
            g = e.slice(16, 32),
            m = new s.CTR(f, h),
            y = (0, l.getBytes)(m.encrypt(o)),
            b = (0, a.keccak256)((0, l.concat)([g, y])),
            A = {
              address: n.address.substring(2).toLowerCase(),
              id: (0, l.uuidV4)(p),
              version: 3,
              Crypto: {
                cipher: "aes-128-ctr",
                cipherparams: { iv: (0, l.hexlify)(h).substring(2) },
                ciphertext: (0, l.hexlify)(y).substring(2),
                kdf: "scrypt",
                kdfparams: {
                  salt: (0, l.hexlify)(t.salt).substring(2),
                  n: t.N,
                  dklen: 32,
                  p: t.p,
                  r: t.r,
                },
                mac: b.substring(2),
              },
            };
          if (n.mnemonic) {
            let t = null != i.client ? i.client : `ethers/${c.version}`,
              o = n.mnemonic.path || d,
              h = n.mnemonic.locale || "en",
              p = e.slice(32, 64),
              f = (0, l.getBytes)(
                n.mnemonic.entropy,
                "account.mnemonic.entropy"
              ),
              g = (0, a.randomBytes)(16),
              m = new s.CTR(p, g),
              y = (0, l.getBytes)(m.encrypt(f)),
              b = new Date(),
              w =
                "UTC--" +
                (b.getUTCFullYear() +
                  "-" +
                  (0, u.zpad)(b.getUTCMonth() + 1, 2) +
                  "-" +
                  (0, u.zpad)(b.getUTCDate(), 2) +
                  "T" +
                  (0, u.zpad)(b.getUTCHours(), 2) +
                  "-" +
                  (0, u.zpad)(b.getUTCMinutes(), 2) +
                  "-") +
                (0, u.zpad)(b.getUTCSeconds(), 2) +
                ".0Z--" +
                A.address;
            A["x-ethers"] = {
              client: t,
              gethFilename: w,
              path: o,
              locale: h,
              mnemonicCounter: (0, l.hexlify)(g).substring(2),
              mnemonicCiphertext: (0, l.hexlify)(y).substring(2),
              version: "0.1",
            };
          }
          return JSON.stringify(A);
        }
        async function b(e, t, n) {
          null == n && (n = {});
          let s = (0, u.getPassword)(t),
            i = m(n),
            o = await (0, a.scrypt)(
              s,
              i.salt,
              i.N,
              i.r,
              i.p,
              64,
              n.progressCallback
            );
          return y((0, l.getBytes)(o), i, e, n);
        }
        (t.isKeystoreJson = function (e) {
          try {
            let t = JSON.parse(e),
              n = null != t.version ? parseInt(t.version) : 0;
            if (3 === n) return !0;
          } catch (e) {}
          return !1;
        }),
          (t.decryptKeystoreJsonSync = function (e, t) {
            let n = JSON.parse(e),
              s = (0, u.getPassword)(t),
              i = p(n);
            if ("pbkdf2" === i.name) {
              let { salt: e, count: t, dkLen: o, algorithm: l } = i;
              return h(n, (0, a.pbkdf2)(s, e, t, o, l));
            }
            (0, l.assert)(
              "scrypt" === i.name,
              "cannot be reached",
              "UNKNOWN_ERROR",
              { params: i }
            );
            let { salt: o, N: c, r: d, p: f, dkLen: g } = i;
            return h(n, (0, a.scryptSync)(s, o, c, d, f, g));
          }),
          (t.decryptKeystoreJson = g),
          (t.encryptKeystoreJsonSync = function (e, t, n) {
            null == n && (n = {});
            let s = (0, u.getPassword)(t),
              i = m(n),
              o = (0, a.scryptSync)(s, i.salt, i.N, i.r, i.p, 64);
            return y((0, l.getBytes)(o), i, e, n);
          }),
          (t.encryptKeystoreJson = b);
      },
      40075: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Mnemonic = void 0);
        let s = n(96965),
          i = n(42120),
          a = n(10847);
        function o(e) {
          return (((1 << e) - 1) << (8 - e)) & 255;
        }
        function l(e, t) {
          (0, i.assertNormalize)("NFKD"),
            null == t && (t = a.LangEn.wordlist());
          let n = t.split(e);
          (0, i.assertArgument)(
            n.length % 3 == 0 && n.length >= 12 && n.length <= 24,
            "invalid mnemonic length",
            "mnemonic",
            "[ REDACTED ]"
          );
          let l = new Uint8Array(Math.ceil((11 * n.length) / 8)),
            u = 0;
          for (let e = 0; e < n.length; e++) {
            let s = t.getWordIndex(n[e].normalize("NFKD"));
            (0, i.assertArgument)(
              s >= 0,
              `invalid mnemonic word at index ${e}`,
              "mnemonic",
              "[ REDACTED ]"
            );
            for (let e = 0; e < 11; e++)
              s & (1 << (10 - e)) && (l[u >> 3] |= 1 << (7 - (u % 8))), u++;
          }
          let c = (32 * n.length) / 3,
            d = o(n.length / 3),
            h = (0, i.getBytes)((0, s.sha256)(l.slice(0, c / 8)))[0] & d;
          return (
            (0, i.assertArgument)(
              h === (l[l.length - 1] & d),
              "invalid mnemonic checksum",
              "mnemonic",
              "[ REDACTED ]"
            ),
            (0, i.hexlify)(l.slice(0, c / 8))
          );
        }
        function u(e, t) {
          (0, i.assertArgument)(
            e.length % 4 == 0 && e.length >= 16 && e.length <= 32,
            "invalid entropy size",
            "entropy",
            "[ REDACTED ]"
          ),
            null == t && (t = a.LangEn.wordlist());
          let n = [0],
            l = 11;
          for (let t = 0; t < e.length; t++)
            l > 8
              ? ((n[n.length - 1] <<= 8), (n[n.length - 1] |= e[t]), (l -= 8))
              : ((n[n.length - 1] <<= l),
                (n[n.length - 1] |= e[t] >> (8 - l)),
                n.push(e[t] & (((1 << (8 - l)) - 1) & 255)),
                (l += 3));
          let u = e.length / 4,
            c = parseInt((0, s.sha256)(e).substring(2, 4), 16) & o(u);
          return (
            (n[n.length - 1] <<= u),
            (n[n.length - 1] |= c >> (8 - u)),
            t.join(n.map((e) => t.getWord(e)))
          );
        }
        let c = {};
        class d {
          phrase;
          password;
          wordlist;
          entropy;
          constructor(e, t, n, s, o) {
            null == s && (s = ""),
              null == o && (o = a.LangEn.wordlist()),
              (0, i.assertPrivate)(e, c, "Mnemonic"),
              (0, i.defineProperties)(this, {
                phrase: n,
                password: s,
                wordlist: o,
                entropy: t,
              });
          }
          computeSeed() {
            let e = (0, i.toUtf8Bytes)("mnemonic" + this.password, "NFKD");
            return (0, s.pbkdf2)(
              (0, i.toUtf8Bytes)(this.phrase, "NFKD"),
              e,
              2048,
              64,
              "sha512"
            );
          }
          static fromPhrase(e, t, n) {
            let s = l(e, n);
            return (e = u((0, i.getBytes)(s), n)), new d(c, s, e, t, n);
          }
          static fromEntropy(e, t, n) {
            let s = (0, i.getBytes)(e, "entropy"),
              a = u(s, n);
            return new d(c, (0, i.hexlify)(s), a, t, n);
          }
          static entropyToPhrase(e, t) {
            return u((0, i.getBytes)(e, "entropy"), t);
          }
          static phraseToEntropy(e, t) {
            return l(e, t);
          }
          static isValidMnemonic(e, t) {
            try {
              return l(e, t), !0;
            } catch (e) {}
            return !1;
          }
        }
        t.Mnemonic = d;
      },
      57668: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.spelunk = t.getPassword = t.zpad = t.looseArrayify = void 0);
        let s = n(42120);
        function i(e) {
          return (
            "string" != typeof e || e.startsWith("0x") || (e = "0x" + e),
            (0, s.getBytesCopy)(e)
          );
        }
        (t.looseArrayify = i),
          (t.zpad = function (e, t) {
            for (e = String(e); e.length < t; ) e = "0" + e;
            return e;
          }),
          (t.getPassword = function (e) {
            return "string" == typeof e
              ? (0, s.toUtf8Bytes)(e, "NFKC")
              : (0, s.getBytesCopy)(e);
          }),
          (t.spelunk = function (e, t) {
            let n = t.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
            (0, s.assertArgument)(null != n, "invalid path", "path", t);
            let a = n[1],
              o = n[3],
              l = "!" === n[4],
              u = e;
            for (let e of a.toLowerCase().split(".")) {
              if (Array.isArray(u)) {
                if (!e.match(/^[0-9]+$/)) break;
                u = u[parseInt(e)];
              } else if ("object" == typeof u) {
                let t = null;
                for (let n in u)
                  if (n.toLowerCase() === e) {
                    t = u[n];
                    break;
                  }
                u = t;
              } else u = null;
              if (null == u) break;
            }
            if (
              ((0, s.assertArgument)(
                !l || null != u,
                "missing required value",
                "path",
                a
              ),
              o && null != u)
            ) {
              if ("int" === o) {
                if ("string" == typeof u && u.match(/^-?[0-9]+$/))
                  return parseInt(u);
                if (Number.isSafeInteger(u)) return u;
              }
              if (
                "number" === o &&
                "string" == typeof u &&
                u.match(/^-?[0-9.]*$/)
              )
                return parseFloat(u);
              if ("data" === o && "string" == typeof u) return i(u);
              if (("array" === o && Array.isArray(u)) || o === typeof u)
                return u;
              (0, s.assertArgument)(
                !1,
                `wrong type found for ${o} `,
                "path",
                a
              );
            }
            return u;
          });
      },
      6389: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Wallet = void 0);
        let s = n(96965),
          i = n(42120),
          a = n(85662),
          o = n(90483),
          l = n(78668),
          u = n(10630),
          c = n(40075);
        function d(e) {
          return new Promise((t) => {
            setTimeout(() => {
              t();
            }, e);
          });
        }
        class h extends a.BaseWallet {
          constructor(e, t) {
            "string" != typeof e || e.startsWith("0x") || (e = "0x" + e),
              super("string" == typeof e ? new s.SigningKey(e) : e, t);
          }
          connect(e) {
            return new h(this.signingKey, e);
          }
          async encrypt(e, t) {
            let n = { address: this.address, privateKey: this.privateKey };
            return await (0, u.encryptKeystoreJson)(n, e, {
              progressCallback: t,
            });
          }
          encryptSync(e) {
            let t = { address: this.address, privateKey: this.privateKey };
            return (0, u.encryptKeystoreJsonSync)(t, e);
          }
          static #tM(e) {
            if (
              ((0, i.assertArgument)(
                e,
                "invalid JSON wallet",
                "json",
                "[ REDACTED ]"
              ),
              "mnemonic" in e && e.mnemonic && "en" === e.mnemonic.locale)
            ) {
              let t = c.Mnemonic.fromEntropy(e.mnemonic.entropy),
                n = o.HDNodeWallet.fromMnemonic(t, e.mnemonic.path);
              if (n.address === e.address && n.privateKey === e.privateKey)
                return n;
              console.log(
                "WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key"
              );
            }
            let t = new h(e.privateKey);
            return (
              (0, i.assertArgument)(
                t.address === e.address,
                "address/privateKey mismatch",
                "json",
                "[ REDACTED ]"
              ),
              t
            );
          }
          static async fromEncryptedJson(e, t, n) {
            let s = null;
            return (
              (0, u.isKeystoreJson)(e)
                ? (s = await (0, u.decryptKeystoreJson)(e, t, n))
                : (0, l.isCrowdsaleJson)(e) &&
                  (n && (n(0), await d(0)),
                  (s = (0, l.decryptCrowdsaleJson)(e, t)),
                  n && (n(1), await d(0))),
              h.#tM(s)
            );
          }
          static fromEncryptedJsonSync(e, t) {
            let n = null;
            return (
              (0, u.isKeystoreJson)(e)
                ? (n = (0, u.decryptKeystoreJsonSync)(e, t))
                : (0, l.isCrowdsaleJson)(e)
                ? (n = (0, l.decryptCrowdsaleJson)(e, t))
                : (0, i.assertArgument)(
                    !1,
                    "invalid JSON wallet",
                    "json",
                    "[ REDACTED ]"
                  ),
              h.#tM(n)
            );
          }
          static createRandom(e) {
            let t = o.HDNodeWallet.createRandom();
            return e ? t.connect(e) : t;
          }
          static fromPhrase(e, t) {
            let n = o.HDNodeWallet.fromPhrase(e);
            return t ? n.connect(t) : n;
          }
        }
        t.Wallet = h;
      },
      75033: function (e, t) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decodeBits = void 0),
          (t.decodeBits = function (e, t) {
            let n = (1 << e) - 1,
              s = [],
              i = 0,
              a = 0,
              o = 0;
            for (let l = 0; l < t.length; l++)
              for (
                i =
                  (i << 6) |
                  ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".indexOf(
                    t[l]
                  ),
                  a += 6;
                a >= e;

              ) {
                let t = i >> (a - e);
                (i &= (1 << (a - e)) - 1),
                  (a -= e),
                  0 === t ? (o += n) : (s.push(t + o), (o = 0));
              }
            return s;
          });
      },
      82629: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decodeOwl = t.decode = void 0);
        let s = n(42120),
          i = " !#$%&'()*+,-./<=>?@[]^_`{|}~",
          a = /^[a-z]*$/i;
        function o(e, t) {
          let n = 97;
          return e.reduce(
            (e, s) => (
              s === t
                ? n++
                : s.match(a)
                ? e.push(String.fromCharCode(n) + s)
                : ((n = 97), e.push(s)),
              e
            ),
            []
          );
        }
        function l(e, t) {
          for (let n = i.length - 1; n >= 0; n--)
            e = e.split(i[n]).join(t.substring(2 * n, 2 * n + 2));
          let n = [],
            s = e.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (e, t, s, i) => {
              if (s) for (let e = parseInt(s); e >= 0; e--) n.push(";");
              else n.push(t.toLowerCase());
              return "";
            });
          if (s) throw Error(`leftovers: ${JSON.stringify(s)}`);
          return o(o(n, ";"), ":");
        }
        (t.decode = l),
          (t.decodeOwl = function (e) {
            return (
              (0, s.assertArgument)(
                "0" === e[0],
                "unsupported auwl data",
                "data",
                e
              ),
              l(e.substring(1 + 2 * i.length), e.substring(1, 1 + 2 * i.length))
            );
          });
      },
      84603: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decodeOwlA = void 0);
        let s = n(42120),
          i = n(75033),
          a = n(82629);
        t.decodeOwlA = function (e, t) {
          let n = (0, a.decodeOwl)(e).join(",");
          return (
            t.split(/,/g).forEach((e) => {
              let a = e.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
              (0, s.assertArgument)(
                null !== a,
                "internal error parsing accents",
                "accents",
                t
              );
              let o = 0,
                l = (0, i.decodeBits)(parseInt(a[3]), a[4]),
                u = parseInt(a[2]),
                c = RegExp(`([${a[1]}])`, "g");
              n = n.replace(
                c,
                (e, t) => (
                  0 == --l[o] &&
                    ((t = String.fromCharCode(t.charCodeAt(0), u)), o++),
                  t
                )
              );
            }),
            n.split(",")
          );
        };
      },
      60659: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.wordlists =
            t.WordlistOwlA =
            t.WordlistOwl =
            t.LangEn =
            t.Wordlist =
              void 0);
        var s = n(51208);
        Object.defineProperty(t, "Wordlist", {
          enumerable: !0,
          get: function () {
            return s.Wordlist;
          },
        });
        var i = n(10847);
        Object.defineProperty(t, "LangEn", {
          enumerable: !0,
          get: function () {
            return i.LangEn;
          },
        });
        var a = n(21978);
        Object.defineProperty(t, "WordlistOwl", {
          enumerable: !0,
          get: function () {
            return a.WordlistOwl;
          },
        });
        var o = n(99766);
        Object.defineProperty(t, "WordlistOwlA", {
          enumerable: !0,
          get: function () {
            return o.WordlistOwlA;
          },
        });
        var l = n(99669);
        Object.defineProperty(t, "wordlists", {
          enumerable: !0,
          get: function () {
            return l.wordlists;
          },
        });
      },
      10847: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LangEn = void 0);
        let s = n(21978),
          i = null;
        class a extends s.WordlistOwl {
          constructor() {
            super(
              "en",
              "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO",
              "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60"
            );
          }
          static wordlist() {
            return null == i && (i = new a()), i;
          }
        }
        t.LangEn = a;
      },
      21978: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.WordlistOwl = void 0);
        let s = n(62475),
          i = n(42120),
          a = n(82629),
          o = n(51208);
        class l extends o.Wordlist {
          #r;
          #tL;
          constructor(e, t, n) {
            super(e), (this.#r = t), (this.#tL = n), (this.#t_ = null);
          }
          get _data() {
            return this.#r;
          }
          _decodeWords() {
            return (0, a.decodeOwl)(this.#r);
          }
          #t_;
          #tF() {
            if (null == this.#t_) {
              let e = this._decodeWords();
              if ((0, s.id)(e.join("\n") + "\n") !== this.#tL)
                throw Error(`BIP39 Wordlist for ${this.locale} FAILED`);
              this.#t_ = e;
            }
            return this.#t_;
          }
          getWord(e) {
            let t = this.#tF();
            return (
              (0, i.assertArgument)(
                e >= 0 && e < t.length,
                `invalid word index: ${e}`,
                "index",
                e
              ),
              t[e]
            );
          }
          getWordIndex(e) {
            return this.#tF().indexOf(e);
          }
        }
        t.WordlistOwl = l;
      },
      99766: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.WordlistOwlA = void 0);
        let s = n(21978),
          i = n(84603);
        class a extends s.WordlistOwl {
          #tD;
          constructor(e, t, n, s) {
            super(e, t, s), (this.#tD = n);
          }
          get _accent() {
            return this.#tD;
          }
          _decodeWords() {
            return (0, i.decodeOwlA)(this._data, this._accent);
          }
        }
        t.WordlistOwlA = a;
      },
      51208: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Wordlist = void 0);
        let s = n(42120);
        class i {
          locale;
          constructor(e) {
            (0, s.defineProperties)(this, { locale: e });
          }
          split(e) {
            return e.toLowerCase().split(/\s+/g);
          }
          join(e) {
            return e.join(" ");
          }
        }
        t.Wordlist = i;
      },
      99669: function (e, t, n) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.wordlists = void 0);
        let s = n(10847);
        t.wordlists = { en: s.LangEn.wordlist() };
      },
      85351: function (e, t, n) {
        "use strict";
        let s;
        n.d(t, {
          s_: function () {
            return t_;
          },
          _0: function () {
            return eh;
          },
          $D: function () {
            return ef;
          },
        });
        var i,
          a,
          o,
          l,
          u,
          c,
          d,
          h,
          p,
          f = n(97544);
        let g = { withStackTrace: !1 },
          m = (e, t, n = g) => ({
            data: t.isOk()
              ? { type: "Ok", value: t.value }
              : { type: "Err", value: t.error },
            message: e,
            stack: n.withStackTrace ? Error().stack : void 0,
          });
        function y(e, t, n, s) {
          return new (n || (n = Promise))(function (i, a) {
            function o(e) {
              try {
                u(s.next(e));
              } catch (e) {
                a(e);
              }
            }
            function l(e) {
              try {
                u(s.throw(e));
              } catch (e) {
                a(e);
              }
            }
            function u(e) {
              var t;
              e.done
                ? i(e.value)
                : ((t = e.value) instanceof n
                    ? t
                    : new n(function (e) {
                        e(t);
                      })
                  ).then(o, l);
            }
            u((s = s.apply(e, t || [])).next());
          });
        }
        function b(e) {
          return this instanceof b ? ((this.v = e), this) : new b(e);
        }
        class A {
          constructor(e) {
            this._promise = e;
          }
          static fromSafePromise(e) {
            return new A(e.then((e) => new O(e)));
          }
          static fromPromise(e, t) {
            return new A(e.then((e) => new O(e)).catch((e) => new S(t(e))));
          }
          static fromThrowable(e, t) {
            return (...n) =>
              new A(
                y(this, void 0, void 0, function* () {
                  try {
                    return new O(yield e(...n));
                  } catch (e) {
                    return new S(t ? t(e) : e);
                  }
                })
              );
          }
          static combine(e) {
            return E(e);
          }
          static combineWithAllErrors(e) {
            return k(e);
          }
          map(e) {
            return new A(
              this._promise.then((t) =>
                y(this, void 0, void 0, function* () {
                  return t.isErr() ? new S(t.error) : new O(yield e(t.value));
                })
              )
            );
          }
          mapErr(e) {
            return new A(
              this._promise.then((t) =>
                y(this, void 0, void 0, function* () {
                  return t.isOk() ? new O(t.value) : new S(yield e(t.error));
                })
              )
            );
          }
          andThen(e) {
            return new A(
              this._promise.then((t) => {
                if (t.isErr()) return new S(t.error);
                let n = e(t.value);
                return n instanceof A ? n._promise : n;
              })
            );
          }
          orElse(e) {
            return new A(
              this._promise.then((t) =>
                y(this, void 0, void 0, function* () {
                  return t.isErr() ? e(t.error) : new O(t.value);
                })
              )
            );
          }
          match(e, t) {
            return this._promise.then((n) => n.match(e, t));
          }
          unwrapOr(e) {
            return this._promise.then((t) => t.unwrapOr(e));
          }
          safeUnwrap() {
            return (function (e, t, n) {
              if (!Symbol.asyncIterator)
                throw TypeError("Symbol.asyncIterator is not defined.");
              var s,
                i = n.apply(e, t || []),
                a = [];
              return (
                (s = {}),
                o("next"),
                o("throw"),
                o("return"),
                (s[Symbol.asyncIterator] = function () {
                  return this;
                }),
                s
              );
              function o(e) {
                i[e] &&
                  (s[e] = function (t) {
                    return new Promise(function (n, s) {
                      a.push([e, t, n, s]) > 1 || l(e, t);
                    });
                  });
              }
              function l(e, t) {
                try {
                  var n;
                  (n = i[e](t)).value instanceof b
                    ? Promise.resolve(n.value.v).then(u, c)
                    : d(a[0][2], n);
                } catch (e) {
                  d(a[0][3], e);
                }
              }
              function u(e) {
                l("next", e);
              }
              function c(e) {
                l("throw", e);
              }
              function d(e, t) {
                e(t), a.shift(), a.length && l(a[0][0], a[0][1]);
              }
            })(this, arguments, function* () {
              return yield b(
                yield b(
                  yield* (function (e) {
                    var t, n;
                    return (
                      (t = {}),
                      s("next"),
                      s("throw", function (e) {
                        throw e;
                      }),
                      s("return"),
                      (t[Symbol.iterator] = function () {
                        return this;
                      }),
                      t
                    );
                    function s(s, i) {
                      t[s] = e[s]
                        ? function (t) {
                            return (n = !n)
                              ? { value: b(e[s](t)), done: "return" === s }
                              : i
                              ? i(t)
                              : t;
                          }
                        : i;
                    }
                  })(
                    (function (e) {
                      if (!Symbol.asyncIterator)
                        throw TypeError("Symbol.asyncIterator is not defined.");
                      var t,
                        n = e[Symbol.asyncIterator];
                      return n
                        ? n.call(e)
                        : ((e = (function (e) {
                            var t =
                                "function" == typeof Symbol && Symbol.iterator,
                              n = t && e[t],
                              s = 0;
                            if (n) return n.call(e);
                            if (e && "number" == typeof e.length)
                              return {
                                next: function () {
                                  return (
                                    e && s >= e.length && (e = void 0),
                                    { value: e && e[s++], done: !e }
                                  );
                                },
                              };
                            throw TypeError(
                              t
                                ? "Object is not iterable."
                                : "Symbol.iterator is not defined."
                            );
                          })(e)),
                          (t = {}),
                          s("next"),
                          s("throw"),
                          s("return"),
                          (t[Symbol.asyncIterator] = function () {
                            return this;
                          }),
                          t);
                      function s(n) {
                        t[n] =
                          e[n] &&
                          function (t) {
                            return new Promise(function (s, i) {
                              (function (e, t, n, s) {
                                Promise.resolve(s).then(function (t) {
                                  e({ value: t, done: n });
                                }, t);
                              })(s, i, (t = e[n](t)).done, t.value);
                            });
                          };
                      }
                    })(yield b(this._promise.then((e) => e.safeUnwrap())))
                  )
                )
              );
            });
          }
          then(e, t) {
            return this._promise.then(e, t);
          }
        }
        let w = (e) => new A(Promise.resolve(new S(e)));
        A.fromPromise, A.fromSafePromise, A.fromThrowable;
        let v = (e) => {
            let t = T([]);
            for (let n of e) {
              if (n.isErr()) {
                t = x(n.error);
                break;
              }
              t.map((e) => e.push(n.value));
            }
            return t;
          },
          E = (e) => A.fromSafePromise(Promise.all(e)).andThen(v),
          P = (e) => {
            let t = T([]);
            for (let n of e)
              n.isErr() && t.isErr()
                ? t.error.push(n.error)
                : n.isErr() && t.isOk()
                ? (t = x([n.error]))
                : n.isOk() && t.isOk() && t.value.push(n.value);
            return t;
          },
          k = (e) => A.fromSafePromise(Promise.all(e)).andThen(P);
        ((i = p || (p = {})).fromThrowable = function (e, t) {
          return (...n) => {
            try {
              let t = e(...n);
              return T(t);
            } catch (e) {
              return x(t ? t(e) : e);
            }
          };
        }),
          (i.combine = function (e) {
            return v(e);
          }),
          (i.combineWithAllErrors = function (e) {
            return P(e);
          });
        let T = (e) => new O(e),
          x = (e) => new S(e);
        class O {
          constructor(e) {
            this.value = e;
          }
          isOk() {
            return !0;
          }
          isErr() {
            return !this.isOk();
          }
          map(e) {
            return T(e(this.value));
          }
          mapErr(e) {
            return T(this.value);
          }
          andThen(e) {
            return e(this.value);
          }
          orElse(e) {
            return T(this.value);
          }
          asyncAndThen(e) {
            return e(this.value);
          }
          asyncMap(e) {
            return A.fromSafePromise(e(this.value));
          }
          unwrapOr(e) {
            return this.value;
          }
          match(e, t) {
            return e(this.value);
          }
          safeUnwrap() {
            let e = this.value;
            return (function* () {
              return e;
            })();
          }
          _unsafeUnwrap(e) {
            return this.value;
          }
          _unsafeUnwrapErr(e) {
            throw m("Called `_unsafeUnwrapErr` on an Ok", this, e);
          }
        }
        class S {
          constructor(e) {
            this.error = e;
          }
          isOk() {
            return !1;
          }
          isErr() {
            return !this.isOk();
          }
          map(e) {
            return x(this.error);
          }
          mapErr(e) {
            return x(e(this.error));
          }
          andThen(e) {
            return x(this.error);
          }
          orElse(e) {
            return e(this.error);
          }
          asyncAndThen(e) {
            return w(this.error);
          }
          asyncMap(e) {
            return w(this.error);
          }
          unwrapOr(e) {
            return e;
          }
          match(e, t) {
            return t(this.error);
          }
          safeUnwrap() {
            let e = this.error;
            return (function* () {
              throw (
                (yield x(e),
                Error("Do not use this generator out of `safeTry`"))
              );
            })();
          }
          _unsafeUnwrap(e) {
            throw m("Called `_unsafeUnwrap` on an Err", this, e);
          }
          _unsafeUnwrapErr(e) {
            return this.error;
          }
        }
        p.fromThrowable;
        var C = n(94898),
          B = n(80284),
          N = n(68597),
          R = n(98494),
          I = Object.defineProperty,
          M = (e, t, n) =>
            t in e
              ? I(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n),
          L = (e, t, n) => (M(e, "symbol" != typeof t ? t + "" : t, n), n),
          _ = class extends Error {
            constructor(e, t) {
              let n;
              (n =
                "string" == typeof t
                  ? { message: t }
                  : t instanceof Error
                  ? { cause: t, message: t.message }
                  : t).message || (n.message = n.cause?.message || ""),
                super(n.message, { cause: n.cause }),
                L(this, "errCode"),
                L(this, "presentable", !1),
                (this.name = "AuthClientError"),
                (this.errCode = e);
            }
          },
          F = (e) =>
            e.isErr()
              ? { error: e.error, isError: !0 }
              : { ...e.value, isError: !1 },
          D = {
            interval: 1e3,
            timeout: 1e4,
            successCode: 200,
            onResponse: () => {},
          },
          U = async (e, t, n) =>
            A.fromPromise(
              fetch($(e, t), { headers: G(n) }),
              (e) => new _("unknown", e)
            ).andThen((e) =>
              A.fromPromise(e.json(), (e) => new _("unknown", e)).andThen((t) =>
                T({ response: e, data: t })
              )
            ),
          j = async (e, t, n, s) =>
            A.fromPromise(
              fetch($(e, t), {
                method: "POST",
                body: JSON.stringify(n),
                headers: G(s),
              }),
              (e) => new _("unknown", e)
            ).andThen((e) =>
              A.fromPromise(e.json(), (e) => new _("unknown", e)).andThen((t) =>
                T({ response: e, data: t })
              )
            ),
          H = async (e, t, n, s) => {
            let {
                timeout: i,
                interval: a,
                successCode: o,
                onResponse: l,
              } = { ...D, ...n },
              u = Date.now() + i;
            for (; Date.now() < u; ) {
              let n = await U(e, t, s);
              if (!n.isOk()) return x(n.error);
              {
                let { response: e } = n.value;
                if (e.status === o) return T(n.value);
                l(n.value), await new Promise((e) => setTimeout(e, a));
              }
            }
            return x(new _("unavailable", `Polling timed out after ${i}ms`));
          },
          $ = (e, t) => `${e.config.relay}/${e.config.version}/${t}`,
          G = (e) => {
            let t = { ...e?.headers };
            return (
              e?.authToken && (t.Authorization = `Bearer ${e.authToken}`),
              { ...t, "Content-Type": "application/json" }
            );
          },
          K = async (e, { ...t }) => F(await j(e, "channel", t)),
          V = async (e, { channelToken: t }) =>
            F(await U(e, "channel/status", { authToken: t })),
          z = "Farcaster Auth",
          J = /^farcaster:\/\/fid\/([1-9]\d*)\/?$/,
          Q = (e) =>
            p
              .fromThrowable(
                () => new f.SiweMessage(e),
                (e) => new _("bad_request.validation_failure", e)
              )()
              .andThen(Y)
              .andThen(Z)
              .andThen(X),
          q = (e) => {
            let t = W(e);
            return t.isErr() ? x(t.error) : T({ fid: t.value });
          },
          W = (e) => {
            let t = (e.resources ?? []).find((e) => J.test(e));
            if (!t)
              return x(
                new _(
                  "bad_request.validation_failure",
                  "No fid resource provided"
                )
              );
            let n = parseInt(t.match(J)?.[1] ?? "");
            return isNaN(n)
              ? x(new _("bad_request.validation_failure", "Invalid fid"))
              : T(n);
          },
          Y = (e) =>
            e.statement === z || "Farcaster Connect" === e.statement
              ? T(e)
              : x(
                  new _(
                    "bad_request.validation_failure",
                    `Statement must be '${z}'`
                  )
                ),
          Z = (e) =>
            10 !== e.chainId
              ? x(
                  new _("bad_request.validation_failure", "Chain ID must be 10")
                )
              : T(e),
          X = (e) => {
            let t = (e.resources ?? []).filter((e) => J.test(e));
            return 0 === t.length
              ? x(
                  new _(
                    "bad_request.validation_failure",
                    "No fid resource provided"
                  )
                )
              : t.length > 1
              ? x(
                  new _(
                    "bad_request.validation_failure",
                    "Multiple fid resources provided"
                  )
                )
              : T(e);
          },
          ee = (e) =>
            Promise.reject(
              Error("Not implemented: Must provide an fid verifier")
            ),
          et = async (e, t, n, s, i = { getFid: ee }) => {
            let { getFid: a, provider: o } = i,
              l = Q(n)
                .andThen((t) => er(t, e))
                .andThen((e) => en(e, t));
            if (l.isErr()) return x(l.error);
            let u = (await es(l.value, s, o)).andThen(ea);
            if (u.isErr()) return x(u.error);
            if (!u.value.success)
              return x(
                new _(
                  "unauthorized",
                  u.value.error?.type ?? "Failed to verify SIWE message"
                )
              );
            let c = await ei(u.value, a);
            if (c.isErr()) return x(c.error);
            if (!c.value.success)
              return x(
                new _(
                  "unauthorized",
                  u.value.error?.type ?? "Failed to validate fid owner"
                )
              );
            let { error: d, ...h } = c.value;
            return T(h);
          },
          er = (e, t) =>
            e.nonce !== t ? x(new _("unauthorized", "Invalid nonce")) : T(e),
          en = (e, t) =>
            e.domain !== t ? x(new _("unauthorized", "Invalid domain")) : T(e),
          es = async (e, t, n) =>
            A.fromPromise(
              e.verify(
                { signature: t },
                { provider: n, suppressExceptions: !0 }
              ),
              (e) => new _("unauthorized", e)
            ),
          ei = async (e, t) => {
            let n = e.data.address;
            return A.fromPromise(t(n), (e) => new _("unavailable", e)).andThen(
              (t) => (
                t !== BigInt(e.fid) &&
                  ((e.success = !1),
                  (e.error = new f.SiweError(
                    `Invalid resource: signer ${n} does not own fid ${e.fid}.`,
                    e.fid.toString(),
                    t.toString()
                  ))),
                T(e)
              )
            );
          },
          ea = (e) => q(e.data).andThen((t) => T({ ...t, ...e })),
          eo = async (
            e,
            { nonce: t, domain: n, message: s, signature: i },
            a
          ) =>
            F(await et(t, n, s, i, { getFid: e.ethereum.getFid, provider: a })),
          el = () => {},
          eu = async (e, t) =>
            F(
              await H(
                e,
                "channel/status",
                {
                  timeout: t?.timeout ?? 3e5,
                  interval: t?.interval ?? 1e3,
                  onResponse: t?.onResponse ?? el,
                },
                { authToken: t.channelToken }
              )
            ),
          ec = { relay: "https://relay.farcaster.xyz", version: "v1" },
          ed = ({ ethereum: e, ...t }) => ({
            config: { ...ec, ...t },
            ethereum: e,
          }),
          eh = (e, t) => {
            let n = ed(e);
            return {
              ...n,
              createChannel: (e) => K(n, e),
              status: (e) => V(n, e),
              watchStatus: (e) => eu(n, e),
              verifySignInMessage: (e) => eo(n, e, t),
            };
          },
          ep = [
            {
              inputs: [
                { internalType: "address", name: "_migrator", type: "address" },
                {
                  internalType: "address",
                  name: "_initialOwner",
                  type: "address",
                },
              ],
              stateMutability: "nonpayable",
              type: "constructor",
            },
            { inputs: [], name: "AlreadyMigrated", type: "error" },
            { inputs: [], name: "GatewayFrozen", type: "error" },
            { inputs: [], name: "HasId", type: "error" },
            { inputs: [], name: "HasNoId", type: "error" },
            {
              inputs: [
                { internalType: "address", name: "account", type: "address" },
                {
                  internalType: "uint256",
                  name: "currentNonce",
                  type: "uint256",
                },
              ],
              name: "InvalidAccountNonce",
              type: "error",
            },
            { inputs: [], name: "InvalidShortString", type: "error" },
            { inputs: [], name: "InvalidSignature", type: "error" },
            { inputs: [], name: "OnlyGuardian", type: "error" },
            { inputs: [], name: "OnlyMigrator", type: "error" },
            { inputs: [], name: "PermissionRevoked", type: "error" },
            { inputs: [], name: "SignatureExpired", type: "error" },
            {
              inputs: [{ internalType: "string", name: "str", type: "string" }],
              name: "StringTooLong",
              type: "error",
            },
            { inputs: [], name: "Unauthorized", type: "error" },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "address",
                  name: "guardian",
                  type: "address",
                },
              ],
              name: "Add",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "fid",
                  type: "uint256",
                },
              ],
              name: "AdminReset",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "id",
                  type: "uint256",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "recovery",
                  type: "address",
                },
              ],
              name: "ChangeRecoveryAddress",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [],
              name: "EIP712DomainChanged",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !1,
                  internalType: "address",
                  name: "idGateway",
                  type: "address",
                },
              ],
              name: "FreezeIdGateway",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "migratedAt",
                  type: "uint256",
                },
              ],
              name: "Migrated",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "address",
                  name: "previousOwner",
                  type: "address",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "newOwner",
                  type: "address",
                },
              ],
              name: "OwnershipTransferStarted",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "address",
                  name: "previousOwner",
                  type: "address",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "newOwner",
                  type: "address",
                },
              ],
              name: "OwnershipTransferred",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !1,
                  internalType: "address",
                  name: "account",
                  type: "address",
                },
              ],
              name: "Paused",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "address",
                  name: "from",
                  type: "address",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "to",
                  type: "address",
                },
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "id",
                  type: "uint256",
                },
              ],
              name: "Recover",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "address",
                  name: "to",
                  type: "address",
                },
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "id",
                  type: "uint256",
                },
                {
                  indexed: !1,
                  internalType: "address",
                  name: "recovery",
                  type: "address",
                },
              ],
              name: "Register",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "address",
                  name: "guardian",
                  type: "address",
                },
              ],
              name: "Remove",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !1,
                  internalType: "uint256",
                  name: "oldCounter",
                  type: "uint256",
                },
                {
                  indexed: !1,
                  internalType: "uint256",
                  name: "newCounter",
                  type: "uint256",
                },
              ],
              name: "SetIdCounter",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !1,
                  internalType: "address",
                  name: "oldIdGateway",
                  type: "address",
                },
                {
                  indexed: !1,
                  internalType: "address",
                  name: "newIdGateway",
                  type: "address",
                },
              ],
              name: "SetIdGateway",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !1,
                  internalType: "address",
                  name: "oldMigrator",
                  type: "address",
                },
                {
                  indexed: !1,
                  internalType: "address",
                  name: "newMigrator",
                  type: "address",
                },
              ],
              name: "SetMigrator",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "address",
                  name: "from",
                  type: "address",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "to",
                  type: "address",
                },
                {
                  indexed: !0,
                  internalType: "uint256",
                  name: "id",
                  type: "uint256",
                },
              ],
              name: "Transfer",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !1,
                  internalType: "address",
                  name: "account",
                  type: "address",
                },
              ],
              name: "Unpaused",
              type: "event",
            },
            {
              inputs: [],
              name: "CHANGE_RECOVERY_ADDRESS_TYPEHASH",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "TRANSFER_AND_CHANGE_RECOVERY_TYPEHASH",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "TRANSFER_TYPEHASH",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "VERSION",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "acceptOwnership",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "guardian", type: "address" },
              ],
              name: "addGuardian",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                {
                  components: [
                    { internalType: "uint24", name: "fid", type: "uint24" },
                    {
                      internalType: "address",
                      name: "custody",
                      type: "address",
                    },
                    {
                      internalType: "address",
                      name: "recovery",
                      type: "address",
                    },
                  ],
                  internalType: "struct IIdRegistry.BulkRegisterData[]",
                  name: "ids",
                  type: "tuple[]",
                },
              ],
              name: "bulkRegisterIds",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                {
                  components: [
                    { internalType: "uint24", name: "fid", type: "uint24" },
                    {
                      internalType: "address",
                      name: "custody",
                      type: "address",
                    },
                  ],
                  internalType:
                    "struct IIdRegistry.BulkRegisterDefaultRecoveryData[]",
                  name: "ids",
                  type: "tuple[]",
                },
                { internalType: "address", name: "recovery", type: "address" },
              ],
              name: "bulkRegisterIdsWithDefaultRecovery",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint24[]", name: "ids", type: "uint24[]" },
              ],
              name: "bulkResetIds",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "recovery", type: "address" },
              ],
              name: "changeRecoveryAddress",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "owner", type: "address" },
                { internalType: "address", name: "recovery", type: "address" },
                { internalType: "uint256", name: "deadline", type: "uint256" },
                { internalType: "bytes", name: "sig", type: "bytes" },
              ],
              name: "changeRecoveryAddressFor",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "fid", type: "uint256" },
              ],
              name: "custodyOf",
              outputs: [
                { internalType: "address", name: "custody", type: "address" },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "domainSeparatorV4",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "eip712Domain",
              outputs: [
                { internalType: "bytes1", name: "fields", type: "bytes1" },
                { internalType: "string", name: "name", type: "string" },
                { internalType: "string", name: "version", type: "string" },
                { internalType: "uint256", name: "chainId", type: "uint256" },
                {
                  internalType: "address",
                  name: "verifyingContract",
                  type: "address",
                },
                { internalType: "bytes32", name: "salt", type: "bytes32" },
                {
                  internalType: "uint256[]",
                  name: "extensions",
                  type: "uint256[]",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "freezeIdGateway",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [],
              name: "gatewayFrozen",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "gracePeriod",
              outputs: [{ internalType: "uint24", name: "", type: "uint24" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "guardian", type: "address" },
              ],
              name: "guardians",
              outputs: [
                { internalType: "bool", name: "isGuardian", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                {
                  internalType: "bytes32",
                  name: "structHash",
                  type: "bytes32",
                },
              ],
              name: "hashTypedDataV4",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "idCounter",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "idGateway",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "owner", type: "address" },
              ],
              name: "idOf",
              outputs: [
                { internalType: "uint256", name: "fid", type: "uint256" },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "isMigrated",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "migrate",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [],
              name: "migratedAt",
              outputs: [{ internalType: "uint40", name: "", type: "uint40" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "migrator",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "name",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "owner", type: "address" },
              ],
              name: "nonces",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "owner",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "pause",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [],
              name: "paused",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [],
              name: "pendingOwner",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "from", type: "address" },
                { internalType: "address", name: "to", type: "address" },
                { internalType: "uint256", name: "deadline", type: "uint256" },
                { internalType: "bytes", name: "sig", type: "bytes" },
              ],
              name: "recover",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "from", type: "address" },
                { internalType: "address", name: "to", type: "address" },
                {
                  internalType: "uint256",
                  name: "recoveryDeadline",
                  type: "uint256",
                },
                { internalType: "bytes", name: "recoverySig", type: "bytes" },
                {
                  internalType: "uint256",
                  name: "toDeadline",
                  type: "uint256",
                },
                { internalType: "bytes", name: "toSig", type: "bytes" },
              ],
              name: "recoverFor",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "fid", type: "uint256" },
              ],
              name: "recoveryOf",
              outputs: [
                { internalType: "address", name: "recovery", type: "address" },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "to", type: "address" },
                { internalType: "address", name: "recovery", type: "address" },
              ],
              name: "register",
              outputs: [
                { internalType: "uint256", name: "fid", type: "uint256" },
              ],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "guardian", type: "address" },
              ],
              name: "removeGuardian",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [],
              name: "renounceOwnership",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "uint256", name: "_counter", type: "uint256" },
              ],
              name: "setIdCounter",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                {
                  internalType: "address",
                  name: "_idGateway",
                  type: "address",
                },
              ],
              name: "setIdGateway",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "_migrator", type: "address" },
              ],
              name: "setMigrator",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "to", type: "address" },
                { internalType: "uint256", name: "deadline", type: "uint256" },
                { internalType: "bytes", name: "sig", type: "bytes" },
              ],
              name: "transfer",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "to", type: "address" },
                { internalType: "address", name: "recovery", type: "address" },
                { internalType: "uint256", name: "deadline", type: "uint256" },
                { internalType: "bytes", name: "sig", type: "bytes" },
              ],
              name: "transferAndChangeRecovery",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "from", type: "address" },
                { internalType: "address", name: "to", type: "address" },
                { internalType: "address", name: "recovery", type: "address" },
                {
                  internalType: "uint256",
                  name: "fromDeadline",
                  type: "uint256",
                },
                { internalType: "bytes", name: "fromSig", type: "bytes" },
                {
                  internalType: "uint256",
                  name: "toDeadline",
                  type: "uint256",
                },
                { internalType: "bytes", name: "toSig", type: "bytes" },
              ],
              name: "transferAndChangeRecoveryFor",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "from", type: "address" },
                { internalType: "address", name: "to", type: "address" },
                {
                  internalType: "uint256",
                  name: "fromDeadline",
                  type: "uint256",
                },
                { internalType: "bytes", name: "fromSig", type: "bytes" },
                {
                  internalType: "uint256",
                  name: "toDeadline",
                  type: "uint256",
                },
                { internalType: "bytes", name: "toSig", type: "bytes" },
              ],
              name: "transferFor",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "newOwner", type: "address" },
              ],
              name: "transferOwnership",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [],
              name: "unpause",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [],
              name: "useNonce",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            {
              inputs: [
                {
                  internalType: "address",
                  name: "custodyAddress",
                  type: "address",
                },
                { internalType: "uint256", name: "fid", type: "uint256" },
                { internalType: "bytes32", name: "digest", type: "bytes32" },
                { internalType: "bytes", name: "sig", type: "bytes" },
              ],
              name: "verifyFidSignature",
              outputs: [
                { internalType: "bool", name: "isValid", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
            },
          ],
          ef = (e) => {
            let t = (function (e) {
              let { key: t = "public", name: n = "Public Client" } = e;
              return (0, C.e)({
                ...e,
                key: t,
                name: n,
                type: "publicClient",
              }).extend(B.I);
            })({ chain: R.v, transport: (0, N.d)(e?.rpcUrl) });
            return {
              getFid: async (e) =>
                t.readContract({
                  address: "0x00000000Fc6c5F01Fc30151999387Bb99A9f489b",
                  abi: ep,
                  functionName: "idOf",
                  args: [e],
                }),
            };
          },
          eg = n(85893),
          em = n(67294);
        n(73935);
        let ey = {
          relay: "https://relay.farcaster.xyz",
          version: "v1",
          ...("u" > typeof window && null != window && window.location
            ? { domain: window.location.host, siweUri: window.location.href }
            : {}),
        };
        function eb({ height: e, fill: t }) {
          return (0, eg.jsxs)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            width: 1.1 * e,
            height: e,
            fill: "none",
            children: [
              (0, eg.jsx)("title", { children: "Farcaster logo" }),
              (0, eg.jsxs)("g", {
                fill: eA[t],
                clipPath: "url(#a)",
                children: [
                  (0, eg.jsx)("path", {
                    d: "M3.786.05h14.156v2.824h4.025l-.844 2.825h-.714v11.427c.358 0 .65.287.65.642v.77h.13c.358 0 .649.288.649.642v.77h-7.273v-.77c0-.354.29-.642.65-.642h.13v-.77c0-.309.22-.566.512-.628l-.014-6.306c-.23-2.519-2.37-4.493-4.98-4.493-2.608 0-4.75 1.974-4.979 4.494l-.013 6.3c.346.05.772.315.772.633v.77h.13c.358 0 .65.288.65.642v.77H.15v-.77c0-.354.29-.642.649-.642h.13v-.77c0-.355.29-.642.65-.642V5.7H.863L.02 2.874h3.766V.05Z",
                  }),
                  (0, eg.jsx)("path", {
                    d: "M17.942.05h.047V.003h-.047V.05ZM3.786.05V.003H3.74V.05h.047Zm14.156 2.824h-.048v.047h.048v-.047Zm4.025 0 .046.013.018-.06h-.064v.047Zm-.844 2.824v.047h.035l.01-.033-.045-.014Zm-.714 0v-.046h-.047v.046h.047Zm0 11.428h-.047v.047h.047v-.047Zm.65 1.412h-.048v.047h.047v-.047Zm.779 1.412v.047h.046v-.047h-.046Zm-7.273 0h-.048v.047h.048v-.047Zm.78-1.412v.047h.047v-.047h-.048Zm.512-1.398.01.045.038-.007v-.038h-.048Zm-.014-6.306h.048v-.004l-.048.004Zm-9.959 0-.047-.004v.004h.047Zm-.013 6.3h-.048v.041l.04.006.008-.047Zm.772 1.404h-.047v.047h.047v-.047Zm.78 1.412v.047h.047v-.047h-.048Zm-7.273 0H.102v.047H.15v-.047Zm.779-1.412v.047h.047v-.047H.93Zm.65-1.412v.047h.047v-.047h-.047Zm0-11.428h.047v-.046h-.047v.046Zm-.715 0-.045.014.01.033h.035v-.047ZM.02 2.874v-.047h-.063l.018.06.045-.013Zm3.766 0v.047h.048v-.047h-.048ZM17.942.003H3.786v.093h14.156V.003Zm.047 2.87V.05h-.095v2.824h.095Zm3.978-.046h-4.025v.094h4.025v-.094Zm-.798 2.885.844-2.825-.091-.026-.845 2.824.092.027Zm-.76.033h.714v-.093h-.714v.093Zm.048 11.381V5.698h-.095v11.428h.095Zm.649.641a.693.693 0 0 0-.697-.688v.094c.332 0 .602.266.602.595h.095Zm0 .77v-.77h-.095v.77h.095Zm.082-.045h-.13v.093h.13v-.093Zm.697.688a.692.692 0 0 0-.697-.688v.093c.333 0 .602.267.602.595h.095Zm0 .77v-.77h-.095v.77h.095Zm-3.943.047h3.896v-.094h-3.896v.094Zm-2.079 0h2.079v-.094h-2.079v.094Zm-1.298 0h1.298v-.094h-1.298v.094Zm-.048-.817v.77h.095v-.77h-.095Zm.697-.688a.693.693 0 0 0-.697.688h.095c0-.328.27-.595.602-.595v-.093Zm.13 0h-.13v.093h.13v-.093Zm-.047-.725v.77h.095v-.77h-.095Zm.55-.673a.69.69 0 0 0-.55.673h.095c0-.285.203-.524.476-.582l-.02-.09Zm-.051-6.26.014 6.306h.095l-.014-6.306h-.095Zm-4.932-4.447c2.583 0 4.704 1.956 4.932 4.452l.094-.009c-.232-2.543-2.393-4.536-5.026-4.536v.093ZM5.932 10.84c.227-2.496 2.348-4.452 4.932-4.452v-.093c-2.633 0-4.795 1.993-5.027 4.536l.095.008Zm-.014 6.295.014-6.3h-.095l-.014 6.3h.095Zm.773.633c0-.18-.12-.337-.276-.453a1.236 1.236 0 0 0-.538-.226l-.014.093c.166.025.351.1.495.207.145.108.238.241.238.38h.095Zm0 .77v-.77h-.095v.77h.095Zm.082-.045h-.13v.093h.13v-.093Zm.697.688a.693.693 0 0 0-.697-.688v.093c.332 0 .602.267.602.595h.095Zm0 .77v-.77h-.095v.77h.095Zm-1.606.047h1.558v-.094H5.864v.094Zm-.108 0h.108v-.094h-.108v.094Zm-1.97 0h1.97v-.094h-1.97v.094Zm-3.636 0h3.636v-.094H.15v.094Zm-.048-.817v.77h.095v-.77H.102Zm.697-.688a.693.693 0 0 0-.697.688h.095c0-.328.27-.595.602-.595v-.093Zm.13 0h-.13v.093h.13v-.093Zm-.048-.725v.77h.095v-.77H.881Zm.698-.688a.693.693 0 0 0-.698.688h.095c0-.328.27-.594.603-.594v-.094ZM1.53 5.7v11.427h.095V5.698h-.095Zm-.667.046h.715v-.093H.864v.093Zm-.89-2.858L.82 5.712l.09-.027-.844-2.824-.09.026Zm3.812-.06H.02v.094h3.766v-.094ZM3.74.05v2.824h.095V.05h-.095Z",
                  }),
                ],
              }),
              (0, eg.jsx)("defs", {
                children: (0, eg.jsx)("clipPath", {
                  id: "a",
                  children: (0, eg.jsx)("path", {
                    fill: eA[t],
                    d: "M0 0h22v20H0z",
                  }),
                }),
              }),
            ],
          });
        }
        (0, em.createContext)({
          isAuthenticated: !1,
          config: ey,
          profile: {},
          signInMessage: {},
          onSignIn: () => {},
          onSignOut: () => {},
        });
        let eA = { purple: "#7C65C1", white: "#FFFFFF" };
        var ew = function () {
          return (ew =
            Object.assign ||
            function (e) {
              for (var t, n = 1, s = arguments.length; n < s; n++)
                for (var i in (t = arguments[n]))
                  Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
              return e;
            }).apply(this, arguments);
        };
        function ev(e, t) {
          var n = {};
          for (var s in e)
            Object.prototype.hasOwnProperty.call(e, s) &&
              0 > t.indexOf(s) &&
              (n[s] = e[s]);
          if (null != e && "function" == typeof Object.getOwnPropertySymbols)
            for (
              var i = 0, s = Object.getOwnPropertySymbols(e);
              i < s.length;
              i++
            )
              0 > t.indexOf(s[i]) &&
                Object.prototype.propertyIsEnumerable.call(e, s[i]) &&
                (n[s[i]] = e[s[i]]);
          return n;
        }
        var eE = "right-scroll-bar-position",
          eP = "width-before-scroll-bar",
          ek = function (e) {
            var t = e.sideCar,
              n = ev(e, ["sideCar"]);
            if (!t)
              throw Error(
                "Sidecar: please provide `sideCar` property to import the right car"
              );
            var s = t.read();
            if (!s) throw Error("Sidecar medium not found");
            return em.createElement(s, ew({}, n));
          };
        ek.isSideCarExport = !0;
        var eT =
            (void 0 === a && (a = {}),
            ((void 0 === o &&
              (o = function (e) {
                return e;
              }),
            (l = []),
            (u = !1),
            (c = {
              read: function () {
                if (u)
                  throw Error(
                    "Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."
                  );
                return l.length ? l[l.length - 1] : null;
              },
              useMedium: function (e) {
                var t = o(e, u);
                return (
                  l.push(t),
                  function () {
                    l = l.filter(function (e) {
                      return e !== t;
                    });
                  }
                );
              },
              assignSyncMedium: function (e) {
                for (u = !0; l.length; ) {
                  var t = l;
                  (l = []), t.forEach(e);
                }
                l = {
                  push: function (t) {
                    return e(t);
                  },
                  filter: function () {
                    return l;
                  },
                };
              },
              assignMedium: function (e) {
                u = !0;
                var t = [];
                if (l.length) {
                  var n = l;
                  (l = []), n.forEach(e), (t = l);
                }
                var s = function () {
                    var n = t;
                    (t = []), n.forEach(e);
                  },
                  i = function () {
                    return Promise.resolve().then(s);
                  };
                i(),
                  (l = {
                    push: function (e) {
                      t.push(e), i();
                    },
                    filter: function (e) {
                      return (t = t.filter(e)), l;
                    },
                  });
              },
            })).options = ew({ async: !0, ssr: !1 }, a)),
            c),
          ex = function () {},
          eO = em.forwardRef(function (e, t) {
            var n,
              s,
              i,
              a = em.useRef(null),
              o = em.useState({
                onScrollCapture: ex,
                onWheelCapture: ex,
                onTouchMoveCapture: ex,
              }),
              l = o[0],
              u = o[1],
              c = e.forwardProps,
              d = e.children,
              h = e.className,
              p = e.removeScrollBar,
              f = e.enabled,
              g = e.shards,
              m = e.sideCar,
              y = e.noIsolation,
              b = e.inert,
              A = e.allowPinchZoom,
              w = e.as,
              v = e.gapMode,
              E = ev(e, [
                "forwardProps",
                "children",
                "className",
                "removeScrollBar",
                "enabled",
                "shards",
                "sideCar",
                "noIsolation",
                "inert",
                "allowPinchZoom",
                "as",
                "gapMode",
              ]),
              P =
                ((n = [a, t]),
                (s = function (e) {
                  return n.forEach(function (t) {
                    return (
                      "function" == typeof t ? t(e) : t && (t.current = e), t
                    );
                  });
                }),
                ((i = (0, em.useState)(function () {
                  return {
                    value: null,
                    callback: s,
                    facade: {
                      get current() {
                        return i.value;
                      },
                      set current(r) {
                        var e = i.value;
                        e !== r && ((i.value = r), i.callback(r, e));
                      },
                    },
                  };
                })[0]).callback = s),
                i.facade),
              k = ew(ew({}, E), l);
            return em.createElement(
              em.Fragment,
              null,
              f &&
                em.createElement(m, {
                  sideCar: eT,
                  removeScrollBar: p,
                  shards: g,
                  noIsolation: y,
                  inert: b,
                  setCallbacks: u,
                  allowPinchZoom: !!A,
                  lockRef: a,
                  gapMode: v,
                }),
              c
                ? em.cloneElement(
                    em.Children.only(d),
                    ew(ew({}, k), { ref: P })
                  )
                : em.createElement(
                    void 0 === w ? "div" : w,
                    ew({}, k, { className: h, ref: P }),
                    d
                  )
            );
          });
        (eO.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }),
          (eO.classNames = { fullWidth: eP, zeroRight: eE });
        var eS = function () {
            var e = 0,
              t = null;
            return {
              add: function (s) {
                var i, a;
                0 == e &&
                  (t = (function () {
                    if (!document) return null;
                    var e = document.createElement("style");
                    e.type = "text/css";
                    var t = n.nc;
                    return t && e.setAttribute("nonce", t), e;
                  })()) &&
                  ((i = t).styleSheet
                    ? (i.styleSheet.cssText = s)
                    : i.appendChild(document.createTextNode(s)),
                  (a = t),
                  (
                    document.head || document.getElementsByTagName("head")[0]
                  ).appendChild(a)),
                  e++;
              },
              remove: function () {
                --e ||
                  !t ||
                  (t.parentNode && t.parentNode.removeChild(t), (t = null));
              },
            };
          },
          eC = function () {
            var e = eS();
            return function (t, n) {
              em.useEffect(
                function () {
                  return (
                    e.add(t),
                    function () {
                      e.remove();
                    }
                  );
                },
                [t && n]
              );
            };
          },
          eB = function () {
            var e = eC();
            return function (t) {
              return e(t.styles, t.dynamic), null;
            };
          },
          eN = { left: 0, top: 0, right: 0, gap: 0 },
          eR = function (e) {
            return parseInt(e || "", 10) || 0;
          },
          eI = function (e) {
            var t = window.getComputedStyle(document.body),
              n = t["padding" === e ? "paddingLeft" : "marginLeft"],
              s = t["padding" === e ? "paddingTop" : "marginTop"],
              i = t["padding" === e ? "paddingRight" : "marginRight"];
            return [eR(n), eR(s), eR(i)];
          },
          eM = function (e) {
            if ((void 0 === e && (e = "margin"), typeof window > "u"))
              return eN;
            var t = eI(e),
              n = document.documentElement.clientWidth,
              s = window.innerWidth;
            return {
              left: t[0],
              top: t[1],
              right: t[2],
              gap: Math.max(0, s - n + t[2] - t[0]),
            };
          },
          eL = eB(),
          e_ = function (e, t, n, s) {
            var i = e.left,
              a = e.top,
              o = e.right,
              l = e.gap;
            return (
              void 0 === n && (n = "margin"),
              `
  .`
                .concat(
                  "with-scroll-bars-hidden",
                  ` {
   overflow: hidden `
                )
                .concat(
                  s,
                  `;
   padding-right: `
                )
                .concat(l, "px ")
                .concat(
                  s,
                  `;
  }
  body {
    overflow: hidden `
                )
                .concat(
                  s,
                  `;
    overscroll-behavior: contain;
    `
                )
                .concat(
                  [
                    t && "position: relative ".concat(s, ";"),
                    "margin" === n &&
                      `
    padding-left: `
                        .concat(
                          i,
                          `px;
    padding-top: `
                        )
                        .concat(
                          a,
                          `px;
    padding-right: `
                        )
                        .concat(
                          o,
                          `px;
    margin-left:0;
    margin-top:0;
    margin-right: `
                        )
                        .concat(l, "px ")
                        .concat(
                          s,
                          `;
    `
                        ),
                    "padding" === n &&
                      "padding-right: ".concat(l, "px ").concat(s, ";"),
                  ]
                    .filter(Boolean)
                    .join(""),
                  `
  }
  
  .`
                )
                .concat(
                  eE,
                  ` {
    right: `
                )
                .concat(l, "px ")
                .concat(
                  s,
                  `;
  }
  
  .`
                )
                .concat(
                  eP,
                  ` {
    margin-right: `
                )
                .concat(l, "px ")
                .concat(
                  s,
                  `;
  }
  
  .`
                )
                .concat(eE, " .")
                .concat(
                  eE,
                  ` {
    right: 0 `
                )
                .concat(
                  s,
                  `;
  }
  
  .`
                )
                .concat(eP, " .")
                .concat(
                  eP,
                  ` {
    margin-right: 0 `
                )
                .concat(
                  s,
                  `;
  }
  
  body {
    `
                )
                .concat("--removed-body-scroll-bar-size", ": ")
                .concat(
                  l,
                  `px;
  }
`
                )
            );
          },
          eF = function (e) {
            var t = e.noRelative,
              n = e.noImportant,
              s = e.gapMode,
              i = void 0 === s ? "margin" : s,
              a = em.useMemo(
                function () {
                  return eM(i);
                },
                [i]
              );
            return em.createElement(eL, {
              styles: e_(a, !t, i, n ? "" : "!important"),
            });
          },
          eD = !1;
        if ("u" > typeof window)
          try {
            var eU = Object.defineProperty({}, "passive", {
              get: function () {
                return (eD = !0), !0;
              },
            });
            window.addEventListener("test", eU, eU),
              window.removeEventListener("test", eU, eU);
          } catch {
            eD = !1;
          }
        var ej = !!eD && { passive: !1 },
          eH = function (e, t) {
            var n = window.getComputedStyle(e);
            return (
              "hidden" !== n[t] &&
              !(
                n.overflowY === n.overflowX &&
                "TEXTAREA" !== e.tagName &&
                "visible" === n[t]
              )
            );
          },
          e$ = function (e, t) {
            var n = t.ownerDocument,
              s = t;
            do {
              if (
                ("u" > typeof ShadowRoot &&
                  s instanceof ShadowRoot &&
                  (s = s.host),
                eG(e, s))
              ) {
                var i = eK(e, s);
                if (i[1] > i[2]) return !0;
              }
              s = s.parentNode;
            } while (s && s !== n.body);
            return !1;
          },
          eG = function (e, t) {
            return "v" === e ? eH(t, "overflowY") : eH(t, "overflowX");
          },
          eK = function (e, t) {
            return "v" === e
              ? [t.scrollTop, t.scrollHeight, t.clientHeight]
              : [t.scrollLeft, t.scrollWidth, t.clientWidth];
          },
          eV = function (e, t, n, s, i) {
            var a,
              o =
                ((a = window.getComputedStyle(t).direction),
                "h" === e && "rtl" === a ? -1 : 1),
              l = o * s,
              u = n.target,
              c = t.contains(u),
              d = !1,
              h = l > 0,
              p = 0,
              f = 0;
            do {
              var g = eK(e, u),
                m = g[0],
                y = g[1] - g[2] - o * m;
              (m || y) && eG(e, u) && ((p += y), (f += m)),
                u instanceof ShadowRoot ? (u = u.host) : (u = u.parentNode);
            } while (
              (!c && u !== document.body) ||
              (c && (t.contains(u) || t === u))
            );
            return (
              ((h && ((i && 1 > Math.abs(p)) || (!i && l > p))) ||
                (!h && ((i && 1 > Math.abs(f)) || (!i && -l > f)))) &&
                (d = !0),
              d
            );
          },
          ez = function (e) {
            return "changedTouches" in e
              ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY]
              : [0, 0];
          },
          eJ = function (e) {
            return [e.deltaX, e.deltaY];
          },
          eQ = function (e) {
            return e && "current" in e ? e.current : e;
          },
          eq = 0,
          eW = [];
        let eY =
          ((d = function (e) {
            var t = em.useRef([]),
              n = em.useRef([0, 0]),
              s = em.useRef(),
              i = em.useState(eq++)[0],
              a = em.useState(eB)[0],
              o = em.useRef(e);
            em.useEffect(
              function () {
                o.current = e;
              },
              [e]
            ),
              em.useEffect(
                function () {
                  if (e.inert) {
                    document.body.classList.add(
                      "block-interactivity-".concat(i)
                    );
                    var t = (function (e, t, n) {
                      if (n || 2 == arguments.length)
                        for (var s, i = 0, a = t.length; i < a; i++)
                          (!s && i in t) ||
                            (s || (s = Array.prototype.slice.call(t, 0, i)),
                            (s[i] = t[i]));
                      return e.concat(s || Array.prototype.slice.call(t));
                    })(
                      [e.lockRef.current],
                      (e.shards || []).map(eQ),
                      !0
                    ).filter(Boolean);
                    return (
                      t.forEach(function (e) {
                        return e.classList.add(
                          "allow-interactivity-".concat(i)
                        );
                      }),
                      function () {
                        document.body.classList.remove(
                          "block-interactivity-".concat(i)
                        ),
                          t.forEach(function (e) {
                            return e.classList.remove(
                              "allow-interactivity-".concat(i)
                            );
                          });
                      }
                    );
                  }
                },
                [e.inert, e.lockRef.current, e.shards]
              );
            var l = em.useCallback(function (e, t) {
                if ("touches" in e && 2 === e.touches.length)
                  return !o.current.allowPinchZoom;
                var i,
                  a = ez(e),
                  l = n.current,
                  u = "deltaX" in e ? e.deltaX : l[0] - a[0],
                  c = "deltaY" in e ? e.deltaY : l[1] - a[1],
                  d = e.target,
                  h = Math.abs(u) > Math.abs(c) ? "h" : "v";
                if ("touches" in e && "h" === h && "range" === d.type)
                  return !1;
                var p = e$(h, d);
                if (!p) return !0;
                if (
                  (p ? (i = h) : ((i = "v" === h ? "h" : "v"), (p = e$(h, d))),
                  !p)
                )
                  return !1;
                if (
                  (!s.current &&
                    "changedTouches" in e &&
                    (u || c) &&
                    (s.current = i),
                  !i)
                )
                  return !0;
                var f = s.current || i;
                return eV(f, t, e, "h" === f ? u : c, !0);
              }, []),
              u = em.useCallback(function (e) {
                if (!(!eW.length || eW[eW.length - 1] !== a)) {
                  var n = "deltaY" in e ? eJ(e) : ez(e),
                    s = t.current.filter(function (t) {
                      var s;
                      return (
                        t.name === e.type &&
                        (t.target === e.target ||
                          e.target === t.shadowParent) &&
                        (s = t.delta)[0] === n[0] &&
                        s[1] === n[1]
                      );
                    })[0];
                  if (s && s.should) {
                    e.cancelable && e.preventDefault();
                    return;
                  }
                  if (!s) {
                    var i = (o.current.shards || [])
                      .map(eQ)
                      .filter(Boolean)
                      .filter(function (t) {
                        return t.contains(e.target);
                      });
                    (i.length > 0 ? l(e, i[0]) : !o.current.noIsolation) &&
                      e.cancelable &&
                      e.preventDefault();
                  }
                }
              }, []),
              c = em.useCallback(function (e, n, s, i) {
                var a = {
                  name: e,
                  delta: n,
                  target: s,
                  should: i,
                  shadowParent: (function (e) {
                    for (var t = null; null !== e; )
                      e instanceof ShadowRoot && ((t = e.host), (e = e.host)),
                        (e = e.parentNode);
                    return t;
                  })(s),
                };
                t.current.push(a),
                  setTimeout(function () {
                    t.current = t.current.filter(function (e) {
                      return e !== a;
                    });
                  }, 1);
              }, []),
              d = em.useCallback(function (e) {
                (n.current = ez(e)), (s.current = void 0);
              }, []),
              h = em.useCallback(function (t) {
                c(t.type, eJ(t), t.target, l(t, e.lockRef.current));
              }, []),
              p = em.useCallback(function (t) {
                c(t.type, ez(t), t.target, l(t, e.lockRef.current));
              }, []);
            em.useEffect(function () {
              return (
                eW.push(a),
                e.setCallbacks({
                  onScrollCapture: h,
                  onWheelCapture: h,
                  onTouchMoveCapture: p,
                }),
                document.addEventListener("wheel", u, ej),
                document.addEventListener("touchmove", u, ej),
                document.addEventListener("touchstart", d, ej),
                function () {
                  (eW = eW.filter(function (e) {
                    return e !== a;
                  })),
                    document.removeEventListener("wheel", u, ej),
                    document.removeEventListener("touchmove", u, ej),
                    document.removeEventListener("touchstart", d, ej);
                }
              );
            }, []);
            var f = e.removeScrollBar,
              g = e.inert;
            return em.createElement(
              em.Fragment,
              null,
              g
                ? em.createElement(a, {
                    styles: `
  .block-interactivity-`
                      .concat(
                        i,
                        ` {pointer-events: none;}
  .allow-interactivity-`
                      )
                      .concat(
                        i,
                        ` {pointer-events: all;}
`
                      ),
                  })
                : null,
              f ? em.createElement(eF, { gapMode: e.gapMode }) : null
            );
          }),
          eT.useMedium(d),
          ek);
        em.forwardRef(function (e, t) {
          return em.createElement(eO, ew({}, e, { ref: t, sideCar: eY }));
        }).classNames = eO.classNames;
        var eZ = {},
          eX = {},
          e0 = {};
        let e1 = [
          0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581,
          655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706,
          1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196,
          3362, 3532, 3706,
        ];
        (e0.getSymbolSize = function (e) {
          if (!e) throw Error('"version" cannot be null or undefined');
          if (e < 1 || e > 40)
            throw Error('"version" should be in range from 1 to 40');
          return 4 * e + 17;
        }),
          (e0.getSymbolTotalCodewords = function (e) {
            return e1[e];
          }),
          (e0.getBCHDigit = function (e) {
            let t = 0;
            for (; 0 !== e; ) t++, (e >>>= 1);
            return t;
          }),
          (e0.setToSJISFunction = function (e) {
            if ("function" != typeof e)
              throw Error('"toSJISFunc" is not a valid function.');
            s = e;
          }),
          (e0.isKanjiModeEnabled = function () {
            return "u" > typeof s;
          }),
          (e0.toSJIS = function (e) {
            return s(e);
          });
        var e2 = {};
        function e3() {
          (this.buffer = []), (this.length = 0);
        }
        function e4(e) {
          if (!e || e < 1)
            throw Error("BitMatrix size must be defined and greater than 0");
          (this.size = e),
            (this.data = new Uint8Array(e * e)),
            (this.reservedBit = new Uint8Array(e * e));
        }
        (e2.L = { bit: 1 }),
          (e2.M = { bit: 0 }),
          (e2.Q = { bit: 3 }),
          (e2.H = { bit: 2 }),
          (e2.isValid = function (e) {
            return e && "u" > typeof e.bit && e.bit >= 0 && e.bit < 4;
          }),
          (e2.from = function (e, t) {
            if (e2.isValid(e)) return e;
            try {
              return (function (e) {
                if ("string" != typeof e) throw Error("Param is not a string");
                switch (e.toLowerCase()) {
                  case "l":
                  case "low":
                    return e2.L;
                  case "m":
                  case "medium":
                    return e2.M;
                  case "q":
                  case "quartile":
                    return e2.Q;
                  case "h":
                  case "high":
                    return e2.H;
                  default:
                    throw Error("Unknown EC Level: " + e);
                }
              })(e);
            } catch {
              return t;
            }
          }),
          (e3.prototype = {
            get: function (e) {
              return (
                ((this.buffer[Math.floor(e / 8)] >>> (7 - (e % 8))) & 1) == 1
              );
            },
            put: function (e, t) {
              for (let n = 0; n < t; n++)
                this.putBit(((e >>> (t - n - 1)) & 1) == 1);
            },
            getLengthInBits: function () {
              return this.length;
            },
            putBit: function (e) {
              let t = Math.floor(this.length / 8);
              this.buffer.length <= t && this.buffer.push(0),
                e && (this.buffer[t] |= 128 >>> this.length % 8),
                this.length++;
            },
          }),
          (e4.prototype.set = function (e, t, n, s) {
            let i = e * this.size + t;
            (this.data[i] = n), s && (this.reservedBit[i] = !0);
          }),
          (e4.prototype.get = function (e, t) {
            return this.data[e * this.size + t];
          }),
          (e4.prototype.xor = function (e, t, n) {
            this.data[e * this.size + t] ^= n;
          }),
          (e4.prototype.isReserved = function (e, t) {
            return this.reservedBit[e * this.size + t];
          });
        var e6 = {};
        !(function (e) {
          let t = e0.getSymbolSize;
          (e.getRowColCoords = function (e) {
            if (1 === e) return [];
            let n = Math.floor(e / 7) + 2,
              s = t(e),
              i = 145 === s ? 26 : 2 * Math.ceil((s - 13) / (2 * n - 2)),
              a = [s - 7];
            for (let e = 1; e < n - 1; e++) a[e] = a[e - 1] - i;
            return a.push(6), a.reverse();
          }),
            (e.getPositions = function (t) {
              let n = [],
                s = e.getRowColCoords(t),
                i = s.length;
              for (let e = 0; e < i; e++)
                for (let t = 0; t < i; t++)
                  (0 === e && 0 === t) ||
                    (0 === e && t === i - 1) ||
                    (e === i - 1 && 0 === t) ||
                    n.push([s[e], s[t]]);
              return n;
            });
        })(e6);
        var e5 = {};
        let e8 = e0.getSymbolSize;
        e5.getPositions = function (e) {
          let t = e8(e);
          return [
            [0, 0],
            [t - 7, 0],
            [0, t - 7],
          ];
        };
        var e7 = {};
        !(function (e) {
          e.Patterns = {
            PATTERN000: 0,
            PATTERN001: 1,
            PATTERN010: 2,
            PATTERN011: 3,
            PATTERN100: 4,
            PATTERN101: 5,
            PATTERN110: 6,
            PATTERN111: 7,
          };
          let t = { N1: 3, N2: 3, N3: 40, N4: 10 };
          (e.isValid = function (e) {
            return null != e && "" !== e && !isNaN(e) && e >= 0 && e <= 7;
          }),
            (e.from = function (t) {
              return e.isValid(t) ? parseInt(t, 10) : void 0;
            }),
            (e.getPenaltyN1 = function (e) {
              let n = e.size,
                s = 0,
                i = 0,
                a = 0,
                o = null,
                l = null;
              for (let u = 0; u < n; u++) {
                (i = a = 0), (o = l = null);
                for (let c = 0; c < n; c++) {
                  let n = e.get(u, c);
                  n === o
                    ? i++
                    : (i >= 5 && (s += t.N1 + (i - 5)), (o = n), (i = 1)),
                    (n = e.get(c, u)) === l
                      ? a++
                      : (a >= 5 && (s += t.N1 + (a - 5)), (l = n), (a = 1));
                }
                i >= 5 && (s += t.N1 + (i - 5)),
                  a >= 5 && (s += t.N1 + (a - 5));
              }
              return s;
            }),
            (e.getPenaltyN2 = function (e) {
              let n = e.size,
                s = 0;
              for (let t = 0; t < n - 1; t++)
                for (let i = 0; i < n - 1; i++) {
                  let n =
                    e.get(t, i) +
                    e.get(t, i + 1) +
                    e.get(t + 1, i) +
                    e.get(t + 1, i + 1);
                  (4 === n || 0 === n) && s++;
                }
              return s * t.N2;
            }),
            (e.getPenaltyN3 = function (e) {
              let n = e.size,
                s = 0,
                i = 0,
                a = 0;
              for (let t = 0; t < n; t++) {
                i = a = 0;
                for (let o = 0; o < n; o++)
                  (i = ((i << 1) & 2047) | e.get(t, o)),
                    o >= 10 && (1488 === i || 93 === i) && s++,
                    (a = ((a << 1) & 2047) | e.get(o, t)),
                    o >= 10 && (1488 === a || 93 === a) && s++;
              }
              return s * t.N3;
            }),
            (e.getPenaltyN4 = function (e) {
              let n = 0,
                s = e.data.length;
              for (let t = 0; t < s; t++) n += e.data[t];
              return Math.abs(Math.ceil((100 * n) / s / 5) - 10) * t.N4;
            }),
            (e.applyMask = function (t, n) {
              let s = n.size;
              for (let i = 0; i < s; i++)
                for (let a = 0; a < s; a++)
                  n.isReserved(a, i) ||
                    n.xor(
                      a,
                      i,
                      (function (t, n, s) {
                        switch (t) {
                          case e.Patterns.PATTERN000:
                            return (n + s) % 2 == 0;
                          case e.Patterns.PATTERN001:
                            return n % 2 == 0;
                          case e.Patterns.PATTERN010:
                            return s % 3 == 0;
                          case e.Patterns.PATTERN011:
                            return (n + s) % 3 == 0;
                          case e.Patterns.PATTERN100:
                            return (
                              (Math.floor(n / 2) + Math.floor(s / 3)) % 2 == 0
                            );
                          case e.Patterns.PATTERN101:
                            return ((n * s) % 2) + ((n * s) % 3) == 0;
                          case e.Patterns.PATTERN110:
                            return (((n * s) % 2) + ((n * s) % 3)) % 2 == 0;
                          case e.Patterns.PATTERN111:
                            return (((n * s) % 3) + ((n + s) % 2)) % 2 == 0;
                          default:
                            throw Error("bad maskPattern:" + t);
                        }
                      })(t, a, i)
                    );
            }),
            (e.getBestMask = function (t, n) {
              let s = Object.keys(e.Patterns).length,
                i = 0,
                a = 1 / 0;
              for (let o = 0; o < s; o++) {
                n(o), e.applyMask(o, t);
                let s =
                  e.getPenaltyN1(t) +
                  e.getPenaltyN2(t) +
                  e.getPenaltyN3(t) +
                  e.getPenaltyN4(t);
                e.applyMask(o, t), s < a && ((a = s), (i = o));
              }
              return i;
            });
        })(e7);
        var e9 = {};
        let te = [
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4,
            4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4,
            8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16,
            6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17,
            23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29,
            35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45,
            15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19,
            37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45,
            62, 74, 24, 47, 65, 77, 25, 49, 68, 81,
          ],
          tt = [
            7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26,
            48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60,
            110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260,
            308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432,
            144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196,
            364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476,
            690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870,
            1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050,
            1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290,
            1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530,
            1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770,
            2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040,
            2430,
          ];
        (e9.getBlocksCount = function (e, t) {
          switch (t) {
            case e2.L:
              return te[(e - 1) * 4 + 0];
            case e2.M:
              return te[(e - 1) * 4 + 1];
            case e2.Q:
              return te[(e - 1) * 4 + 2];
            case e2.H:
              return te[(e - 1) * 4 + 3];
            default:
              return;
          }
        }),
          (e9.getTotalCodewordsCount = function (e, t) {
            switch (t) {
              case e2.L:
                return tt[(e - 1) * 4 + 0];
              case e2.M:
                return tt[(e - 1) * 4 + 1];
              case e2.Q:
                return tt[(e - 1) * 4 + 2];
              case e2.H:
                return tt[(e - 1) * 4 + 3];
              default:
                return;
            }
          });
        var tr = {},
          tn = {};
        let ts = new Uint8Array(512),
          ti = new Uint8Array(256);
        function ta(e) {
          (this.genPoly = void 0),
            (this.degree = e),
            this.degree && this.initialize(this.degree);
        }
        (function () {
          let e = 1;
          for (let t = 0; t < 255; t++)
            (ts[t] = e), (ti[e] = t), 256 & (e <<= 1) && (e ^= 285);
          for (let e = 255; e < 512; e++) ts[e] = ts[e - 255];
        })(),
          (tn.log = function (e) {
            if (e < 1) throw Error("log(" + e + ")");
            return ti[e];
          }),
          (tn.exp = function (e) {
            return ts[e];
          }),
          (tn.mul = function (e, t) {
            return 0 === e || 0 === t ? 0 : ts[ti[e] + ti[t]];
          }),
          (tr.mul = function (e, t) {
            let n = new Uint8Array(e.length + t.length - 1);
            for (let s = 0; s < e.length; s++)
              for (let i = 0; i < t.length; i++) n[s + i] ^= tn.mul(e[s], t[i]);
            return n;
          }),
          (tr.mod = function (e, t) {
            let n = new Uint8Array(e);
            for (; n.length - t.length >= 0; ) {
              let e = n[0];
              for (let s = 0; s < t.length; s++) n[s] ^= tn.mul(t[s], e);
              let s = 0;
              for (; s < n.length && 0 === n[s]; ) s++;
              n = n.slice(s);
            }
            return n;
          }),
          (tr.generateECPolynomial = function (e) {
            let t = new Uint8Array([1]);
            for (let n = 0; n < e; n++)
              t = tr.mul(t, new Uint8Array([1, tn.exp(n)]));
            return t;
          }),
          (ta.prototype.initialize = function (e) {
            (this.degree = e),
              (this.genPoly = tr.generateECPolynomial(this.degree));
          }),
          (ta.prototype.encode = function (e) {
            if (!this.genPoly) throw Error("Encoder not initialized");
            let t = new Uint8Array(e.length + this.degree);
            t.set(e);
            let n = tr.mod(t, this.genPoly),
              s = this.degree - n.length;
            if (s > 0) {
              let e = new Uint8Array(this.degree);
              return e.set(n, s), e;
            }
            return n;
          });
        var to = {},
          tl = {},
          tu = {};
        tu.isValid = function (e) {
          return !isNaN(e) && e >= 1 && e <= 40;
        };
        var tc = {};
        let td = "[0-9]+",
          th =
            "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+",
          tp =
            "(?:(?![A-Z0-9 $%*+\\-./:]|" +
            (th = th.replace(/u/g, "\\u")) +
            `)(?:.|[\r
]))+`;
        (tc.KANJI = RegExp(th, "g")),
          (tc.BYTE_KANJI = RegExp("[^A-Z0-9 $%*+\\-./:]+", "g")),
          (tc.BYTE = RegExp(tp, "g")),
          (tc.NUMERIC = RegExp(td, "g")),
          (tc.ALPHANUMERIC = RegExp("[A-Z $%*+\\-./:]+", "g"));
        let tf = RegExp("^" + th + "$"),
          tg = RegExp("^" + td + "$"),
          tm = RegExp("^[A-Z0-9 $%*+\\-./:]+$");
        (tc.testKanji = function (e) {
          return tf.test(e);
        }),
          (tc.testNumeric = function (e) {
            return tg.test(e);
          }),
          (tc.testAlphanumeric = function (e) {
            return tm.test(e);
          }),
          (tl.NUMERIC = { id: "Numeric", bit: 1, ccBits: [10, 12, 14] }),
          (tl.ALPHANUMERIC = {
            id: "Alphanumeric",
            bit: 2,
            ccBits: [9, 11, 13],
          }),
          (tl.BYTE = { id: "Byte", bit: 4, ccBits: [8, 16, 16] }),
          (tl.KANJI = { id: "Kanji", bit: 8, ccBits: [8, 10, 12] }),
          (tl.MIXED = { bit: -1 }),
          (tl.getCharCountIndicator = function (e, t) {
            if (!e.ccBits) throw Error("Invalid mode: " + e);
            if (!tu.isValid(t)) throw Error("Invalid version: " + t);
            return t >= 1 && t < 10
              ? e.ccBits[0]
              : t < 27
              ? e.ccBits[1]
              : e.ccBits[2];
          }),
          (tl.getBestModeForData = function (e) {
            return tc.testNumeric(e)
              ? tl.NUMERIC
              : tc.testAlphanumeric(e)
              ? tl.ALPHANUMERIC
              : tc.testKanji(e)
              ? tl.KANJI
              : tl.BYTE;
          }),
          (tl.toString = function (e) {
            if (e && e.id) return e.id;
            throw Error("Invalid mode");
          }),
          (tl.isValid = function (e) {
            return e && e.bit && e.ccBits;
          }),
          (tl.from = function (e, t) {
            if (tl.isValid(e)) return e;
            try {
              return (function (e) {
                if ("string" != typeof e) throw Error("Param is not a string");
                switch (e.toLowerCase()) {
                  case "numeric":
                    return tl.NUMERIC;
                  case "alphanumeric":
                    return tl.ALPHANUMERIC;
                  case "kanji":
                    return tl.KANJI;
                  case "byte":
                    return tl.BYTE;
                  default:
                    throw Error("Unknown mode: " + e);
                }
              })(e);
            } catch {
              return t;
            }
          }),
          (function (e) {
            let t = e0.getBCHDigit(7973);
            function n(e, t) {
              return tl.getCharCountIndicator(e, t) + 4;
            }
            (e.from = function (e, t) {
              return tu.isValid(e) ? parseInt(e, 10) : t;
            }),
              (e.getCapacity = function (e, t, s) {
                if (!tu.isValid(e)) throw Error("Invalid QR Code version");
                typeof s > "u" && (s = tl.BYTE);
                let i =
                  (e0.getSymbolTotalCodewords(e) -
                    e9.getTotalCodewordsCount(e, t)) *
                  8;
                if (s === tl.MIXED) return i;
                let a = i - n(s, e);
                switch (s) {
                  case tl.NUMERIC:
                    return Math.floor((a / 10) * 3);
                  case tl.ALPHANUMERIC:
                    return Math.floor((a / 11) * 2);
                  case tl.KANJI:
                    return Math.floor(a / 13);
                  case tl.BYTE:
                  default:
                    return Math.floor(a / 8);
                }
              }),
              (e.getBestVersionForData = function (t, s) {
                let i;
                let a = e2.from(s, e2.M);
                if (Array.isArray(t)) {
                  if (t.length > 1)
                    return (function (t, s) {
                      for (let i = 1; i <= 40; i++)
                        if (
                          (function (e, t) {
                            let s = 0;
                            return (
                              e.forEach(function (e) {
                                let i = n(e.mode, t);
                                s += i + e.getBitsLength();
                              }),
                              s
                            );
                          })(t, i) <= e.getCapacity(i, s, tl.MIXED)
                        )
                          return i;
                    })(t, a);
                  if (0 === t.length) return 1;
                  i = t[0];
                } else i = t;
                return (function (t, n, s) {
                  for (let i = 1; i <= 40; i++)
                    if (n <= e.getCapacity(i, s, t)) return i;
                })(i.mode, i.getLength(), a);
              }),
              (e.getEncodedBits = function (e) {
                if (!tu.isValid(e) || e < 7)
                  throw Error("Invalid QR Code version");
                let n = e << 12;
                for (; e0.getBCHDigit(n) - t >= 0; )
                  n ^= 7973 << (e0.getBCHDigit(n) - t);
                return (e << 12) | n;
              });
          })(to);
        var ty = {};
        let tb = e0.getBCHDigit(1335);
        ty.getEncodedBits = function (e, t) {
          let n = (e.bit << 3) | t,
            s = n << 10;
          for (; e0.getBCHDigit(s) - tb >= 0; )
            s ^= 1335 << (e0.getBCHDigit(s) - tb);
          return ((n << 10) | s) ^ 21522;
        };
        var tA = {};
        function tw(e) {
          (this.mode = tl.NUMERIC), (this.data = e.toString());
        }
        (tw.getBitsLength = function (e) {
          return 10 * Math.floor(e / 3) + (e % 3 ? (e % 3) * 3 + 1 : 0);
        }),
          (tw.prototype.getLength = function () {
            return this.data.length;
          }),
          (tw.prototype.getBitsLength = function () {
            return tw.getBitsLength(this.data.length);
          }),
          (tw.prototype.write = function (e) {
            let t, n;
            for (t = 0; t + 3 <= this.data.length; t += 3)
              (n = parseInt(this.data.substr(t, 3), 10)), e.put(n, 10);
            let s = this.data.length - t;
            s > 0 &&
              ((n = parseInt(this.data.substr(t), 10)), e.put(n, 3 * s + 1));
          });
        let tv = [
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z",
          " ",
          "$",
          "%",
          "*",
          "+",
          "-",
          ".",
          "/",
          ":",
        ];
        function tE(e) {
          (this.mode = tl.ALPHANUMERIC), (this.data = e);
        }
        (tE.getBitsLength = function (e) {
          return 11 * Math.floor(e / 2) + (e % 2) * 6;
        }),
          (tE.prototype.getLength = function () {
            return this.data.length;
          }),
          (tE.prototype.getBitsLength = function () {
            return tE.getBitsLength(this.data.length);
          }),
          (tE.prototype.write = function (e) {
            let t;
            for (t = 0; t + 2 <= this.data.length; t += 2) {
              let n = 45 * tv.indexOf(this.data[t]);
              (n += tv.indexOf(this.data[t + 1])), e.put(n, 11);
            }
            this.data.length % 2 && e.put(tv.indexOf(this.data[t]), 6);
          });
        let tP = function (e) {
          for (var t = [], n = e.length, s = 0; s < n; s++) {
            var i = e.charCodeAt(s);
            if (i >= 55296 && i <= 56319 && n > s + 1) {
              var a = e.charCodeAt(s + 1);
              a >= 56320 &&
                a <= 57343 &&
                ((i = (i - 55296) * 1024 + a - 56320 + 65536), (s += 1));
            }
            if (i < 128) {
              t.push(i);
              continue;
            }
            if (i < 2048) {
              t.push((i >> 6) | 192), t.push((63 & i) | 128);
              continue;
            }
            if (i < 55296 || (i >= 57344 && i < 65536)) {
              t.push((i >> 12) | 224),
                t.push(((i >> 6) & 63) | 128),
                t.push((63 & i) | 128);
              continue;
            }
            if (i >= 65536 && i <= 1114111) {
              t.push((i >> 18) | 240),
                t.push(((i >> 12) & 63) | 128),
                t.push(((i >> 6) & 63) | 128),
                t.push((63 & i) | 128);
              continue;
            }
            t.push(239, 191, 189);
          }
          return new Uint8Array(t).buffer;
        };
        function tk(e) {
          (this.mode = tl.BYTE),
            "string" == typeof e && (e = tP(e)),
            (this.data = new Uint8Array(e));
        }
        function tT(e) {
          (this.mode = tl.KANJI), (this.data = e);
        }
        (tk.getBitsLength = function (e) {
          return 8 * e;
        }),
          (tk.prototype.getLength = function () {
            return this.data.length;
          }),
          (tk.prototype.getBitsLength = function () {
            return tk.getBitsLength(this.data.length);
          }),
          (tk.prototype.write = function (e) {
            for (let t = 0, n = this.data.length; t < n; t++)
              e.put(this.data[t], 8);
          }),
          (tT.getBitsLength = function (e) {
            return 13 * e;
          }),
          (tT.prototype.getLength = function () {
            return this.data.length;
          }),
          (tT.prototype.getBitsLength = function () {
            return tT.getBitsLength(this.data.length);
          }),
          (tT.prototype.write = function (e) {
            let t;
            for (t = 0; t < this.data.length; t++) {
              let n = e0.toSJIS(this.data[t]);
              if (n >= 33088 && n <= 40956) n -= 33088;
              else if (n >= 57408 && n <= 60351) n -= 49472;
              else
                throw Error(
                  "Invalid SJIS character: " +
                    this.data[t] +
                    `
Make sure your charset is UTF-8`
                );
              (n = ((n >>> 8) & 255) * 192 + (255 & n)), e.put(n, 13);
            }
          });
        var tx = { exports: {} };
        (h = {
          single_source_shortest_paths: function (e, t, n) {
            var s,
              i,
              a,
              o,
              l,
              u,
              c,
              d = {},
              p = {};
            p[t] = 0;
            var f = h.PriorityQueue.make();
            for (f.push(t, 0); !f.empty(); )
              for (a in ((i = (s = f.pop()).value),
              (o = s.cost),
              (l = e[i] || {})))
                l.hasOwnProperty(a) &&
                  ((u = o + l[a]),
                  (c = p[a]),
                  (typeof p[a] > "u" || c > u) &&
                    ((p[a] = u), f.push(a, u), (d[a] = i)));
            if ("u" > typeof n && typeof p[n] > "u")
              throw Error(
                ["Could not find a path from ", t, " to ", n, "."].join("")
              );
            return d;
          },
          extract_shortest_path_from_predecessor_list: function (e, t) {
            for (var n = [], s = t; s; ) n.push(s), e[s], (s = e[s]);
            return n.reverse(), n;
          },
          find_path: function (e, t, n) {
            var s = h.single_source_shortest_paths(e, t, n);
            return h.extract_shortest_path_from_predecessor_list(s, n);
          },
          PriorityQueue: {
            make: function (e) {
              var t,
                n = h.PriorityQueue,
                s = {};
              for (t in ((e = e || {}), n))
                n.hasOwnProperty(t) && (s[t] = n[t]);
              return (
                (s.queue = []), (s.sorter = e.sorter || n.default_sorter), s
              );
            },
            default_sorter: function (e, t) {
              return e.cost - t.cost;
            },
            push: function (e, t) {
              this.queue.push({ value: e, cost: t }),
                this.queue.sort(this.sorter);
            },
            pop: function () {
              return this.queue.shift();
            },
            empty: function () {
              return 0 === this.queue.length;
            },
          },
        }),
          (tx.exports = h);
        var tO = tx.exports;
        function tS(e, t, n) {
          let s, i;
          let a = e.size,
            o = ty.getEncodedBits(t, n);
          for (s = 0; s < 15; s++)
            (i = ((o >> s) & 1) == 1),
              s < 6
                ? e.set(s, 8, i, !0)
                : s < 8
                ? e.set(s + 1, 8, i, !0)
                : e.set(a - 15 + s, 8, i, !0),
              s < 8
                ? e.set(8, a - s - 1, i, !0)
                : s < 9
                ? e.set(8, 15 - s - 1 + 1, i, !0)
                : e.set(8, 15 - s - 1, i, !0);
          e.set(a - 8, 8, 1, !0);
        }
        (function (e) {
          function t(e) {
            return unescape(encodeURIComponent(e)).length;
          }
          function n(e, t, n) {
            let s;
            let i = [];
            for (; null !== (s = e.exec(n)); )
              i.push({
                data: s[0],
                index: s.index,
                mode: t,
                length: s[0].length,
              });
            return i;
          }
          function s(e) {
            let t, s;
            let i = n(tc.NUMERIC, tl.NUMERIC, e),
              a = n(tc.ALPHANUMERIC, tl.ALPHANUMERIC, e);
            return (
              e0.isKanjiModeEnabled()
                ? ((t = n(tc.BYTE, tl.BYTE, e)), (s = n(tc.KANJI, tl.KANJI, e)))
                : ((t = n(tc.BYTE_KANJI, tl.BYTE, e)), (s = [])),
              i
                .concat(a, t, s)
                .sort(function (e, t) {
                  return e.index - t.index;
                })
                .map(function (e) {
                  return { data: e.data, mode: e.mode, length: e.length };
                })
            );
          }
          function i(e, t) {
            switch (t) {
              case tl.NUMERIC:
                return tw.getBitsLength(e);
              case tl.ALPHANUMERIC:
                return tE.getBitsLength(e);
              case tl.KANJI:
                return tT.getBitsLength(e);
              case tl.BYTE:
                return tk.getBitsLength(e);
            }
          }
          function a(e, t) {
            let n;
            let s = tl.getBestModeForData(e);
            if ((n = tl.from(t, s)) !== tl.BYTE && n.bit < s.bit)
              throw Error(
                '"' +
                  e +
                  '" cannot be encoded with mode ' +
                  tl.toString(n) +
                  `.
 Suggested mode is: ` +
                  tl.toString(s)
              );
            switch (
              (n !== tl.KANJI || e0.isKanjiModeEnabled() || (n = tl.BYTE), n)
            ) {
              case tl.NUMERIC:
                return new tw(e);
              case tl.ALPHANUMERIC:
                return new tE(e);
              case tl.KANJI:
                return new tT(e);
              case tl.BYTE:
                return new tk(e);
            }
          }
          (e.fromArray = function (e) {
            return e.reduce(function (e, t) {
              return (
                "string" == typeof t
                  ? e.push(a(t, null))
                  : t.data && e.push(a(t.data, t.mode)),
                e
              );
            }, []);
          }),
            (e.fromString = function (n, a) {
              let o = (function (e, t) {
                  let n = {},
                    s = { start: {} },
                    a = ["start"];
                  for (let o = 0; o < e.length; o++) {
                    let l = e[o],
                      u = [];
                    for (let e = 0; e < l.length; e++) {
                      let c = l[e],
                        d = "" + o + e;
                      u.push(d),
                        (n[d] = { node: c, lastCount: 0 }),
                        (s[d] = {});
                      for (let e = 0; e < a.length; e++) {
                        let o = a[e];
                        n[o] && n[o].node.mode === c.mode
                          ? ((s[o][d] =
                              i(n[o].lastCount + c.length, c.mode) -
                              i(n[o].lastCount, c.mode)),
                            (n[o].lastCount += c.length))
                          : (n[o] && (n[o].lastCount = c.length),
                            (s[o][d] =
                              i(c.length, c.mode) +
                              4 +
                              tl.getCharCountIndicator(c.mode, t)));
                      }
                    }
                    a = u;
                  }
                  for (let e = 0; e < a.length; e++) s[a[e]].end = 0;
                  return { map: s, table: n };
                })(
                  (function (e) {
                    let n = [];
                    for (let s = 0; s < e.length; s++) {
                      let i = e[s];
                      switch (i.mode) {
                        case tl.NUMERIC:
                          n.push([
                            i,
                            {
                              data: i.data,
                              mode: tl.ALPHANUMERIC,
                              length: i.length,
                            },
                            { data: i.data, mode: tl.BYTE, length: i.length },
                          ]);
                          break;
                        case tl.ALPHANUMERIC:
                          n.push([
                            i,
                            { data: i.data, mode: tl.BYTE, length: i.length },
                          ]);
                          break;
                        case tl.KANJI:
                          n.push([
                            i,
                            { data: i.data, mode: tl.BYTE, length: t(i.data) },
                          ]);
                          break;
                        case tl.BYTE:
                          n.push([
                            { data: i.data, mode: tl.BYTE, length: t(i.data) },
                          ]);
                      }
                    }
                    return n;
                  })(s(n, e0.isKanjiModeEnabled())),
                  a
                ),
                l = tO.find_path(o.map, "start", "end"),
                u = [];
              for (let e = 1; e < l.length - 1; e++) u.push(o.table[l[e]].node);
              return e.fromArray(
                u.reduce(function (e, t) {
                  let n = e.length - 1 >= 0 ? e[e.length - 1] : null;
                  return (
                    n && n.mode === t.mode
                      ? (e[e.length - 1].data += t.data)
                      : e.push(t),
                    e
                  );
                }, [])
              );
            }),
            (e.rawSplit = function (t) {
              return e.fromArray(s(t, e0.isKanjiModeEnabled()));
            });
        })(tA),
          (eX.create = function (e, t) {
            if (typeof e > "u" || "" === e) throw Error("No input text");
            let n = e2.M,
              s,
              i;
            return (
              "u" > typeof t &&
                ((n = e2.from(t.errorCorrectionLevel, e2.M)),
                (s = to.from(t.version)),
                (i = e7.from(t.maskPattern)),
                t.toSJISFunc && e0.setToSJISFunction(t.toSJISFunc)),
              (function (e, t, n, s) {
                let i;
                if (Array.isArray(e)) i = tA.fromArray(e);
                else if ("string" == typeof e) {
                  let s = t;
                  if (!s) {
                    let t = tA.rawSplit(e);
                    s = to.getBestVersionForData(t, n);
                  }
                  i = tA.fromString(e, s || 40);
                } else throw Error("Invalid data");
                let a = to.getBestVersionForData(i, n);
                if (!a)
                  throw Error(
                    "The amount of data is too big to be stored in a QR Code"
                  );
                if (t) {
                  if (t < a)
                    throw Error(
                      `
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` +
                        a +
                        `.
`
                    );
                } else t = a;
                let o = (function (e, t, n) {
                    let s = new e3();
                    n.forEach(function (t) {
                      s.put(t.mode.bit, 4),
                        s.put(
                          t.getLength(),
                          tl.getCharCountIndicator(t.mode, e)
                        ),
                        t.write(s);
                    });
                    let i =
                      (e0.getSymbolTotalCodewords(e) -
                        e9.getTotalCodewordsCount(e, t)) *
                      8;
                    for (
                      s.getLengthInBits() + 4 <= i && s.put(0, 4);
                      s.getLengthInBits() % 8 != 0;

                    )
                      s.putBit(0);
                    let a = (i - s.getLengthInBits()) / 8;
                    for (let e = 0; e < a; e++) s.put(e % 2 ? 17 : 236, 8);
                    return (function (e, t, n) {
                      let s = e0.getSymbolTotalCodewords(t),
                        i = s - e9.getTotalCodewordsCount(t, n),
                        a = e9.getBlocksCount(t, n),
                        o = s % a,
                        l = a - o,
                        u = Math.floor(s / a),
                        c = Math.floor(i / a),
                        d = c + 1,
                        h = u - c,
                        p = new ta(h),
                        f = 0,
                        g = Array(a),
                        m = Array(a),
                        y = 0,
                        b = new Uint8Array(e.buffer);
                      for (let e = 0; e < a; e++) {
                        let t = e < l ? c : d;
                        (g[e] = b.slice(f, f + t)),
                          (m[e] = p.encode(g[e])),
                          (f += t),
                          (y = Math.max(y, t));
                      }
                      let A = new Uint8Array(s),
                        w = 0,
                        v,
                        E;
                      for (v = 0; v < y; v++)
                        for (E = 0; E < a; E++)
                          v < g[E].length && (A[w++] = g[E][v]);
                      for (v = 0; v < h; v++)
                        for (E = 0; E < a; E++) A[w++] = m[E][v];
                      return A;
                    })(s, e, t);
                  })(t, n, i),
                  l = new e4(e0.getSymbolSize(t));
                return (
                  (function (e, t) {
                    let n = e.size,
                      s = e5.getPositions(t);
                    for (let t = 0; t < s.length; t++) {
                      let i = s[t][0],
                        a = s[t][1];
                      for (let t = -1; t <= 7; t++)
                        if (!(i + t <= -1 || n <= i + t))
                          for (let s = -1; s <= 7; s++)
                            a + s <= -1 ||
                              n <= a + s ||
                              ((t >= 0 && t <= 6 && (0 === s || 6 === s)) ||
                              (s >= 0 && s <= 6 && (0 === t || 6 === t)) ||
                              (t >= 2 && t <= 4 && s >= 2 && s <= 4)
                                ? e.set(i + t, a + s, !0, !0)
                                : e.set(i + t, a + s, !1, !0));
                    }
                  })(l, t),
                  (function (e) {
                    let t = e.size;
                    for (let n = 8; n < t - 8; n++) {
                      let t = n % 2 == 0;
                      e.set(n, 6, t, !0), e.set(6, n, t, !0);
                    }
                  })(l),
                  (function (e, t) {
                    let n = e6.getPositions(t);
                    for (let t = 0; t < n.length; t++) {
                      let s = n[t][0],
                        i = n[t][1];
                      for (let t = -2; t <= 2; t++)
                        for (let n = -2; n <= 2; n++)
                          -2 === t ||
                          2 === t ||
                          -2 === n ||
                          2 === n ||
                          (0 === t && 0 === n)
                            ? e.set(s + t, i + n, !0, !0)
                            : e.set(s + t, i + n, !1, !0);
                    }
                  })(l, t),
                  tS(l, n, 0),
                  t >= 7 &&
                    (function (e, t) {
                      let n, s, i;
                      let a = e.size,
                        o = to.getEncodedBits(t);
                      for (let t = 0; t < 18; t++)
                        (n = Math.floor(t / 3)),
                          (s = (t % 3) + a - 8 - 3),
                          (i = ((o >> t) & 1) == 1),
                          e.set(n, s, i, !0),
                          e.set(s, n, i, !0);
                    })(l, t),
                  (function (e, t) {
                    let n = e.size,
                      s = -1,
                      i = n - 1,
                      a = 7,
                      o = 0;
                    for (let l = n - 1; l > 0; l -= 2)
                      for (6 === l && l--; ; ) {
                        for (let n = 0; n < 2; n++)
                          if (!e.isReserved(i, l - n)) {
                            let s = !1;
                            o < t.length && (s = ((t[o] >>> a) & 1) == 1),
                              e.set(i, l - n, s),
                              -1 == --a && (o++, (a = 7));
                          }
                        if ((i += s) < 0 || n <= i) {
                          (i -= s), (s = -s);
                          break;
                        }
                      }
                  })(l, o),
                  isNaN(s) && (s = e7.getBestMask(l, tS.bind(null, l, n))),
                  e7.applyMask(s, l),
                  tS(l, n, s),
                  {
                    modules: l,
                    version: t,
                    errorCorrectionLevel: n,
                    maskPattern: s,
                    segments: i,
                  }
                );
              })(e, s, n, i)
            );
          });
        var tC = {},
          tB = {};
        (function (e) {
          function t(e) {
            if (
              ("number" == typeof e && (e = e.toString()), "string" != typeof e)
            )
              throw Error("Color should be defined as hex string");
            let t = e.slice().replace("#", "").split("");
            if (t.length < 3 || 5 === t.length || t.length > 8)
              throw Error("Invalid hex color: " + e);
            (3 === t.length || 4 === t.length) &&
              (t = Array.prototype.concat.apply(
                [],
                t.map(function (e) {
                  return [e, e];
                })
              )),
              6 === t.length && t.push("F", "F");
            let n = parseInt(t.join(""), 16);
            return {
              r: (n >> 24) & 255,
              g: (n >> 16) & 255,
              b: (n >> 8) & 255,
              a: 255 & n,
              hex: "#" + t.slice(0, 6).join(""),
            };
          }
          (e.getOptions = function (e) {
            e || (e = {}), e.color || (e.color = {});
            let n =
                typeof e.margin > "u" || null === e.margin || e.margin < 0
                  ? 4
                  : e.margin,
              s = e.width && e.width >= 21 ? e.width : void 0,
              i = e.scale || 4;
            return {
              width: s,
              scale: s ? 4 : i,
              margin: n,
              color: {
                dark: t(e.color.dark || "#000000ff"),
                light: t(e.color.light || "#ffffffff"),
              },
              type: e.type,
              rendererOpts: e.rendererOpts || {},
            };
          }),
            (e.getScale = function (e, t) {
              return t.width && t.width >= e + 2 * t.margin
                ? t.width / (e + 2 * t.margin)
                : t.scale;
            }),
            (e.getImageWidth = function (t, n) {
              let s = e.getScale(t, n);
              return Math.floor((t + 2 * n.margin) * s);
            }),
            (e.qrToImageData = function (t, n, s) {
              let i = n.modules.size,
                a = n.modules.data,
                o = e.getScale(i, s),
                l = Math.floor((i + 2 * s.margin) * o),
                u = s.margin * o,
                c = [s.color.light, s.color.dark];
              for (let e = 0; e < l; e++)
                for (let n = 0; n < l; n++) {
                  let d = (e * l + n) * 4,
                    h = s.color.light;
                  e >= u &&
                    n >= u &&
                    e < l - u &&
                    n < l - u &&
                    (h =
                      c[
                        a[Math.floor((e - u) / o) * i + Math.floor((n - u) / o)]
                          ? 1
                          : 0
                      ]),
                    (t[d++] = h.r),
                    (t[d++] = h.g),
                    (t[d++] = h.b),
                    (t[d] = h.a);
                }
            });
        })(tB),
          (tC.render = function (e, t, n) {
            var s;
            let i = n,
              a = t;
            !(typeof i > "u") || (t && t.getContext) || ((i = t), (t = void 0)),
              t ||
                (a = (function () {
                  try {
                    return document.createElement("canvas");
                  } catch {
                    throw Error("You need to specify a canvas element");
                  }
                })()),
              (i = tB.getOptions(i));
            let o = tB.getImageWidth(e.modules.size, i),
              l = a.getContext("2d"),
              u = l.createImageData(o, o);
            return (
              tB.qrToImageData(u.data, e, i),
              (s = a),
              l.clearRect(0, 0, s.width, s.height),
              s.style || (s.style = {}),
              (s.height = o),
              (s.width = o),
              (s.style.height = o + "px"),
              (s.style.width = o + "px"),
              l.putImageData(u, 0, 0),
              a
            );
          }),
          (tC.renderToDataURL = function (e, t, n) {
            let s = n;
            !(typeof s > "u") || (t && t.getContext) || ((s = t), (t = void 0)),
              s || (s = {});
            let i = tC.render(e, t, s),
              a = s.type || "image/png",
              o = s.rendererOpts || {};
            return i.toDataURL(a, o.quality);
          });
        var tN = {};
        function tR(e, t) {
          let n = e.a / 255,
            s = t + '="' + e.hex + '"';
          return n < 1
            ? s + " " + t + '-opacity="' + n.toFixed(2).slice(1) + '"'
            : s;
        }
        function tI(e, t, n) {
          let s = e + t;
          return "u" > typeof n && (s += " " + n), s;
        }
        function tM(e, t, n, s, i) {
          let a = [].slice.call(arguments, 1),
            o = a.length,
            l = "function" == typeof a[o - 1];
          if (
            !l &&
            !(
              "function" == typeof Promise &&
              Promise.prototype &&
              Promise.prototype.then
            )
          )
            throw Error("Callback required as last argument");
          if (l) {
            if (o < 2) throw Error("Too few arguments provided");
            2 === o
              ? ((i = n), (n = t), (t = s = void 0))
              : 3 === o &&
                (t.getContext && typeof i > "u"
                  ? ((i = s), (s = void 0))
                  : ((i = s), (s = n), (n = t), (t = void 0)));
          } else {
            if (o < 1) throw Error("Too few arguments provided");
            return (
              1 === o
                ? ((n = t), (t = s = void 0))
                : 2 !== o || t.getContext || ((s = n), (n = t), (t = void 0)),
              new Promise(function (i, a) {
                try {
                  let a = eX.create(n, s);
                  i(e(a, t, s));
                } catch (e) {
                  a(e);
                }
              })
            );
          }
          try {
            let a = eX.create(n, s);
            i(null, e(a, t, s));
          } catch (e) {
            i(e);
          }
        }
        (tN.render = function (e, t, n) {
          let s = tB.getOptions(t),
            i = e.modules.size,
            a = e.modules.data,
            o = i + 2 * s.margin,
            l = s.color.light.a
              ? "<path " +
                tR(s.color.light, "fill") +
                ' d="M0 0h' +
                o +
                "v" +
                o +
                'H0z"/>'
              : "",
            u =
              "<path " +
              tR(s.color.dark, "stroke") +
              ' d="' +
              (function (e, t, n) {
                let s = "",
                  i = 0,
                  a = !1,
                  o = 0;
                for (let l = 0; l < e.length; l++) {
                  let u = Math.floor(l % t),
                    c = Math.floor(l / t);
                  u || a || (a = !0),
                    e[l]
                      ? (o++,
                        (l > 0 && u > 0 && e[l - 1]) ||
                          ((s += a
                            ? tI("M", u + n, 0.5 + c + n)
                            : tI("m", i, 0)),
                          (i = 0),
                          (a = !1)),
                        (u + 1 < t && e[l + 1]) || ((s += tI("h", o)), (o = 0)))
                      : i++;
                }
                return s;
              })(a, i, s.margin) +
              '"/>',
            c =
              '<svg xmlns="http://www.w3.org/2000/svg" ' +
              (s.width
                ? 'width="' + s.width + '" height="' + s.width + '" '
                : "") +
              ('viewBox="0 0 ' + o) +
              " " +
              o +
              '" shape-rendering="crispEdges">' +
              l +
              u +
              `</svg>
`;
          return "function" == typeof n && n(null, c), c;
        }),
          (eZ.create = eX.create),
          (eZ.toCanvas = tM.bind(null, tC.render)),
          (eZ.toDataURL = tM.bind(null, tC.renderToDataURL)),
          (eZ.toString = tM.bind(null, function (e, t, n) {
            return tN.render(e, n);
          }));
        let tL = (e, t) => {
          let n = Array.prototype.slice.call(
              eZ.create(e, { errorCorrectionLevel: t }).modules.data,
              0
            ),
            s = Math.sqrt(n.length);
          return n.reduce(
            (e, t, n) =>
              (n % s == 0 ? e.push([t]) : e[e.length - 1].push(t)) && e,
            []
          );
        };
        function t_({
          ecl: e = "H",
          logoMargin: t = 10,
          logoSize: n = 50,
          size: s = 200,
          uri: i,
        }) {
          let a = s - 2 * parseInt("20", 10),
            o = (0, em.useMemo)(() => {
              let s = [],
                o = tL(i, e),
                l = a / o.length;
              [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: 1 },
              ].forEach(({ x: e, y: t }) => {
                let n = (o.length - 7) * l * e,
                  i = (o.length - 7) * l * t;
                for (let a = 0; a < 3; a++)
                  s.push(
                    (0, eg.jsx)(
                      "rect",
                      {
                        fill: a % 2 != 0 ? "white" : "black",
                        height: l * (7 - 2 * a),
                        rx: -((a - 2) * 5) + (0 === a ? 2 : 0),
                        ry: -((a - 2) * 5) + (0 === a ? 2 : 0),
                        width: l * (7 - 2 * a),
                        x: n + l * a,
                        y: i + l * a,
                      },
                      `${a}-${e}-${t}`
                    )
                  );
              });
              let u = Math.floor((n + 2 * t) / l),
                c = o.length / 2 - u / 2,
                d = o.length / 2 + u / 2 - 1;
              return (
                o.forEach((e, t) => {
                  e.forEach((e, n) => {
                    o[t][n] &&
                      ((t < 7 && n < 7) ||
                        (t > o.length - 8 && n < 7) ||
                        (t < 7 && n > o.length - 8) ||
                        (t > c && t < d && n > c && n < d) ||
                        s.push(
                          (0, eg.jsx)(
                            "circle",
                            {
                              cx: t * l + l / 2,
                              cy: n * l + l / 2,
                              fill: "black",
                              r: l / 3,
                            },
                            `circle-${t}-${n}`
                          )
                        ));
                  });
                }),
                s
              );
            }, [e, n, t, a, i]),
            l = a / 2 - n / 2,
            u = n + 2 * t;
          return (0, eg.jsx)("div", {
            className: "_1n3pr304",
            children: (0, eg.jsxs)("div", {
              className: "_1n3pr305",
              children: [
                (0, eg.jsx)("div", {
                  className: "_1n3pr306",
                  style: { top: l, width: a },
                  children: (0, eg.jsx)(eb, { fill: "purple", height: n }),
                }),
                (0, eg.jsxs)("svg", {
                  height: a,
                  style: { all: "revert" },
                  width: a,
                  children: [
                    (0, eg.jsx)("title", { children: "QR Code" }),
                    (0, eg.jsxs)("defs", {
                      children: [
                        (0, eg.jsx)("clipPath", {
                          id: "clip-wrapper",
                          children: (0, eg.jsx)("rect", {
                            height: u,
                            width: u,
                          }),
                        }),
                        (0, eg.jsx)("clipPath", {
                          id: "clip-logo",
                          children: (0, eg.jsx)("rect", {
                            height: n,
                            width: n,
                          }),
                        }),
                      ],
                    }),
                    (0, eg.jsx)("rect", {
                      fill: "transparent",
                      height: a,
                      width: a,
                    }),
                    o,
                  ],
                }),
              ],
            }),
          });
        }
      },
      94427: function (e, t, n) {
        "use strict";
        n.r(t),
          n.d(t, {
            __addDisposableResource: function () {
              return L;
            },
            __assign: function () {
              return a;
            },
            __asyncDelegator: function () {
              return x;
            },
            __asyncGenerator: function () {
              return T;
            },
            __asyncValues: function () {
              return O;
            },
            __await: function () {
              return k;
            },
            __awaiter: function () {
              return g;
            },
            __classPrivateFieldGet: function () {
              return R;
            },
            __classPrivateFieldIn: function () {
              return M;
            },
            __classPrivateFieldSet: function () {
              return I;
            },
            __createBinding: function () {
              return y;
            },
            __decorate: function () {
              return l;
            },
            __disposeResources: function () {
              return F;
            },
            __esDecorate: function () {
              return c;
            },
            __exportStar: function () {
              return b;
            },
            __extends: function () {
              return i;
            },
            __generator: function () {
              return m;
            },
            __importDefault: function () {
              return N;
            },
            __importStar: function () {
              return B;
            },
            __makeTemplateObject: function () {
              return S;
            },
            __metadata: function () {
              return f;
            },
            __param: function () {
              return u;
            },
            __propKey: function () {
              return h;
            },
            __read: function () {
              return w;
            },
            __rest: function () {
              return o;
            },
            __runInitializers: function () {
              return d;
            },
            __setFunctionName: function () {
              return p;
            },
            __spread: function () {
              return v;
            },
            __spreadArray: function () {
              return P;
            },
            __spreadArrays: function () {
              return E;
            },
            __values: function () {
              return A;
            },
          });
        var s = function (e, t) {
          return (s =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (e, t) {
                e.__proto__ = t;
              }) ||
            function (e, t) {
              for (var n in t)
                Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            })(e, t);
        };
        function i(e, t) {
          if ("function" != typeof t && null !== t)
            throw TypeError(
              "Class extends value " +
                String(t) +
                " is not a constructor or null"
            );
          function n() {
            this.constructor = e;
          }
          s(e, t),
            (e.prototype =
              null === t
                ? Object.create(t)
                : ((n.prototype = t.prototype), new n()));
        }
        var a = function () {
          return (a =
            Object.assign ||
            function (e) {
              for (var t, n = 1, s = arguments.length; n < s; n++)
                for (var i in (t = arguments[n]))
                  Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
              return e;
            }).apply(this, arguments);
        };
        function o(e, t) {
          var n = {};
          for (var s in e)
            Object.prototype.hasOwnProperty.call(e, s) &&
              0 > t.indexOf(s) &&
              (n[s] = e[s]);
          if (null != e && "function" == typeof Object.getOwnPropertySymbols)
            for (
              var i = 0, s = Object.getOwnPropertySymbols(e);
              i < s.length;
              i++
            )
              0 > t.indexOf(s[i]) &&
                Object.prototype.propertyIsEnumerable.call(e, s[i]) &&
                (n[s[i]] = e[s[i]]);
          return n;
        }
        function l(e, t, n, s) {
          var i,
            a = arguments.length,
            o =
              a < 3
                ? t
                : null === s
                ? (s = Object.getOwnPropertyDescriptor(t, n))
                : s;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            o = Reflect.decorate(e, t, n, s);
          else
            for (var l = e.length - 1; l >= 0; l--)
              (i = e[l]) &&
                (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o);
          return a > 3 && o && Object.defineProperty(t, n, o), o;
        }
        function u(e, t) {
          return function (n, s) {
            t(n, s, e);
          };
        }
        function c(e, t, n, s, i, a) {
          function o(e) {
            if (void 0 !== e && "function" != typeof e)
              throw TypeError("Function expected");
            return e;
          }
          for (
            var l,
              u = s.kind,
              c = "getter" === u ? "get" : "setter" === u ? "set" : "value",
              d = !t && e ? (s.static ? e : e.prototype) : null,
              h = t || (d ? Object.getOwnPropertyDescriptor(d, s.name) : {}),
              p = !1,
              f = n.length - 1;
            f >= 0;
            f--
          ) {
            var g = {};
            for (var m in s) g[m] = "access" === m ? {} : s[m];
            for (var m in s.access) g.access[m] = s.access[m];
            g.addInitializer = function (e) {
              if (p)
                throw TypeError(
                  "Cannot add initializers after decoration has completed"
                );
              a.push(o(e || null));
            };
            var y = (0, n[f])(
              "accessor" === u ? { get: h.get, set: h.set } : h[c],
              g
            );
            if ("accessor" === u) {
              if (void 0 === y) continue;
              if (null === y || "object" != typeof y)
                throw TypeError("Object expected");
              (l = o(y.get)) && (h.get = l),
                (l = o(y.set)) && (h.set = l),
                (l = o(y.init)) && i.unshift(l);
            } else (l = o(y)) && ("field" === u ? i.unshift(l) : (h[c] = l));
          }
          d && Object.defineProperty(d, s.name, h), (p = !0);
        }
        function d(e, t, n) {
          for (var s = arguments.length > 2, i = 0; i < t.length; i++)
            n = s ? t[i].call(e, n) : t[i].call(e);
          return s ? n : void 0;
        }
        function h(e) {
          return "symbol" == typeof e ? e : "".concat(e);
        }
        function p(e, t, n) {
          return (
            "symbol" == typeof t &&
              (t = t.description ? "[".concat(t.description, "]") : ""),
            Object.defineProperty(e, "name", {
              configurable: !0,
              value: n ? "".concat(n, " ", t) : t,
            })
          );
        }
        function f(e, t) {
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.metadata
          )
            return Reflect.metadata(e, t);
        }
        function g(e, t, n, s) {
          return new (n || (n = Promise))(function (i, a) {
            function o(e) {
              try {
                u(s.next(e));
              } catch (e) {
                a(e);
              }
            }
            function l(e) {
              try {
                u(s.throw(e));
              } catch (e) {
                a(e);
              }
            }
            function u(e) {
              var t;
              e.done
                ? i(e.value)
                : ((t = e.value) instanceof n
                    ? t
                    : new n(function (e) {
                        e(t);
                      })
                  ).then(o, l);
            }
            u((s = s.apply(e, t || [])).next());
          });
        }
        function m(e, t) {
          var n,
            s,
            i,
            a = {
              label: 0,
              sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1];
              },
              trys: [],
              ops: [],
            },
            o = Object.create(
              ("function" == typeof Iterator ? Iterator : Object).prototype
            );
          return (
            (o.next = l(0)),
            (o.throw = l(1)),
            (o.return = l(2)),
            "function" == typeof Symbol &&
              (o[Symbol.iterator] = function () {
                return this;
              }),
            o
          );
          function l(l) {
            return function (u) {
              return (function (l) {
                if (n) throw TypeError("Generator is already executing.");
                for (; o && ((o = 0), l[0] && (a = 0)), a; )
                  try {
                    if (
                      ((n = 1),
                      s &&
                        (i =
                          2 & l[0]
                            ? s.return
                            : l[0]
                            ? s.throw || ((i = s.return) && i.call(s), 0)
                            : s.next) &&
                        !(i = i.call(s, l[1])).done)
                    )
                      return i;
                    switch (((s = 0), i && (l = [2 & l[0], i.value]), l[0])) {
                      case 0:
                      case 1:
                        i = l;
                        break;
                      case 4:
                        return a.label++, { value: l[1], done: !1 };
                      case 5:
                        a.label++, (s = l[1]), (l = [0]);
                        continue;
                      case 7:
                        (l = a.ops.pop()), a.trys.pop();
                        continue;
                      default:
                        if (
                          !(i = (i = a.trys).length > 0 && i[i.length - 1]) &&
                          (6 === l[0] || 2 === l[0])
                        ) {
                          a = 0;
                          continue;
                        }
                        if (
                          3 === l[0] &&
                          (!i || (l[1] > i[0] && l[1] < i[3]))
                        ) {
                          a.label = l[1];
                          break;
                        }
                        if (6 === l[0] && a.label < i[1]) {
                          (a.label = i[1]), (i = l);
                          break;
                        }
                        if (i && a.label < i[2]) {
                          (a.label = i[2]), a.ops.push(l);
                          break;
                        }
                        i[2] && a.ops.pop(), a.trys.pop();
                        continue;
                    }
                    l = t.call(e, a);
                  } catch (e) {
                    (l = [6, e]), (s = 0);
                  } finally {
                    n = i = 0;
                  }
                if (5 & l[0]) throw l[1];
                return { value: l[0] ? l[1] : void 0, done: !0 };
              })([l, u]);
            };
          }
        }
        var y = Object.create
          ? function (e, t, n, s) {
              void 0 === s && (s = n);
              var i = Object.getOwnPropertyDescriptor(t, n);
              (!i ||
                ("get" in i ? !t.__esModule : i.writable || i.configurable)) &&
                (i = {
                  enumerable: !0,
                  get: function () {
                    return t[n];
                  },
                }),
                Object.defineProperty(e, s, i);
            }
          : function (e, t, n, s) {
              void 0 === s && (s = n), (e[s] = t[n]);
            };
        function b(e, t) {
          for (var n in e)
            "default" === n ||
              Object.prototype.hasOwnProperty.call(t, n) ||
              y(t, e, n);
        }
        function A(e) {
          var t = "function" == typeof Symbol && Symbol.iterator,
            n = t && e[t],
            s = 0;
          if (n) return n.call(e);
          if (e && "number" == typeof e.length)
            return {
              next: function () {
                return (
                  e && s >= e.length && (e = void 0),
                  { value: e && e[s++], done: !e }
                );
              },
            };
          throw TypeError(
            t ? "Object is not iterable." : "Symbol.iterator is not defined."
          );
        }
        function w(e, t) {
          var n = "function" == typeof Symbol && e[Symbol.iterator];
          if (!n) return e;
          var s,
            i,
            a = n.call(e),
            o = [];
          try {
            for (; (void 0 === t || t-- > 0) && !(s = a.next()).done; )
              o.push(s.value);
          } catch (e) {
            i = { error: e };
          } finally {
            try {
              s && !s.done && (n = a.return) && n.call(a);
            } finally {
              if (i) throw i.error;
            }
          }
          return o;
        }
        function v() {
          for (var e = [], t = 0; t < arguments.length; t++)
            e = e.concat(w(arguments[t]));
          return e;
        }
        function E() {
          for (var e = 0, t = 0, n = arguments.length; t < n; t++)
            e += arguments[t].length;
          for (var s = Array(e), i = 0, t = 0; t < n; t++)
            for (var a = arguments[t], o = 0, l = a.length; o < l; o++, i++)
              s[i] = a[o];
          return s;
        }
        function P(e, t, n) {
          if (n || 2 == arguments.length)
            for (var s, i = 0, a = t.length; i < a; i++)
              (!s && i in t) ||
                (s || (s = Array.prototype.slice.call(t, 0, i)), (s[i] = t[i]));
          return e.concat(s || Array.prototype.slice.call(t));
        }
        function k(e) {
          return this instanceof k ? ((this.v = e), this) : new k(e);
        }
        function T(e, t, n) {
          if (!Symbol.asyncIterator)
            throw TypeError("Symbol.asyncIterator is not defined.");
          var s,
            i = n.apply(e, t || []),
            a = [];
          return (
            (s = Object.create(
              ("function" == typeof AsyncIterator ? AsyncIterator : Object)
                .prototype
            )),
            o("next"),
            o("throw"),
            o("return", function (e) {
              return function (t) {
                return Promise.resolve(t).then(e, c);
              };
            }),
            (s[Symbol.asyncIterator] = function () {
              return this;
            }),
            s
          );
          function o(e, t) {
            i[e] &&
              ((s[e] = function (t) {
                return new Promise(function (n, s) {
                  a.push([e, t, n, s]) > 1 || l(e, t);
                });
              }),
              t && (s[e] = t(s[e])));
          }
          function l(e, t) {
            try {
              var n;
              (n = i[e](t)).value instanceof k
                ? Promise.resolve(n.value.v).then(u, c)
                : d(a[0][2], n);
            } catch (e) {
              d(a[0][3], e);
            }
          }
          function u(e) {
            l("next", e);
          }
          function c(e) {
            l("throw", e);
          }
          function d(e, t) {
            e(t), a.shift(), a.length && l(a[0][0], a[0][1]);
          }
        }
        function x(e) {
          var t, n;
          return (
            (t = {}),
            s("next"),
            s("throw", function (e) {
              throw e;
            }),
            s("return"),
            (t[Symbol.iterator] = function () {
              return this;
            }),
            t
          );
          function s(s, i) {
            t[s] = e[s]
              ? function (t) {
                  return (n = !n)
                    ? { value: k(e[s](t)), done: !1 }
                    : i
                    ? i(t)
                    : t;
                }
              : i;
          }
        }
        function O(e) {
          if (!Symbol.asyncIterator)
            throw TypeError("Symbol.asyncIterator is not defined.");
          var t,
            n = e[Symbol.asyncIterator];
          return n
            ? n.call(e)
            : ((e = A(e)),
              (t = {}),
              s("next"),
              s("throw"),
              s("return"),
              (t[Symbol.asyncIterator] = function () {
                return this;
              }),
              t);
          function s(n) {
            t[n] =
              e[n] &&
              function (t) {
                return new Promise(function (s, i) {
                  (function (e, t, n, s) {
                    Promise.resolve(s).then(function (t) {
                      e({ value: t, done: n });
                    }, t);
                  })(s, i, (t = e[n](t)).done, t.value);
                });
              };
          }
        }
        function S(e, t) {
          return (
            Object.defineProperty
              ? Object.defineProperty(e, "raw", { value: t })
              : (e.raw = t),
            e
          );
        }
        var C = Object.create
          ? function (e, t) {
              Object.defineProperty(e, "default", { enumerable: !0, value: t });
            }
          : function (e, t) {
              e.default = t;
            };
        function B(e) {
          if (e && e.__esModule) return e;
          var t = {};
          if (null != e)
            for (var n in e)
              "default" !== n &&
                Object.prototype.hasOwnProperty.call(e, n) &&
                y(t, e, n);
          return C(t, e), t;
        }
        function N(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function R(e, t, n, s) {
          if ("a" === n && !s)
            throw TypeError("Private accessor was defined without a getter");
          if ("function" == typeof t ? e !== t || !s : !t.has(e))
            throw TypeError(
              "Cannot read private member from an object whose class did not declare it"
            );
          return "m" === n ? s : "a" === n ? s.call(e) : s ? s.value : t.get(e);
        }
        function I(e, t, n, s, i) {
          if ("m" === s) throw TypeError("Private method is not writable");
          if ("a" === s && !i)
            throw TypeError("Private accessor was defined without a setter");
          if ("function" == typeof t ? e !== t || !i : !t.has(e))
            throw TypeError(
              "Cannot write private member to an object whose class did not declare it"
            );
          return "a" === s ? i.call(e, n) : i ? (i.value = n) : t.set(e, n), n;
        }
        function M(e, t) {
          if (null === t || ("object" != typeof t && "function" != typeof t))
            throw TypeError("Cannot use 'in' operator on non-object");
          return "function" == typeof e ? t === e : e.has(t);
        }
        function L(e, t, n) {
          if (null != t) {
            var s, i;
            if ("object" != typeof t && "function" != typeof t)
              throw TypeError("Object expected.");
            if (n) {
              if (!Symbol.asyncDispose)
                throw TypeError("Symbol.asyncDispose is not defined.");
              s = t[Symbol.asyncDispose];
            }
            if (void 0 === s) {
              if (!Symbol.dispose)
                throw TypeError("Symbol.dispose is not defined.");
              (s = t[Symbol.dispose]), n && (i = s);
            }
            if ("function" != typeof s)
              throw TypeError("Object not disposable.");
            i &&
              (s = function () {
                try {
                  i.call(this);
                } catch (e) {
                  return Promise.reject(e);
                }
              }),
              e.stack.push({ value: t, dispose: s, async: n });
          } else n && e.stack.push({ async: !0 });
          return t;
        }
        var _ =
          "function" == typeof SuppressedError
            ? SuppressedError
            : function (e, t, n) {
                var s = Error(n);
                return (
                  (s.name = "SuppressedError"),
                  (s.error = e),
                  (s.suppressed = t),
                  s
                );
              };
        function F(e) {
          function t(t) {
            (e.error = e.hasError
              ? new _(t, e.error, "An error was suppressed during disposal.")
              : t),
              (e.hasError = !0);
          }
          var n,
            s = 0;
          return (function i() {
            for (; (n = e.stack.pop()); )
              try {
                if (!n.async && 1 === s)
                  return (s = 0), e.stack.push(n), Promise.resolve().then(i);
                if (n.dispose) {
                  var a = n.dispose.call(n.value);
                  if (n.async)
                    return (
                      (s |= 2),
                      Promise.resolve(a).then(i, function (e) {
                        return t(e), i();
                      })
                    );
                } else s |= 1;
              } catch (e) {
                t(e);
              }
            if (1 === s)
              return e.hasError ? Promise.reject(e.error) : Promise.resolve();
            if (e.hasError) throw e.error;
          })();
        }
        t.default = {
          __extends: i,
          __assign: a,
          __rest: o,
          __decorate: l,
          __param: u,
          __metadata: f,
          __awaiter: g,
          __generator: m,
          __createBinding: y,
          __exportStar: b,
          __values: A,
          __read: w,
          __spread: v,
          __spreadArrays: E,
          __spreadArray: P,
          __await: k,
          __asyncGenerator: T,
          __asyncDelegator: x,
          __asyncValues: O,
          __makeTemplateObject: S,
          __importStar: B,
          __importDefault: N,
          __classPrivateFieldGet: R,
          __classPrivateFieldSet: I,
          __classPrivateFieldIn: M,
          __addDisposableResource: L,
          __disposeResources: F,
        };
      },
    },
  ]);
